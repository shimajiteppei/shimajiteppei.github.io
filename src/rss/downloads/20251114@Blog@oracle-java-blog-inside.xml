<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-11-14T08:37:21+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Deep Dive into Gatherers - JEP Cafe #24</title><link href="https://inside.java/2025/11/14/jepcafe24/" rel="alternate" type="text/html" title="Deep Dive into Gatherers - JEP Cafe #24" /><published>2025-11-14T00:00:00+00:00</published><updated>2025-11-14T00:00:00+00:00</updated><id>https://inside.java/2025/11/14/JEPCafe24</id><content type="html" xml:base="https://inside.java/2025/11/14/jepcafe24/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/fgQQIV3B-uo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This JEP Café takes you through everything you can do with Gatherers, added to JDK 24 and available in JDK 25, the version you are going to use for your business applications.</em> 
<em>Along with many examples, it shows you the basics of mapping and filtering, how you can create and manage an internal mutable state to limit your stream, and sort them.</em> 
<em>It shows you how you can properly interrupt a stream when you need, and how you can avoid resource leaking and race conditions in the use of the API. It also shows you how you can leverage some available optimizations by declaring your integrators greedy when you can.</em> 
<em>One of the greatest features of the Stream API is that you can decide to go parallel. So parallel Gatherers are covered, along with the use of non-parallel Gatherers in parallel streams. At the end of this video you will know eveything you need to write efficient and correct Gatherers, but also when you should use them, and when you should stay away from them.</em></p>

<p>Make sure to check the <a href="https://www.youtube.com/watch?v=fgQQIV3B-uo">show-notes</a>!</p>]]></content><author><name>[&quot;JosePaumard&quot;]</name></author><category term="JDK 25" /><category term="Core Libraries" /><summary type="html"><![CDATA[This JEP Café takes you through everything you can do with Gatherers, added to JDK 24 and available in JDK 25, the version you are going to use for your business applications. Along with many examples, it shows you the basics of mapping and filtering, how you can create and manage an internal mutable state to limit your stream, and sort them. It shows you how you can properly interrupt a stream when you need, and how you can avoid resource leaking and race conditions in the use of the API. It also shows you how you can leverage some available optimizations by declaring your integrators greedy when you can. One of the greatest features of the Stream API is that you can decide to go parallel. So parallel Gatherers are covered, along with the use of non-parallel Gatherers in parallel streams. At the end of this video you will know eveything you need to write efficient and correct Gatherers, but also when you should use them, and when you should stay away from them.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC</title><link href="https://inside.java/2025/11/13/jep516-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC" /><published>2025-11-13T00:00:00+00:00</published><updated>2025-11-13T00:00:00+00:00</updated><id>https://inside.java/2025/11/13/JEP516-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/13/jep516-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?641002286" /></p>]]></content><author><name>[&quot;ErikOsterlund&quot;]</name></author><category term="JDK 26" /><category term="Leyden" /><category term="GC" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC]]></summary></entry><entry><title type="html">The Inside Java Newsletter: The Latest on JavaOne 2026</title><link href="https://inside.java/2025/11/12/inside-java-newsletter/" rel="alternate" type="text/html" title="The Inside Java Newsletter: The Latest on JavaOne 2026" /><published>2025-11-12T00:00:00+00:00</published><updated>2025-11-12T00:00:00+00:00</updated><id>https://inside.java/2025/11/12/Inside-Java-Newsletter</id><content type="html" xml:base="https://inside.java/2025/11/12/inside-java-newsletter/"><![CDATA[<p><img class="webfeedsFeaturedVisual" src="/images/thumbnail/code.jpg" style="display: none;" /></p>]]></content><author><name>[&quot;JimGrisanzio&quot;]</name></author><category term="Oracle" /><category term="Community" /><summary type="html"><![CDATA[The Inside Java Newsletter for October 2025 focuses exclusively on planning for JavaOne 2026. Subscribe for updates via the links in the newsletter and we’ll see you in March 2026! Visit learn.java, dev.java, and inside.java for multimedia content for developers, learners, educators, and customers. See the newsletter archives, subscribe, and send to a friend!]]></summary></entry><entry><title type="html">Serialization 2 0: A Marshalling Update!</title><link href="https://inside.java/2025/11/10/devoxxbelgium-serialization2-0-marshalling-update/" rel="alternate" type="text/html" title="Serialization 2 0: A Marshalling Update!" /><published>2025-11-10T00:00:00+00:00</published><updated>2025-11-10T00:00:00+00:00</updated><id>https://inside.java/2025/11/10/DevoxxBelgium-Serialization2.0-Marshalling-Update</id><content type="html" xml:base="https://inside.java/2025/11/10/devoxxbelgium-serialization2-0-marshalling-update/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/F89sNgG9dRY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Almost three decades have passed since the creation of Java Serialization—a feature which is widely frowned upon—and application requirements for externalization of objects have changed significantly.This presentation explains in which way requirements and constraints have changed, and how recent enhancements of the Java Language together with a simpler and clearer division of responsibilities can lead to a dramatically simpler, and safer, model for programmatically reasoning about the structure of Objects; offer greater flexibility in state extraction, versioning, encoding, and reconstruction; and, support a wide selection of wire formats.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;ViktorKlang&quot;]</name></author><category term="Core Libraries" /><summary type="html"><![CDATA[Almost three decades have passed since the creation of Java Serialization—a feature which is widely frowned upon—and application requirements for externalization of objects have changed significantly.This presentation explains in which way requirements and constraints have changed, and how recent enhancements of the Java Language together with a simpler and clearer division of responsibilities can lead to a dramatically simpler, and safer, model for programmatically reasoning about the structure of Objects; offer greater flexibility in state extraction, versioning, encoding, and reconstruction; and, support a wide selection of wire formats.]]></summary></entry><entry><title type="html">Pulling the (Foreign) String</title><link href="https://inside.java/2025/11/08/ffm-string/" rel="alternate" type="text/html" title="Pulling the (Foreign) String" /><published>2025-11-08T00:00:00+00:00</published><updated>2025-11-08T00:00:00+00:00</updated><id>https://inside.java/2025/11/08/FFM-String</id><content type="html" xml:base="https://inside.java/2025/11/08/ffm-string/"><![CDATA[<p>The Foreign Function &amp; Memory (FFM) API comes equipped with methods to read, writes strings from/to memory segments, as well as to allocate memory segments from existing Java strings. In this document we’ll explore ways in which we can enhance the FFM API to support more efficient interoperability between strings and memory segments…</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg?632676731" /></p>]]></content><author><name>[&quot;MaurizioCimadamore&quot;]</name></author><category term="Panama" /><summary type="html"><![CDATA[The Foreign Function & Memory (FFM) API comes equipped with methods to read, writes strings from/to memory segments, as well as to allocate memory segments from existing Java strings. In this document we'll explore ways in which we can enhance the FFM API to support more efficient interoperability between strings and memory segments...]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 500: Prepare to Make Final Mean Final</title><link href="https://inside.java/2025/11/07/jep500-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 500: Prepare to Make Final Mean Final" /><published>2025-11-07T00:00:00+00:00</published><updated>2025-11-07T00:00:00+00:00</updated><id>https://inside.java/2025/11/07/JEP500-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/07/jep500-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 500: Prepare to Make Final Mean Final</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?630239334" /></p>]]></content><author><name>[&quot;RonPressler&quot;, &quot;AlexBuckley&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><category term="Java Language" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 500: Prepare to Make Final Mean Final]]></summary></entry><entry><title type="html">Try the New Valhalla EA Build - Inside Java Newscast #100</title><link href="https://inside.java/2025/11/06/newscast-100/" rel="alternate" type="text/html" title="Try the New Valhalla EA Build - Inside Java Newscast #100" /><published>2025-11-06T00:00:00+00:00</published><updated>2025-11-06T00:00:00+00:00</updated><id>https://inside.java/2025/11/06/Newscast-100</id><content type="html" xml:base="https://inside.java/2025/11/06/newscast-100/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/Eua3nTkye2Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>JEP 401, Value Classes and Objects, has recently re-entered “candidate” status and is getting ready to target a release.</em> 
<em>In preparation, Project Valhalla published a new early-access build that allows you to experiment with identity-less value classes in Java.</em> 
<em>A value class’ lack of identity not only comes with readability and maintenance benefits for developers (where their limitations apply) but also gives the Java runtime the space it needs for more optimizations - scalarization and some heap flattening for now, although more is planned for the future.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=Eua3nTkye2Y">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[JEP 401, Value Classes and Objects, has recently re-entered "candidate" status and is getting ready to target a release. In preparation, Project Valhalla published a new early-access build that allows you to experiment with identity-less value classes in Java. A value class' lack of identity not only comes with readability and maintenance benefits for developers (where their limitations apply) but also gives the Java runtime the space it needs for more optimizations - scalarization and some heap flattening for now, although more is planned for the future.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization</title><link href="https://inside.java/2025/11/05/jep522-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization" /><published>2025-11-05T00:00:00+00:00</published><updated>2025-11-05T00:00:00+00:00</updated><id>https://inside.java/2025/11/05/JEP522-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/05/jep522-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?624191370" /></p>]]></content><author><name>[&quot;IvanWalulya&quot;, &quot;ThomasSchatzl&quot;]</name></author><category term="JDK 26" /><category term="GC" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization]]></summary></entry><entry><title type="html">Integrity by Default</title><link href="https://inside.java/2025/11/04/javaone-integrity-by-default/" rel="alternate" type="text/html" title="Integrity by Default" /><published>2025-11-04T00:00:00+00:00</published><updated>2025-11-04T00:00:00+00:00</updated><id>https://inside.java/2025/11/04/JavaOne-Integrity-By-Default</id><content type="html" xml:base="https://inside.java/2025/11/04/javaone-integrity-by-default/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/uTPRTkny7kQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>To assist performance, portability, and security, the Java Platform is progressing toward a state where its abstractions, as well as programmer-defined abstractions, can be made robust and invariants can be locally guaranteed. Libraries may violate some invariants but only if selectively allowed by the application. This session covers the why and how of the vision of “Integrity by Default”.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzVV1xRJkRbcM2tOgVwytJAi">JavaOne 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;RonPressler&quot;]</name></author><category term="Core Libraries" /><category term="Security" /><summary type="html"><![CDATA[To assist performance, portability, and security, the Java Platform is progressing toward a state where its abstractions, as well as programmer-defined abstractions, can be made robust and invariants can be locally guaranteed. Libraries may violate some invariants but only if selectively allowed by the application. This session covers the why and how of the vision of "Integrity by Default".]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 25: Consistent Behavior of ‘new File(“”)’</title><link href="https://inside.java/2025/11/03/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 25: Consistent Behavior of ‘new File(“”)’" /><published>2025-11-03T00:00:00+00:00</published><updated>2025-11-03T00:00:00+00:00</updated><id>https://inside.java/2025/11/03/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/11/03/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of a <a href="https://mail.openjdk.org/pipermail/quality-discuss/2025-February/001141.html">regular communication</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="inconsistencies-of-new-file">Inconsistencies of ‘new File(“”)’</h2>

<p>On JDK 24 and earlier, the behavior of a <code class="language-plaintext highlighter-rouge">File</code> instance created from the empty string was inconsistent.
Queried for information, it appeared to be non-existent:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "false" on JDK 24</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>Similarly, methods like <code class="language-plaintext highlighter-rouge">canRead</code> returned <code class="language-plaintext highlighter-rouge">false</code> and <code class="language-plaintext highlighter-rouge">length</code>, <code class="language-plaintext highlighter-rouge">lastModified</code>, etc. returned <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>When transformed to an instance representing the absolute path, the behavior changed, though:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">).</span><span class="na">getAbsoluteFile</span><span class="o">();</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>The reason is that <code class="language-plaintext highlighter-rouge">new File("").getAbsoluteFile()</code> maps to the current user directory and the <code class="language-plaintext highlighter-rouge">File</code> API behaves accordingly.
Since <code class="language-plaintext highlighter-rouge">new File("")</code> and <code class="language-plaintext highlighter-rouge">new File("").getAbsoluteFile()</code> should represent the same file system entry, this inconsistency is jarring and can be surprising.</p>

<p>The newer API in <code class="language-plaintext highlighter-rouge">java.nio.file</code> avoids this issue and treats both <code class="language-plaintext highlighter-rouge">Path.of("")</code> and <code class="language-plaintext highlighter-rouge">Path.of("").toAbsolutePath()</code> as the current user directory.
For example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">();</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
</code></pre></div></div>

<h2 id="change-in-jdk-25">Change in JDK 25</h2>

<p>JDK 25 fixed this long-standing inconsistency and <code class="language-plaintext highlighter-rouge">new File("")</code> now properly represents the current user directory:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "true" on JDK 25</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>The <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/File.html">Javadoc for <code class="language-plaintext highlighter-rouge">File</code></a> was updated to spell out the intended behavior:</p>

<blockquote>
  <p>Accessing a file with the empty abstract pathname is equivalent to accessing the current user directory.</p>
</blockquote>

<p>For more details, check <a href="https://bugs.openjdk.org/browse/JDK-8024695">JDK-8024695</a>.</p>

<h2 id="migration">Migration</h2>

<p>Code that relies on the old behavior is often found in unit tests (e.g. to intentionally create non-existent files with <code class="language-plaintext highlighter-rouge">new File("")</code>) or where user input is mapped to file system entries (e.g. to treat “no user entry” and “invalid user entry” the same: as an absent file).
Here it may show itself through misbehavior around file-related arguments or configuration.</p>

<p>While fixing such code should be straightforward, identifying it may not be - a thorough test suite helps.
For dependencies and tools, the recommendation is to rely on their tests and statements regarding JDK 25 compatibility.
Only they can fix potential issues as there is no way to restore the inconsistent behavior of JDK 24 and earlier.</p>

<center>~</center>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 25" /><category term="Core Libraries" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers the behavioral change of `File` instances that were created from the empty path.]]></summary></entry></feed>