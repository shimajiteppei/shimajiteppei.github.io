<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	 xmlns:media="http://search.yahoo.com/mrss/" >

<channel>
	<title>Kotlin : A concise multiplatform language developed by JetBrains | The JetBrains Blog</title>
	<atom:link href="https://blog.jetbrains.com/kotlin/feed/" rel="self" type="application/rss+xml" />
	<link>https://blog.jetbrains.com</link>
	<description>Developer Tools for Professionals and Teams</description>
	<lastBuildDate>Thu, 22 Jan 2026 13:55:02 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-32x32.png</url>
	<title>Kotlin : A concise multiplatform language developed by JetBrains | The JetBrains Blog</title>
	<link>https://blog.jetbrains.com</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>How to Avoid Common Pitfalls With JPA and Kotlin</title>
		<link>https://blog.jetbrains.com/idea/2026/01/how-to-avoid-common-pitfalls-with-jpa-and-kotlin/</link>
		
		<dc:creator><![CDATA[Teodor Irkhin]]></dc:creator>
		<pubDate>Tue, 20 Jan 2026 17:25:41 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/IJ-social-BlogFeatured-1280x720-1-1.png</featuredImage>		<product ><![CDATA[kotlin]]></product>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[tutorials]]></category>
		<category><![CDATA[jpa]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=idea&#038;p=669971</guid>

					<description><![CDATA[This post was written together with Thorben Janssen, who has more than 20 years of experience with JPA and Hibernate and is the author of &#8220;Hibernate Tips: More than 70 Solutions to Common Hibernate Problems&#8221; and the JPA newsletter. Kotlin and Jakarta Persistence (also known as JPA) are a popular combination for server-side development. Kotlin [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><em>This post was written together with <a href="https://thorben-janssen.com/" data-type="link" data-id="https://thorben-janssen.com/" target="_blank" rel="noopener">Thorben Janssen</a>, who has more than 20 years of experience with JPA and Hibernate and is the author of &#8220;Hibernate Tips: More than 70 Solutions to Common Hibernate Problems&#8221; and the JPA newsletter.</em></p>



<p>Kotlin and Jakarta Persistence (also known as JPA) are a popular combination for server-side development. Kotlin offers concise syntax and modern language features, while Jakarta Persistence provides a proven persistence framework for enterprise applications.</p>



<p>However, Jakarta Persistence was originally designed for Java. Some of Kotlin’s popular features and concepts, like null safety and data classes, help you tremendously when implementing your business logic, but they don’t align well with the specification.</p>



<p>This article outlines a set of best practices to help you avoid problems and build reliable persistence layers with Kotlin and Jakarta Persistence. And to share some good news before diving in, IntelliJ IDEA 2026.1 will automatically detect many of these issues, highlight them with warnings, and provide support through various inspections.</p>



<h2 class="wp-block-heading" id="entity-class-design"><strong>Entity class design</strong></h2>



<p>Jakarta Persistence defines several <a href="https://jakarta.ee/specifications/persistence/3.2/jakarta-persistence-spec-3.2#a18" target="_blank" rel="noopener">requirements</a> for entity classes that form the foundation for how persistence providers manage entity objects.</p>



<p>An entity class must:</p>



<ul>
<li><strong>Provide a no-argument constructor</strong><strong><br></strong>The persistence provider uses reflection to call the no-argument constructor to create entity instances when loading data from the database.</li>



<li><strong>Have non-final attributes</strong><strong><br></strong>When fetching an entity object from the database, the persistence provider sets all attribute values after it calls the no-argument constructor to instantiate the entity object. This process is called hydration.<br>After that is done, the persistence provider keeps a reference to the entity object to perform automatic dirty checks, during which it detects changes and updates the corresponding database records automatically.</li>



<li><strong>Be non-final</strong><strong><br></strong>The persistence provider often creates proxy subclasses to implement features such as <a href="https://www.baeldung.com/hibernate-lazy-eager-loading" target="_blank" rel="noopener">lazy loading</a> for @ManyToOne and @OneToOne relationships. For this to work, the entity class can’t be final.<br></li>
</ul>



<p>In addition to these specification requirements, it is a widely accepted best practice to:</p>



<ul>
<li><strong>Implement <code>equals</code>, <code>hashCode</code>, and <code>toString</code> carefully<br></strong>These methods should rely only on the entity’s identifier and type to avoid unexpected behavior in persistence contexts. You can find approaches for better implementing those <a href="https://thorben-janssen.com/ultimate-guide-to-implementing-equals-and-hashcode-with-hibernate/" target="_blank" rel="noopener">here</a>.<br></li>
</ul>



<p>These rules are easy to follow in Java but conflict with some of Kotlin’s defaults, such as final classes, immutable properties, and constructor-based initialization.<br><br>The following sections show how to adapt your Kotlin classes to meet these requirements while still using Kotlin’s language features effectively.</p>



<h3 class="wp-block-heading">Data classes vs. entities</h3>



<p><a href="https://kotlinlang.org/docs/data-classes.html" target="_blank" rel="noopener">Kotlin’s data classes</a> are designed to hold data. They are final and provide several utility methods, including getters and setters for all fields, as well as <code>equals</code>, <code>hashCode</code>, and <code>toString</code>.</p>



<p>This makes data classes a great fit for DTOs, which represent query results and are not managed by your persistence provider.</p>



<p>Below is a typical usage of a data class to fetch data:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">data class EmployeeWithCompany(val employeeName: String, val companyName: String)

val query = entityManager.createQuery("""
   SELECT new com.company.kotlin.model.EmployeeWithCompany(p.name, c.name)
    FROM Employee e
       JOIN e.company c
    WHERE p.id = :id""")

val employeeWithCompany = query.setParameter("id", 1L).singleResult;</pre>



<p>However, entities differ because they are managed objects. And that causes problems when you model them as a data class.</p>



<p>For entities, the persistence provider automatically detects changes and uses lazy loading for relationships. To support this, it expects entity classes to follow the requirements defined in the Jakarta Persistence specification, which we discussed at the beginning of this chapter.&nbsp;</p>



<p>As you can see in the following table, that makes Kotlin’s data classes a bad fit for entity classes.</p>



<figure class="wp-block-table"><table><tbody><tr><td></td><td><strong>Kotlin Data Class</strong></td><td><strong>Jakarta Persistence Entity</strong></td></tr><tr><td><strong>Class Type</strong></td><td>Final</td><td>Must be open (non-final) so the provider can create proxy subclasses</td></tr><tr><td><strong>Constructors</strong></td><td>Primary constructor with required parameters</td><td>Must provide a no-argument constructor, used by the persistence provider</td></tr><tr><td><strong>Mutability</strong></td><td>Immutable by default (val properties)</td><td>Must have mutable, non-final attributes so the provider can perform lazy loading as well as detect and persist changes</td></tr><tr><td><strong>equals</strong><strong> and </strong><strong>hashCode</strong></td><td>Use all properties</td><td>Should rely only on type and primary key</td></tr><tr><td><strong>toString</strong></td><td>Includes all properties</td><td>Should only reference eagerly loaded attributes to avoid additional queries</td></tr></tbody></table></figure>



<p>The recommended approach is to use regular open classes to model your entities. They are mutable and proxy-friendly, and they don’t cause any issues with Jakarta Persistence.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
open class Person {
   @Id
   @GeneratedValue
   var id: Long? = null

   var name: String? = null
}</pre>



<h3 class="wp-block-heading">Non-final classes and no-argument constructors</h3>



<p><a href="#entity-class-design">As discussed earlier</a>, Jakarta Persistence requires entity classes to be non-final and provide a no-argument constructor.&nbsp;</p>



<p>Kotlin’s classes are final by default and don’t have to offer a no-argument constructor.</p>



<p>But don’t worry, it’s easy to fulfill the requirements without changing your code or implementing your entity classes in a specific way. Just add the no-arg and all-open plugins and add <a href="https://kotlinlang.org/docs/reflection.html" target="_blank" rel="noopener">kotlin-reflect</a> to your dependencies. This adds the required constructor and marks annotated classes as open at build time.</p>



<p>Currently, you need the compiler plugins <code>plugin.spring</code> and <code>plugin.jpa</code>, which will automatically add the no-arg and all-open plugins. When creating a new Spring project using the <em>New Project</em> wizard in IntelliJ IDEA or via <a href="http://start.spring.io" target="_blank" rel="noopener">start.spring.io</a>, both plugins are automatically configured for you. And starting with IntelliJ IDEA 2026.1, this will also be the case when you add a Kotlin file to an existing Java project.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">plugins {
   kotlin("plugin.spring") version "2.2.20"
   kotlin("plugin.jpa") version "2.2.20"
}

allOpen {
   annotation("jakarta.persistence.Entity")
   annotation("jakarta.persistence.MappedSuperclass")
   annotation("jakarta.persistence.Embeddable")
}</pre>



<p>When configuring this manually, pay close attention to both parts of this setup. <code>plugin.jpa</code> appears to provide the required configuration, but it only configures the no-arg plugin, not the all-open one. This will be improved with the upcoming JPA plugin update. You will then no longer have to add the allOpen section. See: <a href="https://youtrack.jetbrains.com/issue/KT-79389/Add-allopen-plugin-JPA-preset-to-kotlin.plugin.jpa" target="_blank" rel="noopener">KT-79389</a></p>



<h2 class="wp-block-heading">Mutability</h2>



<p>As a Kotlin developer, you’re used to analyzing whether information is mutable or immutable and modelling your classes accordingly. And when defining your entities, you might want to do the same. But that creates potential issues.</p>



<h3 class="wp-block-heading"><code>var</code> vs. <code>val</code></h3>



<p>In Kotlin, you use val to define an immutable field or property and var for mutable ones. Under the hood, val is compiled in Java to a final field. But as discussed earlier, the Jakarta Persistence specification requires all fields to be non-final.</p>



<p>So, in theory, you can’t use val when modelling your entities. However, if you look at various projects, you can find several entities that use val without causing any bugs.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Person(name: String) {
   @Id
   @GeneratedValue
   var id: Long? = null

   val name: String = name
}</pre>



<p>That’s because your Jakarta Persistence implementation, the persistence provider, populates entity fields through reflection if you use field-based access, which is usually the case when implementing Jakarta Persistence entities in Kotlin. <code>final</code> fields can also be <a href="https://docs.oracle.com/javase/specs/jls/se25/html/jls-17.html#jls-17.5.3" target="_blank" rel="noopener">modified using reflection</a>. As a result, your persistence provider can modify val fields, but this contradicts Kotlin’s immutability guarantees.</p>



<p>So, practically, you can use <code>val</code> to model immutable fields of your entity class. Still, it’s not in line with the Jakarta Persistence specification, and your fields are not as immutable as you might expect. To make it even worse, <a href="https://openjdk.org/jeps/500" target="_blank" rel="noopener">JEP 500: Prepare to Make Final Mean Final</a> discusses introducing a warning and future changes to restrict final field modifications via reflection. This would prevent you from using <code>val</code> on your entity fields and break many persistence layers using Jakarta Persistence and Kotlin.</p>



<p>Be careful when using <code>val</code> for your entity fields and make sure everyone on your team understands the implications.</p>



<p>Starting with version 2026.1, IntelliJ IDEA will display a weak warning indicating that a val field will be modified when the persistence provider, such as Hibernate or EclipseLink, instantiates the entity object.</p>



<h2 class="wp-block-heading">Access types</h2>



<p>The Jakarta Persistence specification defines two access types that determine if your persistence provider uses getter and setter methods to access your entity’s fields or reflection.</p>



<p>You can define the access type explicitly by annotating your entity class with the <code>@Access</code> annotation. Or, as almost all development teams do, define it implicitly by where you place your mapping annotations:</p>



<ul>
<li>Annotations on entity fields → field access = direct access using reflection</li>



<li>Annotations on getter methods → property access = access via getter or setter methods</li>
</ul>



<p>Most Kotlin developers put their annotations on properties, which Hibernate treats as field access by default.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
   @Id
   @GeneratedValue
   var id: Long? = null

   var name: String? = null
       get() {
           println("Getter called")
           return field
       }
       set(value) {
           println("Setter called")
           field = value
       }
}</pre>



<p>In this example, it might look like the getter and setter methods will be called to access the name property. But that’s only the case for your business logic. Because we annotated the fields, the persistence provider will use reflection to access them directly, bypassing the getter and setter methods.</p>



<p>As a general best practice, it’s recommended to stick to field access. It’s easier to read and lets your persistence provider access the entity’s fields directly. You can then provide getter and setter methods that help your business code without affecting your database mapping.</p>



<p>If you want to use property access, you can either annotate your entity class with <code>@Access(AccessType.PROPERTY)</code> or annotate the accessors explicitly:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
   @get:Id
   @get:GeneratedValue
   var id: Long? = null

   var name: String? = null
       get() {
           println("Getter called")
           return field
       }
       set(value) {
           println("Setter called")
           field = value
       }
}</pre>



<p>However, when you do this, you must ensure that all fields are defined as <code>var</code>. Kotlin doesn’t provide setter methods for fields defined as <code>val</code>.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
   @get:Id
   @get:GeneratedValue
   var id: Long? = null

   val name: String? = null 
}</pre>



<p>You can see this when checking Kotlin’s decompiled bytecode of a snippet above.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import kotlin.Metadata;
import org.jetbrains.annotations.Nullable;


@Entity
…
public final class Company {
  @Nullable
  private Long id;
  @Nullable
  private final String name;

  @Id
  @GeneratedValue
  @Nullable
  public final Long getId() {
     return this.id;
  }

  public final void setId(@Nullable Long var1) {
     this.id = var1;
  }

  @Nullable
  public final String getName() {
     return this.name;
  }
}
</pre>



<p>Your persistence provider will check that each field has a getter and a setter method. As long as you use var to define your entity fields, property access works with Kotlin.</p>



<h2 class="wp-block-heading">Null safety and default values</h2>



<p>Null safety and default values are two popular features in Kotlin that don’t exist in that form in Java. It’s no surprise that you have to pay special attention if you want to use them in your Jakarta Persistence entities.</p>



<h3 class="wp-block-heading">Nullability considerations (including primary key fields)</h3>



<p>Kotlin allows you to define whether a field or property supports <code>null </code>values. Unfortunately, reflection can bypass Kotlin&#8217;s null prevention, and as explained earlier, the persistence provider uses reflection to initialize your entity objects.</p>



<p>Even if you define an entity attribute as non-nullable, your persistence provider will set it to <code>null</code> if the database contains a <code>null</code> value. In your business code, this can lead to runtime exceptions similar to those seen in Java.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
@Table(name = "user")
class User(
   @Id
   var id: Long? = null

   var name: String
)

fun testLogic(){
   // Suppose the row with id = 1 has name = NULL in the database
   val user = userRepository.findById(1).get()
   println("Firstname: ${user.name}") // null, because Hibernate saves null via reflection
}</pre>



<p>And unfortunately, solving this problem is not as easy as it seems.</p>



<p>You could argue that all non-nullable entity fields should map to a database column with a not-null constraint. So, your database can’t contain any <code>null</code> values.</p>



<p>In general, this is a great approach. But it does not eliminate the risk completely. Constraints can get out of sync between different environments or during migrations. Therefore, using not-null constraints on your database is highly recommended, but it doesn’t provide an unbreakable guarantee that you will never fetch a <code>null</code> value from the database.</p>



<p>To make it even worse, all Jakarta Persistence implementations call the no-argument constructor of your entity class to instantiate an object and then use reflection to initialize each field. This means that technically, all your entity fields must be nullable.</p>



<p>What does that mean for your entities? Should you use <code>val</code> or <code>var</code> to model your fields?</p>



<p>That decision is ultimately up to you. Both of them work, but we recommend sticking to the Kotlin way: Use <code>val</code> if an entity field is not supposed to be changed by your business logic, and <code>var</code> otherwise. However, due to the issues discussed earlier, it is also essential to ensure that everyone on your team is aware that your Jakarta Persistence implementation may set those fields to <code>null</code> if your database lacks a not-null constraint.</p>



<h3 class="wp-block-heading">@Id and generated value</h3>



<p>The previous paragraphs already discussed why all entity fields should be nullable. However, many developers consider primary key attributes to be distinct because the database requires a primary key value, and the Jakarta Persistence specification defines it as immutable. Primary keys are mandatory and immutable as soon as you persist the entity object in your database. But let’s quickly discuss why this doesn’t mean that primary key values should be not-nullable, especially if you’re using database-generated primary key values.</p>



<p>When you want to store a new record in your database, you create a new entity object without a primary key and persist it.&nbsp;</p>



<p>Unfortunately, the Jakarta Persistence specification doesn’t clearly define how to implement the persist operation. But it requires generating a primary key value if none is provided. The handling of provided primary key values differs across implementations, but that’s a topic for a different article.&nbsp;</p>



<p>The important thing here is that all persistence providers treat null as a not-provided primary key value. They then use a database sequence or an auto-incremented column to generate a primary key value and set it on the entity object. Due to this mechanism, the primary key value is <code>null </code>before the entity gets persisted, and changes during the persist operation.</p>



<p>An interesting side note is that Hibernate handles the primary key value 0 differently when calling the persist or the merge method. The persist method throws an exception because it expects the object to be an already-persisted entity. In contrast, Hibernate’s merge method generates a new primary key value and inserts a new record into the database. That’s why you can model a primary key with the default value 0 and save the new entity object using Spring Data JPA. The default repository implementation recognizes the already set primary key value and calls the merge method instead of the persist method.</p>



<p>Now, returning to the initialization of primary key fields.</p>



<p>When you fetch an entity object from the database, your persistence provider uses the parameterless constructor to instantiate a new object. It then uses reflection to set the primary key value before it returns the entity object to your business code.</p>



<p>All of this clearly shows that the Jakarta Persistence specification expects the primary key field to be mutable, even though the primary key value is not allowed to change after it was assigned. To avoid any portability issues across different Jakarta Persistence implementations, use <code>null </code>to represent an undefined primary key value.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
   @Id
   @GeneratedValue
   var id: Long? = null
}</pre>



<h3 class="wp-block-heading">Declaring default values</h3>



<p>Kotlin’s support for default values can simplify your business code and prevent <code>null</code> values.&nbsp;</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company(
   @Id @GeneratedValue 
   var id: Long? = null,

   @NotNull
   var name: String = "John Doe",

   @Email
   var email: String = "default@email.com"
)</pre>



<p>However, please be aware that these default values will have no effect when your persistence provider fetches an entity object from the database.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val companyFromDb = companyRepository.findById(1).get()
println(companyFromDb.email) // &lt;- If email in DB is empty, it will not set to "default@email.com"</pre>



<p>The Jakarta Persistence specification requires a parameterless constructor that the implementations call when fetching an entity object from the database. After that, they use reflection to map all values retrieved from the database to the corresponding entity fields. As a result, the default values defined in your constructor will not be used, and some fields of your entity object might not be set even though you expect your constructor to assign default values. This may not cause any issues in your application, but it is something you and your team should be aware of.</p>



<h2 class="wp-block-heading">Annotation placement</h2>



<p>In Java, annotations are typically applied directly to the field, method, or class you annotate. In Kotlin, by contrast, annotations can target different elements, such as constructor parameters, properties, or fields.</p>



<p>Before Kotlin 2.2, this often caused problems because annotations applied to properties were applied only to the constructor parameter by default. This often caused problems for Jakarta Persistence and validation frameworks. Annotations like <code>@NotNull</code>, <code>@Email</code>, or even <code>@Id</code> didn&#8217;t end up where the framework expected them to be. This led to missed validations or mapping issues.</p>



<p>The good news is that this has been improved in Kotlin 2.2. With the new compiler option, which IntelliJ IDEA will suggest enabling, annotations will be applied to the constructor parameter and the property or field by default. So, your code now works as expected without requiring any changes.</p>



<p>To learn more, check out the <a href="https://blog.jetbrains.com/idea/2025/09/improved-annotation-handling-in-kotlin-2-2-less-boilerplate-fewer-surprises/">blog post</a>.</p>



<h2 class="wp-block-heading">IntelliJ IDEA to the rescue!</h2>



<p>In the upcoming 2026.1 release, IntelliJ IDEA will provide inspections and quick-fixes to address many of the problems mentioned in this article, thereby improving your overall experience. Be sure to update when the release becomes available. Here are a few examples of what you’ll get with the new release:</p>



<ul>
<li>Highlighting missing no-arg constructors or final entity classes and suggestions to enable the correct Kotlin plugins.</li>



<li>Autoconfiguration of all essential setup when configuring Kotlin in the project.</li>



<li>Detection and quick fix for data classes and val fields on JPA-managed properties.</li>
</ul>



<p>And other JPA-related updates!</p>



<h2 class="wp-block-heading"><strong>About the author</strong></h2>


    <div class="about-author ">
        <div class="about-author__box">
            <div class="row">
                                                            <div class="about-author__box-img">
                            <img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/Thorben-Janssen-400x400-1.jpg" alt="" loading="lazy">
                        </div>
                                        <div class="about-author__box-text">
                                                    <h4>Thorben Janssen</h4>
                                                <div class="p-client_container">
<div class="p-ia4_client_container">
<div class="p-ia4_client p-ia4_client--sidebar-wide p-ia4_client--with-split-view-feature">
<div class="p-client_workspace_wrapper" role="tabpanel" aria-label="JetBrains">
<div class="p-client_workspace">
<div class="p-client_workspace__layout">
<div class="p-client_workspace__tabpanel" role="tabpanel" aria-label="DMs">
<div class="enabled-managed-focus-container" role="none">
<div>
<div class="p-view_contents p-view_contents--primary" tabindex="-1" role="dialog" aria-label="Conversation with Teodor Irkhin">
<div class="tabbed_channel__Abx5r">
<div class="tabbed_channel__Abx5r">
<div class="channel_tab_panel__zJ5Bt c-tabs__tab_panel c-tabs__tab_panel--active c-tabs__tab_panel--full_height" role="none" data-qa="tabs_content_container">
<div class="p-file_drag_drop__container">
<div class="p-workspace__primary_view_body">
<div class="p-message_pane p-message_pane--classic-nav p-message_pane--scrollbar-float-adjustment p-message_pane--with-bookmarks-bar" data-qa="message_pane">
<div>
<div id="message-list" role="presentation">
<div id="message-list" class="c-virtual_list c-virtual_list--scrollbar c-message_list c-scrollbar c-scrollbar--fade" role="presentation">
<div class="c-scrollbar__hider" role="presentation" data-qa="slack_kit_scrollbar">
<div class="c-scrollbar__child" role="presentation">
<div class="c-virtual_list__scroll_container" role="presentation" data-qa="slack_kit_list">
<div id="message-list_1766072525.327379" class="c-virtual_list__item" tabindex="0" role="listitem" aria-setsize="-1" data-qa="virtual-list-item" data-item-key="1766072525.327379">
<div class="c-message_kit__background c-message_kit__background--hovered p-message_pane_message__message c-message_kit__message" role="presentation" data-qa="message_container" data-qa-unprocessed="false" data-qa-placeholder="false" data-msg-ts="1766072525.327379" data-msg-channel-id="D072Y30UX54">
<div class="c-message_kit__hover c-message_kit__hover--hovered" role="document" aria-roledescription="message" data-qa-hover="true">
<div class="c-message_kit__actions c-message_kit__actions--above">
<div class="c-message_kit__gutter">
<div class="c-message_kit__gutter__right" role="presentation" data-qa="message_content">
<div class="c-message_kit__blocks c-message_kit__blocks--rich_text">
<div class="c-message__message_blocks c-message__message_blocks--rich_text" data-qa="message-text">
<div class="p-block_kit_renderer" data-qa="block-kit-renderer">
<div class="p-block_kit_renderer__block_wrapper p-block_kit_renderer__block_wrapper--first">
<div class="p-rich_text_block" dir="auto">
<p>Thorben Janssen is a consultant and trainer who helps teams build better persistence layers with JPA and Hibernate. An international speaker with more than 20 years of experience in JPA and Hibernate, Thorben is the author of the best-selling book <i data-stringify-type="italic">Hibernate Tips: More than 70 solutions to common Hibernate problems</i>.</p>
<p>He also writes on thorben-janssen.com about various persistence topics, and to help developers improve their skills, he founded the Persistence Hub.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
                    </div>
                            </div>
        </div>
    </div>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Update your Kotlin projects for Android Gradle Plugin 9.0</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/update-your-projects-for-agp9/</link>
		
		<dc:creator><![CDATA[Márton Braun]]></dc:creator>
		<pubDate>Fri, 16 Jan 2026 10:30:56 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/KT-social-BlogFeatured-1280x720-1-10.png</featuredImage>		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=673033</guid>

					<description><![CDATA[Android Gradle plugin 9.0 is now available, and it includes two major changes that will affect existing Kotlin projects: This post provides some details about these changes and points you to the resources that you’ll need to update your existing projects. You’ll also need to update tools and plugins that depend on AGP to their [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><a href="https://developer.android.com/build/releases/agp-9-0-0-release-notes" target="_blank" rel="noopener">Android Gradle plugin 9.0</a> is now available, and it includes two major changes that will affect existing Kotlin projects:</p>



<ul>
<li>Android apps need to start using AGP 9.0’s <strong>built-in Kotlin support</strong>.</li>



<li>Kotlin Multiplatform projects targeting Android need to migrate to the <strong>new Android KMP library plugin</strong>.</li>
</ul>



<p>This post provides some details about these changes and points you to the resources that you’ll need to update your existing projects.</p>



<p>You’ll also need to update tools and plugins that depend on AGP to their latest versions with support for AGP 9.0. If you use Android Studio, you&#8217;ll need to use Otter 3 Feature Drop or later.</p>



<blockquote class="wp-block-quote">
<p>Note: Support for AGP 9.0 is coming soon to IntelliJ IDEA, expected to arrive in Q1 2026.</p>
</blockquote>



<p>For information about Gradle plugin compatibility, you can refer to <a href="https://agp-status.frybits.com/agp-9.0.0/" target="_blank" rel="noopener">this community-maintained page</a>.</p>



<p>We are working on adopting AGP 9.0 in our documentation, samples, and wizards. This means that they will all use AGP 9.0 by default and already include these changes in their respective configurations.</p>



<h2 class="wp-block-heading">Use built-in Kotlin</h2>



<p>Previously, Android projects had to apply the Kotlin Android plugin (<code>org.jetbrains.kotlin.android</code>) to add support for Kotlin source files. With AGP 9.0, Kotlin support is built in and enabled by default, so you no longer need to apply the Kotlin Android plugin separately for Android apps.</p>



<p>The main migration step here is to remove usages of the Kotlin Android plugin from your projects. However, if your project uses kapt for annotation processing or sets custom <code>kotlinOptions</code>, you’ll need to update those configurations as well.</p>



<p>Read the <a href="https://developer.android.com/build/migrate-to-built-in-kotlin" target="_blank" rel="noopener">migration guide</a> in the Android documentation for step-by-step instructions.</p>



<blockquote class="wp-block-quote">
<p>With AGP 9.0, you can still opt out of these changes <em>temporarily</em> by adding <code>android.builtInKotlin=false</code> and <code>android.newDsl=false</code> to your <code>gradle.properties</code>. However, this will no longer work in AGP 10.0, which is expected sometime in 2026.</p>
</blockquote>



<h2 class="wp-block-heading">Use the new Android KMP library plugin</h2>



<p>In previous versions, the Android Gradle plugin provided two different plugins you could apply to a module:</p>



<ul>
<li>The Android library plugin (<code>com.android.library</code>).</li>



<li>The Android application plugin (<code>com.android.application</code>).</li>
</ul>



<p>Either of them could be used in combination with the KMP plugin (<code>org.jetbrains.kotlin.multiplatform</code>) to set up a multiplatform module.</p>



<p>AGP 9.0 introduces a new, simplified Android KMP library plugin (<code>com.android.kotlin.multiplatform.library</code>), built specifically for multiplatform projects. The previously used Android library and Android application plugins are no longer compatible with the KMP plugin in the same module, which means you’ll need to migrate any multiplatform modules to the new plugin. This migration will be different for library and application modules; you can learn more about both scenarios below.</p>



<blockquote class="wp-block-quote">
<p>With AGP 9.0, you can still opt out of these changes <em>temporarily</em> by adding <code>android.enableLegacyVariantApi=true</code> to your <code>gradle.properties</code>. However, this will no longer work in AGP 10.0, which is expected sometime in 2026.</p>
</blockquote>



<h3 class="wp-block-heading">Migrating a library module</h3>



<p>If you have a module that uses the Android library plugin and the Kotlin Multiplatform plugin together, you’ll have to <strong>replace the Android library plugin with the Android KMP library plugin</strong>. This means you’ll have to update the build configuration of your existing module, but generally no changes are required to your project structure or source code.</p>



<p>The new Android KMP library plugin has default settings that are designed for Kotlin Multiplatform and optimized for build speed and stability. Some previous configuration options have been removed or moved to new APIs.</p>



<p>Read the <a href="https://developer.android.com/kotlin/multiplatform/plugin#migrate" target="_blank" rel="noopener">migration guide</a> to learn about the differences and get step-by-step instructions on how to migrate a library module to the new plugin.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://developer.android.com/kotlin/multiplatform/plugin#migrate" class="btn" target="" rel="noopener">Migrate a library module</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading">Migrating an application module</h3>



<p>Many projects apply both the Android application plugin and the Kotlin Multiplatform plugin in the same module. A module like this contains shared multiplatform code as well as an Android application with all of its related build configuration. This was the recommended structure in the past, and if you created your project using the KMP wizard, your project probably has a single <code>composeApp</code> module that’s set up like this.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" fetchpriority="high" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/before.png" alt="" class="wp-image-673062" style="aspect-ratio:2.259770114942529;width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/><figcaption class="wp-element-caption">The starting setup</figcaption></figure></div>


<p>Modules like this also have to be migrated to use the new Android KMP library plugin in the module that contains shared code, which requires multiple steps.</p>



<p>First, you’ll have to <strong>create a new module for the entry point of your app and apply the Android application plugin</strong> there. This new module can be relatively small and simple, containing the build configuration to package an Android app and its entry point, such as <code>Activity</code> and <code>Application</code> classes (all represented by <code>MainActivity</code> in the illustrations here).</p>



<blockquote class="wp-block-quote">
<p>When using AGP 9.0, this new module doesn’t need to apply a Kotlin plugin, as it can use the built-in Kotlin support (as detailed above).</p>
</blockquote>



<p>Then, this new application module should <strong>depend on the existing multiplatform module</strong> to have access to its contents. The multiplatform module can now become an Android library, which means you should <strong>migrate it to the new Android KMP library</strong><strong><em> </em></strong><strong>plugin</strong>.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/after.png" alt="" class="wp-image-673073" style="width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/><figcaption class="wp-element-caption">The migrated project</figcaption></figure></div>


<p>To migrate an Android application module to AGP 9.0, follow the detailed steps in the <a href="https://kotlinlang.org/docs/multiplatform/multiplatform-project-agp-9-migration.html" target="_blank" rel="noopener">migration guide</a>.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://kotlinlang.org/docs/multiplatform/multiplatform-project-agp-9-migration.html" class="btn" target="" rel="noopener">Migrate an application module</a>
                                                    </div>
    </div>







<h2 class="wp-block-heading">Conclusion</h2>



<p>We recommend making these configuration changes in your existing projects as soon as possible to ensure smooth upgrades to the latest versions of AGP in the future.</p>



<p>In addition to the links above, you can read the <a href="https://developer.android.com/build/releases/agp-9-0-0-release-notes" target="_blank" rel="noopener">full release notes for AGP 9.0</a> to learn more about what’s new.</p>



<p>If you encounter any issues with AGP 9.0 itself, <a href="https://issuetracker.google.com/issues/new?component=192708" target="_blank" rel="noopener">create a new issue</a> in the Android Studio component of the Google issue tracker.</p>



<p>For problems related to the Kotlin Multiplatform IDE plugin, <a href="https://youtrack.jetbrains.com/newIssue?project=KMT" target="_blank" rel="noopener">create an issue in the KMT tracker</a>.</p>



<p>To provide feedback on Kotlin documentation, <a href="https://youtrack.jetbrains.com/newIssue?project=KT" target="_blank" rel="noopener">create an issue on YouTrack</a> or report it in the <a href="https://slack-chats.kotlinlang.org/c/multiplatform" target="_blank" rel="noopener">#multiplatform channel</a> on the Kotlinlang Slack.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Compose Multiplatform 1.10.0: Unified @Preview, Navigation 3, and Stable Compose Hot Reload</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/compose-multiplatform-1-10-0/</link>
		
		<dc:creator><![CDATA[Elvira Mustafina]]></dc:creator>
		<pubDate>Tue, 13 Jan 2026 14:48:34 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/CMP-social-BlogFeatured-1280x720-1.png</featuredImage>		<category><![CDATA[multiplatform]]></category>
		<category><![CDATA[compose-hot-reload]]></category>
		<category><![CDATA[compose-multiplatform]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=674389</guid>

					<description><![CDATA[Compose Multiplatform 1.10.0 has been released! We’re continually developing our multiplatform APIs and expanding support for Jetpack libraries commonly used on Android. Here are the highlights of this release: Get Started with Compose Multiplatform For a complete overview of the changes, check out What’s new in Compose Multiplatform 1.10.0 or the release notes on GitHub. [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Compose Multiplatform 1.10.0 has been released! We’re continually developing our multiplatform APIs and expanding support for Jetpack libraries commonly used on Android.</p>



<p>Here are the highlights of this release:</p>



<ul>
<li><a href="#common-preview" data-type="internal">One common <code>@Preview</code> annotation to rule them all</a></li>



<li><a href="#navigation-3" data-type="internal">Navigation 3 is available on non-Android targets</a></li>



<li><a href="#compose-hot-reload" data-type="internal">Stable and bundled Compose Hot Reload</a></li>
</ul>



<p></p>



<p align="center"><a class="ek-link jb-download-button" href="https://kotlinlang.org/docs/multiplatform/compose-multiplatform-create-first-app.html" target="_blank" rel="noopener"><i class="download-icon"></i>Get Started with Compose Multiplatform</a></p>



<p>For a complete overview of the changes, check out <a href="https://kotlinlang.org/docs/multiplatform/whats-new-compose-110.html" target="_blank" rel="noopener">What’s new in Compose Multiplatform 1.10.0</a> or the <a href="https://github.com/JetBrains/compose-multiplatform/releases/tag/v1.10.0" target="_blank" rel="noopener">release notes on GitHub</a>.</p>



<h2 class="wp-block-heading" id="common-preview">Common <code>@Preview</code> annotation</h2>



<p>Previously, we had three separate <code>@Preview</code> annotations across different packages, which made it challenging to figure out the correct combination of annotation, platform, and IDE.</p>



<p>With this release, we’ve unified previews under a single <code>@Preview</code> annotation that works in your <code>commonMain</code> source set:</p>



<figure class="wp-block-image is-resized"><img decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/preview_in_common_code.png" alt="Preview in common code" class="wp-image-673989" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>All other annotations have been deprecated. But fear not – IDE quick-fix suggestions will help you easily update your dependencies to <code>androidx.compose.ui.tooling.preview.Preview</code>.</p>



<h2 class="wp-block-heading">Navigation 3</h2>



<p>We’ve introduced support for Navigation 3, a new library for managing navigation. With Navigation 3, you can manipulate your navigation stack directly, making tasks like adding or removing destinations more straightforward.</p>



<p>To help you get started, we’ve compiled a set of <a href="https://github.com/terrakok/nav3-recipes" target="_blank" rel="noopener">Navigation 3 recipes</a>&nbsp;with examples of common usage patterns for Compose Multiplatform.</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/navigation3_recipes.png" alt="Navigation 3 in Compose Multiplatform" class="wp-image-673978" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<h2 class="wp-block-heading">Compose Hot Reload</h2>



<p>Compose Hot Reload is designed to speed up UI iteration by letting you instantly see changes without restarting the application:</p>


                                                <figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" data-gif-src="https://blog.jetbrains.com/wp-content/uploads/2026/01/KotlinConf_hot_reload.animated.gif" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/KotlinConf_hot_reload.png" alt="" class="wp-image-673967"/></figure>
                        


<p>The Compose Hot Reload plugin is now stable – check out this <a href="https://blog.jetbrains.com/kotlin/2026/01/the-journey-to-compose-hot-reload-1-0-0/">deep-dive blog post</a> to learn more about how it works. It’s now bundled with the Compose Multiplatform Gradle plugin and enabled by default, so no additional configuration is required.</p>



<p align="center"><a class="ek-link jb-download-button" href="https://kotlinlang.org/docs/multiplatform/compose-hot-reload.html#use-compose-hot-reload" target="_blank" rel="noopener"><i class="download-icon"></i>Try Compose Hot Reload</a></p>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p>These are just the highlights – this release includes numerous updates across platforms, including the introduction of more transparent <a href="https://kotlinlang.org/docs/multiplatform/whats-new-compose-110.html#deprecated-dependency-aliases" target="_blank" rel="noopener">dependency management</a> for Compose Multiplatform libraries with direct library references.</p>



<p>Make sure to check out the <a href="https://kotlinlang.org/docs/multiplatform/whats-new-compose-110.html" target="_blank" rel="noopener">full version</a> in our documentation. If you encounter any issues, please report them on our <a href="https://youtrack.jetbrains.com/issues/CMP" target="_blank" rel="noopener">issue tracker</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>The Journey to Compose Hot Reload 1.0.0</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/the-journey-to-compose-hot-reload-1-0-0/</link>
		
		<dc:creator><![CDATA[Sebastian Sellmair]]></dc:creator>
		<pubDate>Tue, 13 Jan 2026 14:47:58 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/CMP-social-BlogFeatured-1280x720-1-1.png</featuredImage>		<category><![CDATA[multiplatform]]></category>
		<category><![CDATA[compose-hot-reload]]></category>
		<category><![CDATA[compose-multiplatform]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=673207</guid>

					<description><![CDATA[Compose Hot Reload has just been promoted to stable with our 1.0.0 release. We worked hard to build a technology that is easy to use and well-integrated into existing tools while also requiring zero configuration from users. The tool is bundled with Compose Multiplatform, starting from version 1.10 (see our dedicated release blog post). While [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Compose Hot Reload has just been promoted to stable with our <a href="https://github.com/JetBrains/compose-hot-reload/releases/tag/v1.0.0" target="_blank" rel="noreferrer noopener">1.0.0</a> release. We worked hard to build a technology that is easy to use and well-integrated into existing tools while also requiring zero configuration from users. The tool is bundled with Compose Multiplatform, starting from version 1.10 (see our dedicated <a href="https://blog.jetbrains.com/kotlin/2026/01/compose-multiplatform-1-10-0/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2026/01/compose-multiplatform-1-10-0/" rel="noreferrer noopener">release blog post</a>). While we’re happy to have built tooling that doesn&#8217;t really require users to think about its technical implementation, we’re also immensely proud of the engineering behind the project. This blog post highlights some of the technical aspects we find most interesting and provides a high-level overview of how Compose Hot Reload works under the hood.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/aa93f2aa-b976-4bc0-94c0-e5338cab4e01.png" alt="" class="wp-image-674265" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<h2 class="wp-block-heading">What we’ve built so far</h2>



<p>Compose Multiplatform is a declarative framework for sharing UIs across multiple platforms. Typically, if you’d like to launch a Compose application during development, you need to invoke the corresponding Gradle build tasks or otherwise launch it directly from within the IDE. This is also the case with Compose Hot Reload. Launching your application can be done by invoking the <code>./gradlew :myApp:hotRunJvm</code> task or clicking <em>Run with Compose Hot Reload</em> in IntelliJ IDEA (assuming that the Kotlin Multiplatform plugin has already been installed).</p>



<p>Once the app launches in hot-reload mode, we see a floating toolbar right next to the application window. Changing code within IntelliJ IDEA and clicking <em>Save</em> (<em>Cmd</em>+<em>S</em>/<em>Ctrl</em>+<em>S</em>) will recompile the relevant code, perform a hot reload, and update the UI accordingly while preserving all parts of the state that are still considered valid.</p>



<p><em>Note: Screen recordings were made using the latest Compose Hot Reload version, 1.1, which differs visually from the 1.0 release but is conceptually equivalent.</em></p>



<figure class="wp-block-video"><video controls src="https://blog.jetbrains.com/wp-content/uploads/2026/01/hot-reload-demo-cc.mp4"></video></figure>



<p>Beyond simply changing the image resources, Compose Hot Reload lets you make almost arbitrary changes to your code, including but not limited to adding and removing functions, classes, and parameters – in short, all the kinds of changes you typically make during regular development.</p>



<p>The floating toolbar next to your application offers additional features, such as the ability to view logs, manually trigger a reload, and reset the UI state, as well as status indications and more. One of the most critical aspects of any hot-reload user experience, however, is communicating whether something went wrong. As the developer, you should always be acutely aware when reloading fails, causing your current code changes not to be reflected in the application. This could happen, for example, if you try to reload but the code cannot compile and requires your attention. In such cases, Compose Hot Reload will prominently display the error right in the target application&#8217;s window.</p>



<figure class="wp-block-video"><video controls src="https://blog.jetbrains.com/wp-content/uploads/2026/01/error-demo-cc.mp4"></video></figure>



<h2 class="wp-block-heading">Let’s decompose Compose Hot Reload</h2>



<p>Looking at the example above, let’s break Compose Hot Reload into its separate components and try to understand their individual purposes. In this section, we will recreate the process of building the core of Compose Hot Reload from the ground up, before proceeding to an explanation of the more technical details in the following sections.</p>



<p>First things first, the main requirement for Compose Hot Reload is the ability to update the application while it is running dynamically. To achieve this, we need to answer two questions: <strong>How </strong>do we reload code that is already running dynamically, and <strong>when</strong> should we do it? Without first answering these questions, the technology will not work.&nbsp;</p>



<p>The <strong>how</strong> part can be achieved in multiple ways in the JVM world: using custom classloaders, JVM hot swapping, and via various other methods. But what really makes Compose Hot Reload work so well is the JetBrains Runtime and its DCEVM implementation, which we’ll cover in detail later.</p>



<p>With the <strong>how</strong> being taken care of by DCEVM, we need to decide on the <strong>when</strong>. In other words, we need a way to run the application with DCEVM, detect when the user makes changes, recompile the code, and trigger the reload. That’s right, we need an integration with the application’s build system – a plugin that will provide us access to applications&#8217; build and launch configurations.</p>



<p>It would seem that these components should provide everything we need, right? We can integrate with the application&#8217;s build system and trigger code reloads when the user changes their code! Unfortunately, it’s not that simple. You see, dynamically changing the code will not re-render the application&#8217;s UI. Even worse, changes to the code can now lead to errors when interacting with the UI. For example, what will happen if a user interacts with a button that no longer exists in the code? Therefore, we also need a way to interact with the Compose framework and re-render the UI when necessary. Luckily, the Compose Runtime provides APIs to invalidate states and re-render UIs, so we just need to correctly invoke them after the code is reloaded.</p>



<p>Good news: these three components are sufficient to provide the core functionality of Compose Hot Reload! But to truly elevate the user experience, we need to provide quick visual feedback on the current state of the hot reload. That&#8217;s why Compose Hot Reload also offers:</p>



<ul>
<li>In-app notifications about the state of any hot reloads.</li>



<li>A custom toolbar next to the application window, which allows us to track the status and control the state of a given hot reload.</li>



<li>Integration with an IDE that allows you to easily run the application with Compose Hot Reload and monitor its state.</li>
</ul>



<p>Now that you have the rough outline of Compose Hot Reload, let&#8217;s dive deeper into its technical implementation. There is a lot to discover!</p>



<h2 class="wp-block-heading">Reloading code dynamically: DCEVM and the JetBrains Runtime </h2>



<p>As previously mentioned, Compose Hot Reload relies heavily on the JetBrains Runtime to run the user code. Not only is the JetBrains Runtime specialized in building UI applications, it is also, to date, the only JVM to implement the <a href="https://www.sciencedirect.com/science/article/pii/S0167642311001456?via%3Dihub" target="_blank" rel="noreferrer noopener">DCEVM proposal</a> published in 2011 by Thomas Würthinger, Christian Wimmer, and Lukas Stadler. This proposal enhances virtual machines&#8217; ability to reload code. Where a regular JVM is limited to just reloading function bodies, DCEVM proposes “unrestricted and safe dynamic code evolution for Java”, which lifts the restrictions and supports almost arbitrary code changes. Here’s an example demonstrating how the JetBrains Runtime can perform more complex reloads:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/data-classes.png" alt="" class="wp-image-674276"/></figure>



<p>The given program creates an instance of the class <code>Foo</code> and prints it every second in an endless loop.</p>



<p>When reloading, the class was modified, and a second property <code>y</code> was added. This begs the question: How can the program <strong>and the current state</strong> be reloaded in this way? Once the developer edits the code and compiles it, Compose Hot Reload sends the updated <code>.class</code> files to the currently running application, requesting that it reload. The request will be handled over several subsequent steps.&nbsp;</p>



<p>The first step can be called “verification”: The JetBrains Runtime will check whether the new .class files are valid and can generally <em>be reloaded</em>. If the code passes all checks, it can proceed to the second stage, “loading”. Then, the JetBrains Runtime will load all classes into what we call a “side universe”. This will represent the application code (all loaded classes) after the reload.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/SystemClassLoader.png" alt="" class="wp-image-674287" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>At this point, the side universe can be thought of as a second instance of your application, containing all updated application code, but without any state or threads executing. The above example shows the changed <code>Foo.class</code> marked in green, indicating that it points to an updated version of the class.</p>



<p>The current state of the application is then required to migrate objects to this side universe: We call this a “state transfer”. This state transfer is implemented as a special garbage collection (GC) pass. GC has a few properties that are useful for implementing the state transfer. Not only is it possible to “stop the world” (wait for all application threads to reach safe points), but GC is also allowed to allocate new memory and move objects to new locations!</p>



<p>To demonstrate this for the previous example, we can look at the instance created by <code>val foo = Foo(1)</code>. The actual instance might look something like this in your memory:</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/ObjectHeader.png" alt="" class="wp-image-674298" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>This is where the object currently resides at a known memory location. The memory representation of our object starts with a 16-byte header containing metadata about our object, for example, a pointer or a compressed pointer to our runtime representation of the class (called <code>Klass</code>). Right after the header, we can find the actual fields stored in the object. In our case, we see the value 1 associated with the property x. Memory before or after our object is unknown and could contain basically anything. When a reload changes a class&#8217;s layout by adding or removing properties, it becomes clear that the object needs to be adjusted.</p>



<p>This is where the nature of GC works well for migrating the object. GC can allocate a new block of memory to account for the object&#8217;s new size, and then start migrating the object by copying its previous values. In the chosen example, we added one more <code>int</code> field, requiring us to allocate 32 additional bits of memory. Since the <code>x</code> field was unchanged, we can just copy the previous value to its new location. However, a decision has to be made on how to treat the newly introduced field <code>y</code>. Re-running the constructor is not feasible, so DCEVM uses the JVM defaults: null, 0, and <code>false</code>.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/ObjectHeader_2.png" alt="" class="wp-image-674309" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>Note that the new object has a different header that points to the new <code>Klass</code> object, representing the reloaded code.</p>



<p>Once all objects are migrated, all pointers to them will be updated to point to the migrated objects. In our example above, the instance <code>Foo</code> has moved to a new memory location and now carries a y property.&nbsp;</p>



<p>Before we can resume the application, the runtime needs to consider that previous optimizations and just-in-time compilations to machine code might be invalid. For this reason, the code is then “de-optimized”. Once the application resumes, the JIT compiler is free to kick in again, optimizing our code and returning the application to the previous level of performance.</p>



<h2 class="wp-block-heading">Java agents FTW</h2>



<p>DCEVM is an amazing technology that allows you to dynamically reload and redefine code while it is executing. However, to make it actually work, we need a way to call its APIs from the user application.&nbsp;</p>



<p>Luckily, the JVM has a way to implement that – it&#8217;s called a <strong>Java agent</strong>. A Java agent is a Java library that can be attached to any Java program and execute code before the target program starts.</p>



<p>To create a Java agent, we need to declare a class with a <code>premain</code> method. This method, as the name suggests, will be executed<strong><em> </em></strong><em>before</em> the target application’s <code>main</code>, i.e. during JVM startup. The method takes a <code>String</code> argument and an instance of <code>java.lang.instrument.Instrumentation</code><strong> </strong>as its parameters.</p>



<pre class="EnlighterJSRAW">fun premain(args: String, instrumentation: Instrumentation)</pre>



<p><code>java.lang.instrument.Instrumentation</code> is a part of the <strong>Java Instrumentation API</strong>, which allows agents to <strong>observe</strong>, <strong>modify</strong>, and <strong>redefine</strong> classes at runtime. When you are using the JetBrains Runtime, <code>java.lang.instrument.Instrumentation</code> provides you with access to DCEVM via its <code>redefineClasses</code> method implementation.</p>



<p>So, in the case of Compose Hot Reload, the Java agent&#8217;s function is relatively straightforward: We attach it to the target application and launch a background task/thread in the <code>premain</code>. This background task will invoke <code>instrumentation.redefineClasses</code> with new classes whenever it receives information about changes to the application&#8217;s code.&nbsp;</p>



<p>Finally, we just need to package our agent as a standalone JAR and give the agent information required by the JVM in the manifest file:</p>



<p><code>Premain-Class: org.jetbrains.compose.reload.agent.ComposeHotReloadAgent</code></p>



<p><code>Can-Redefine-Classes: true&nbsp; // declare that we intend to redefine classes</code></p>



<p>In practice, we use the Compose Hot Reload agent for much more than just redefining classes via DCEVM. We will cover its other functions in the following sections.</p>



<p>You may have noticed that we boldly skipped one of the most important parts of any hot reload by simply claiming that the agent “receives information about changes in the code”. It is, indeed, not so simple. However, to get the whole picture, we first have to dive into another complex subsystem of Compose Hot Reload – its integration with build systems.</p>



<h2 class="wp-block-heading">Building a zero-configuration tool</h2>



<p>The combination of the JetBrains Runtime’s ability to reload code and an agent that can listen for reload requests form the core functionality of Compose Hot Reload. Integrating these components into a zero-configuration product requires careful integration into build tools. The following describes how the Gradle plugin is implemented, but hot reload is also available in <a href="https://amper.org/dev/" target="_blank" rel="noreferrer noopener">Amper</a>. The user-facing workflows can be separated into two typical kinds of builds: In the first, the user compiles the application and intends to launch it in hot-reload mode. In the second kind of build, there will be multiple reloads. These consist of incrementally compiling the code, and then sending the reload request to the agent after a given change. Reload requests typically contain all <code>.class</code> files that have been either changed, added, or modified. While reloading can be triggered manually, it is typically managed either by Compose Hot Reload itself or by the IDE, which watches source files for changes.&nbsp;</p>



<p>This leads to two questions:&nbsp;</p>



<ol>
<li>How can the set of <strong>changed files</strong> be resolved efficiently when reloading?</li>



<li>How can other tools reliably issue reloads?</li>
</ol>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-23.png" alt="" class="wp-image-673267"/></figure>



<p>The flow of launching the application already gives a lot of insights into how the overall system works, and it is relatively straightforward:&nbsp;</p>



<p>The entire project is compiled, as usual, and produces the corresponding <code>.class</code> files. Typically, applications can launch directly afterwards by launching the JVM with all necessary arguments (classpath, properties, JVM arguments, user arguments, etc.). A hot reload run will then perform two additional steps before actually launching.</p>



<p>After the compilation finishes, a snapshot of the classpath is taken. It&#8217;s worth mentioning that Compose Hot Reload differentiates the classpath into a <strong>hot</strong> and <strong>cold</strong> part. Dependencies resolved from remote repositories are considered <strong>cold</strong> because they won’t change during a hot reload session. Code compiled by the current build, however, is considered <strong>hot</strong>. The snapshot is therefore only taken of the <strong>hot</strong> part of the classpath and contains all known <code>.class</code> files, each with a checksum of its contents.</p>



<p>The second task performed by hot reload is to produce special hot-reload arguments for the run. For convenience and to support restarting the application, these arguments will be stored in an <code>.argfile</code>. The most important arguments being:</p>



<ul>
<li><code><em>-</em>XX:+AllowEnhancedClassRedefinition</code>, which enables the JetBrains Runtime’s DCEVM capabilities.</li>



<li><code><em>-</em>javaagent:/.../hot-reload-agent-1.1.0.jar</code>, which adds our agent to the application.</li>



<li><code>-Dcompose.reload.buildSystem=Gradle</code>, which tells Compose Hot Reload to use the Gradle recompiler backend.</li>



<li><code><em>-</em>Dgradle.build.root=/.../myProject</code>, which tells Compose Hot Reload where the current Gradle project is located.</li>



<li><code><em>-</em>Dgradle.build.project=:app</code>, which indicates which Gradle project was launched for hot reload.</li>



<li><code><em>-</em>Dgradle.build.task=hotReloadJvmMain</code>, which tells Compose Hot Reload which Gradle task can be executed to issue a reload.</li>



<li><code>-Dcompose.reload.devToolsClasspath=...</code>, which provides the floating toolbar application classpath.</li>



<li><code>-Dcompose.reload.devToolsEnabled=true</code>, which enables the floating toolbar application.</li>
</ul>



<p>Given that the application now has all the information necessary to start reloads by invoking the provided Gradle task at the provided location, Compose Hot Reload will start a supervisor process called <code>devTools</code>. This is the same process that will then provide the floating toolbar window. This process will either start a continuous Gradle build for reloading or wait for external events (such as you clicking <em>Reload</em>, or the IDE sending a signal to reload).&nbsp;</p>



<p>Such signals can be sent through the orchestration protocol, which we’ll talk about in more detail later. For now, it is just essential to know that the application will host a TCP server that allows components, such as Gradle, Amper, or the IDE, to communicate with each other.</p>



<p>Requests to reload the application will trigger the corresponding reload task. Such a Gradle invocation will be marked as <code>isHotReloadBuild</code> and will get the application server port forwarded as <code>orchestration.port</code>.</p>



<p>Once the project is compiled incrementally, the snapshot will be rebuilt incrementally as well. Comparing the previous snapshot to the new one is quick and produces a map of <code>.class</code> files that are either added, removed, or modified.&nbsp;</p>



<p>The last task is to connect to the application using the provided port and send a request to reload those files. The agent will handle this request and reload the code using the JetBrains Runtime.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-24.png" alt="" class="wp-image-673279"/></figure>



<p>Since all relevant tasks can be created automatically by inferring them from the Kotlin Gradle Plugin model, the tool can be used effectively without any further configuration. Launching from the CLI only requires calling the corresponding <code>hotRunJvm</code> task. IntelliJ IDEA can import hot reload tasks during the Gradle sync process and create corresponding run gutters.</p>



<h2 class="wp-block-heading">But what about the UI?</h2>



<p>As we mentioned before, being able to reload the code does not guarantee that Compose Hot Reload will magically start working. Modern applications are far too complex for that to happen. Therefore, after reloading the code, we need to propagate those updates throughout the application, re-rendering the UI, resetting the state, cleaning the references to the old code, etc.&nbsp;</p>



<p>Now, to do that correctly, we first need to understand how Compose code actually works. Let&#8217;s take a look at how our <code>App</code> function from the previous examples is represented.</p>



<pre class="EnlighterJSRAW">@Composable
fun App() {
   var clicks by remember { mutableStateOf(0) }
   MaterialTheme {
       Column(
           horizontalAlignment = Alignment.CenterHorizontally,
       ) {
           Button(onClick = { clicks++ }) {
               Text(&quot;Clicks: $clicks&quot;)
           }


           Icon(
               imageResource(Res.drawable.Kodee_Assets_Digital_Kodee_greeting),
               contentDescription = &quot;Kodee!!!&quot;,
               modifier = Modifier,
               tint = Color.Unspecified
           )
       }
   }
}</pre>



<p>Compose splits the code into sections called <strong>groups</strong> and assigns each group a unique integer key. As an approximation, you can think that each <strong>scope</strong> (e.g. each <code>{}</code> pair in the code) corresponds to a separate group. The groups are organized in a tree-like structure that corresponds to their relations in the source code. In this image, green nodes correspond to Compose groups created by the <code>App</code> function, blue nodes represent other Composable functions called in the <code>App</code> function, and white nodes represent state information.&nbsp;</p>



<p>When the Compose Runtime detects that some parts of the UI need to be re-rendered, it marks the groups corresponding to those components as invalid. It then re-executes all the code corresponding to those groups, creating an updated version of the tree. Subsequently, this means that the state<strong> </strong>created by any invalidated groups will be reset. For example, if we invalidate the group with the key -419397569, the mutable state with the counter will not be reset, while all the other code will be re-executed.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-25.png" alt="" class="wp-image-673314"/></figure>



<p>Now that we have a high-level understanding of the Compose representation, how do we actually implement hot reload? Well, the intuitive option would be to reuse the Compose Runtime&#8217;s existing functionality: If the code changes, we invalidate all groups corresponding to that code. This will allow us to:</p>



<ul>
<li>Re-render only the necessary parts of the UI.</li>



<li>Preserve the state whenever possible.</li>



<li>Clean up all references to the old code.</li>
</ul>



<p>To do that, we need to understand:</p>



<ul>
<li>What code has been changed?</li>



<li>Which Compose groups need to be invalidated because of that change?</li>
</ul>



<p>And here, the Compose Hot Reload agent comes into play one more time.</p>



<h3 class="wp-block-heading">Bytecode analysis</h3>



<p>When compiling the application, the Compose plugin changes the intermediate representation (IR) of the Composable functions and inserts additional instructions for the Compose Runtime. For example, the bytecode of the <code>App</code> function will start with the following instruction: <code>$composer.startRestartGroup(1359525739)</code>.</p>



<p>Here, <code>startRestartGroup</code> is a special instruction of the Compose Runtime that marks the start of a new group, and its argument is the key for this group. Correspondingly, the end of this group will be marked by a call to <code>endRestartGroup</code>. This means that all the information that we’re interested in is actually contained in the bytecode; we just need to extract it.</p>



<p>Luckily, the Java agent allows us to hook into the target application and inspect all the classes while they are loading. We use the <a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a> library to analyze classes, and for each method, we build our own representation of the Compose tree. By locating the startGroup and endGroup calls, we can determine the bounds (and keys) of Compose groups, and their locations in the code define the parent-child relations between them. Conditional branches inside a function can be parsed by tracking jump instructions and their target labels.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/scopes.png" alt="" class="wp-image-673336"/></figure>



<p>For each Compose group, we determine its key, its relations with other groups, its dependencies on different methods, and its <strong>hash</strong>. The group&#8217;s hash value attempts to capture its semantics; for simplicity, we can think of it as a hash of all the bytecode instructions in this group. It allows us to quickly determine whether the group&#8217;s code has changed semantically during reloads.</p>



<h3 class="wp-block-heading">Tracking changes</h3>



<p>Now that we know how to extract information from the bytecode, we need to think about how to apply it. As we mentioned, a Java agent allows us to analyze every class before it has been loaded. This will enable us to analyze classes not only during initial loading, but also during reloads. Thus, during reload, we can keep track of both the old and new versions of each class and monitor changes.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/runtime.png" alt="" class="wp-image-673347"/></figure>



<p>When the class is reloaded, we can compare both its old and new runtime information and invalidate groups using the following rules.</p>



<ul>
<li>If the code hash of a Compose group is changed, invalidate it.</li>



<li>If the code hash of a non-Compose function is changed, invalidate all Compose groups that are (transitively) dependent on it. Since we keep track of the entire runtime, we can efficiently compute all method dependencies.</li>
</ul>



<p>After that, the only thing left to do is to save the new version of the runtime as the current one.</p>



<h2 class="wp-block-heading">The compiler doesn’t like your hot reload stuff</h2>



<p>Even though the core idea of the code invalidation and UI re-rendering approach is not particularly complicated, the path to Compose Hot Reload&#8217;s success was blocked by many obstacles and hurdles we had to overcome. Many of them stemmed from the fact that the Kotlin compiler and Compose plugin weren’t built with DCEVM and hot swapping in mind. Therefore, bytecode produced by those tools often behaved unexpectedly during hot reload. In this section, we will highlight some of the technical difficulties we encountered during the development of Compose Hot Reload and how we solved them.</p>



<h3 class="wp-block-heading">All your lambdas belong to us</h3>



<p>Both Kotlin and Compose encourage heavy use of lambda functions. However, lambda functions were a significant source of inconsistency in the bytecode produced by the Kotlin compiler, mainly due to their names. Users do not provide names for lambda functions; therefore, the compiler generates them itself, using predefined rules to determine each lambda&#8217;s name. Unfortunately, those rules are not designed with hot reload in mind.</p>



<p>There are two ways a lambda function can be compiled to the bytecode: anonymous classes and indy lambdas. The first way suggests that a lambda is compiled as a class that implements one of Kotlin’s <code>FunctionN</code> interfaces, and the lambda’s body is placed inside the <code>invoke</code> method of this class.</p>



<p>The indy way suggests that a lambda is compiled as a function inside the original class, which is then converted into an object in the runtime via the JVM’s <code>invokedynamic</code> instruction and the <code>LambdaMetafactory</code>.</p>



<pre class="EnlighterJSRAW">fun bar() =
   foo { println(it) }


fun foo(a: (Int) -&gt; Unit) {
   listOf(1, 2, 3).forEach(a)
}</pre>



<p>Class-based lambda:</p>



<pre class="EnlighterJSRAW">final class org/example/project/MainKt$bar$1 extends kotlin/jvm/internal/Lambda implements kotlin/jvm/functions/Function1 {
   // access flags 0x0
   &lt;init&gt;()V
           L0
   ALOAD 0
   ICONST_1
   INVOKESPECIAL kotlin/jvm/internal/Lambda.&lt;init&gt; (I)V
   RETURN


   // access flags 0x11
   public final invoke(I)V
   GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
   ILOAD 1
   INVOKEVIRTUAL java/io/PrintStream.println (I)V
   RETURN
}</pre>



<p>Indy lambda:</p>



<pre class="EnlighterJSRAW">public final static bar()V
INVOKEDYNAMIC invoke()Lkotlin/jvm/functions/Function1; &#091;
// handle kind 0x6 : INVOKESTATIC
java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
// arguments:
(Ljava/lang/Object;)Ljava/lang/Object;,
// handle kind 0x6 : INVOKESTATIC
org/example/project/MainKt.bar$lambda$0(I)Lkotlin/Unit;,
(Ljava/lang/Integer;)Lkotlin/Unit;
]
INVOKESTATIC org/example/project/MainKt.foo (Lkotlin/jvm/functions/Function1;)V
RETURN


private final static bar$lambda$0(I)Lkotlin/Unit;
GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
ILOAD 0
INVOKEVIRTUAL java/io/PrintStream.println (I)V
GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit;
ARETURN</pre>



<h4 class="wp-block-heading"><code>ComposableSingleton</code> classes</h4>



<p>Compose attempts to emit every composable lambda function as a singleton, meaning there is only one instance of that lambda function in existence. Therefore, it compiles all the composable lambdas as classes with a <code>ComposableSingleton</code> prefix in their names. <strong>Before </strong>Kotlin 2.1.20, the Compose compiler traversed nested functions using depth-first search and assigned each lambda class a unique name just using a counter.&nbsp;</p>



<p>The problem, however, arises when we introduce changes to the original code:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/composable-singletons.png" alt="" class="wp-image-673369"/></figure>



<p>As you can see, just by adding a single new call to <code>Surface</code>, we caused two significant changes:</p>



<ul>
<li>Each lambda class changed, because adding a new lambda at the bottom of the tree caused all the lambda classes in the file to be renamed.</li>



<li>The class named <code>ComposableSingleton$AppKt$lambda-0</code> changed its interface from <code>Function3</code> to <code>Function2</code>, which causes an error in the JetBrains Runtime during reload, as before version 21.0.8, the JetBrains Runtime did not support changes to class interfaces.</li>
</ul>



<p>Obviously, these kinds of dramatic bytecode changes are not good when hot reloading. Therefore, we changed how the Compose compiler generates names for composable singleton lambdas. Starting from version 2.1.20, the Compose compiler uses <strong>group keys </strong>as a stable, unique name for composable lambdas:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/composable-singletons-fixed-1.png" alt="" class="wp-image-673911"/></figure>



<p>This change ensures that changes to composable lambdas do not cause errors or excessive invalidations in Compose Hot Reload.</p>



<h4 class="wp-block-heading">Indy lambdas</h4>



<p>We encountered similar problems with the names generated for indy lambdas by the Kotlin compiler: Adding a nested lambda anywhere in the code renames all other lambdas.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/Lambdas-Not-Fixed.png" alt="" class="wp-image-674551"/></figure>



<p>This issue leads to the same problems as we observed with <code>ComposableSingletons</code>. However, this issue was reinforced by the fact that it affects <strong>all</strong> lambdas in the code, and Kotlin switched to indy lambdas by default in 2.0.0.</p>



<p>To solve this problem, we have changed the Kotlin compiler. As of Kotlin 2.2.20, indices for indy lambda names are unique for each scope they appear in. This guarantees that:</p>



<ul>
<li>Random changes at the beginning of the file will not affect lambda names at the end of the file.</li>



<li>Adding nested lambdas will not affect all the other lambdas declared in the class.</li>
</ul>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/indys-fixed-1.png" alt="" class="wp-image-673944"/></figure>



<h4 class="wp-block-heading"><code>FunctionKeyMeta</code> annotations</h4>



<p>The whole functionality of Compose Hot Reload relies on the fact that we can extract information about Compose from the bytecode. However, consider this example:</p>



<pre class="EnlighterJSRAW">@Composable
fun App() {
   Button(onClick = { }) {
       Text(&quot;Click me!!!&quot;)
   }
}</pre>



<p>The lambda, passed to a <code>Button</code> call, only creates a single text field and does not create any new Compose groups. The (decompiled) bytecode of this lambda function looks like this:</p>



<pre class="EnlighterJSRAW">final class ComposableSingletons$AppKt$lambda$-794152384$1 implements Function3&lt;RowScope, Composer, Integer, Unit&gt; {


   @FunctionKeyMeta(
       key = -794152384,
       startOffset = 568,
       endOffset = 603
   )
   @Composable
   public final void invoke(RowScope $this$Button, Composer $composer, int $changed) {
       Intrinsics.checkNotNullParameter($this$Button, &quot;$this$Button&quot;);
       ComposerKt.sourceInformation($composer, &quot;C17@578L19:App.kt&quot;);
       if ($composer.shouldExecute(($changed &amp; 17) != 16, $changed &amp; 1)) {
       if (ComposerKt.isTraceInProgress()) {
           ComposerKt.traceEventStart(-794152384, $changed, -1, &quot;ComposableSingletons$AppKt.lambda$-794152384.&lt;anonymous&gt; (App.kt:17)&quot;);
       }


       TextKt.Text--4IGK_g(&quot;Click me!!!&quot;, (Modifier)null, 0L, 0L, (FontStyle)null, (FontWeight)null, (FontFamily)null, 0L, (TextDecoration)null, (TextAlign)null, 0L, 0, false, 0, 0, (Function1)null, (TextStyle)null, $composer, 6, 0, 131070);
       if (ComposerKt.isTraceInProgress()) {
           ComposerKt.traceEventEnd();
       }
   } else {
       $composer.skipToGroupEnd();
   }
   }
}</pre>



<p>As you may notice, the source code of the <code>invoke</code> function does not contain any calls to <code>startGroup</code> or <code>endGroup</code> methods, and we can’t reliably extract the group information from it. The only way to access it is to read the <code>FunctionKeyMeta</code> annotation. This is a special annotation emitted by the Compose compiler that is intended to be used by tooling.&nbsp;</p>



<p>However, before version 2.1.20, there was no way to generate <code>FunctionKeyMeta</code> annotations on composable functions, and there was no way to infer the group key from the bytecode of the compiled composable lambdas. We introduced this option in Kotlin 2.1.20 (which is why it is the required version of Kotlin if you want to use Compose Hot Reload) and enabled it by default in Kotlin 2.2.0.</p>



<h2 class="wp-block-heading">Lifting the limits of the JetBrains Runtime</h2>



<p>With the compiler tamed to emit bytecode that can be reloaded, another set of potential issues needs to be solved. One such issue surfaced very early in our testing. What should happen to the state that was statically initialized? The state in question here is not a UI state, stored by Compose, but static values, such as top-level properties. Take a look at the following test, which failed in early versions of Compose Hot Reload.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/EnumClasses.png" alt="" class="wp-image-674320" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>The test first defines an enum with the cases <code>A</code>, <code>B</code>, and <code>C</code>, then compiles and reloads the enum definition so that it also contains the case <code>D</code>. This failure is due to the <code>EnumCases.entries</code> being stored statically on the enum class. Once this collection is initialized, reloading this code will not magically cause its state to change to include the new case. Similarly, any other top-level property or static value would not change.</p>



<p>This is analogous to managing the state within the Compose framework, which means the same problems need to be solved.&nbsp;</p>



<p>We still need a way to reinitialize static values, and we need to know <strong>when</strong> to do so. This time around, we can answer the question of when to do so much more easily: Our bytecode analysis engine is perfectly capable of finding which functions and properties are considered <strong>dirty</strong>. However, reinitializing static fields is not as straightforward as calling a function. First, many static fields are also declared as final; re-assigning values cannot be done by calling a given function again, as it would require reflection. Second, the code that initializes statics lives inside a function called <code>clinit</code>. This function cannot be simply invoked, as it&#8217;s supposed to be invoked during class loading by the JVM itself. The problem requires transforming the code of <code>.class</code> files that will subsequently be reloaded. The transformation removes all final modifiers from static fields and copies the body of the <code>clinit</code> function to a new, synthetic <code>$chr$clinit</code> function (where <code>chr</code> is short for Compose Hot Reload). When reloading, the <code>clinit</code> method of several classes can be marked as dirty. We enqueue those classes for reinitialization and call them in topological order, according to their dependencies.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/Reloading-Transformed.png" alt="" class="wp-image-674331"/></figure>



<p>When this project started, one of the stated limitations of the JetBrains Runtime was that reloads were rejected if either the superclass or any of a class&#8217;s interfaces changed while the class had active instances. Since some Kotlin lambdas still compile to abstract classes that implement <code>Function1</code>, <code>Function2</code>, and other interfaces, the limitation prevented some valid user code from reloading. We were able to produce lambda class names that were unique in Compose and much more tame outside of Compose, but users could occasionally encounter this limitation. We’re happy to announce that the team working on the JetBrains Runtime, especially Vladimir Dvorak, has lifted the restriction on changing interfaces and is now working on changing superclasses as well.</p>



<h2 class="wp-block-heading">The orchestration protocol</h2>



<p>We have previously seen that different processes need to communicate with each other. There are two concepts we can deduce from the required communication:</p>



<ul>
<li>Events: Single-shot pieces of data (something that happened to which other parts of the system can react).</li>



<li>States: Current statuses of different Compose Hot Reload components that are continuously updated and available across the entire orchestration. For example, the <code>ReloadState</code> can either be <code>Ok,</code> <code>Reloading</code>, or <code>Failed</code>. This is not just a single event, but a universal state that each component can interact with. You can see that this <code>ReloadState</code> will be displayed in the application, the floating toolbar, and the IDE.&nbsp;</li>
</ul>



<p>Typically, such communication patterns can be modelled using higher-level abstractions, such as HTTP, and many would think that Ktor, or <code>kotlinx.rpc</code> might be fitting technologies. We, however, believe that technologies like Compose Hot Reload need to prioritize compatibility over our own developer experience. Using external libraries inside our devtools application is not a problem, but the communication with the user application requires code to run inside the user&#8217;s application, and polluting the user’s classpath might lead to frustrating compatibility issues. Shading such libraries can work, but most of those libraries would require <code>kotlinx.coroutines</code>. While <code>kotlinx.coroutines</code> can be shaded, it is designed to be a system-level library, and we would like to keep it this way.</p>



<p>Therefore, we opted to implement all of the server/client code without any external dependencies. To model async code accurately, we even implemented a tiny coroutines runtime that allows launching tasks, switching threads, offering a <code>Queue</code> option (analogous to a <code>Channel</code> in <code>kotlinx.coroutines</code>), and more.&nbsp;</p>



<p>The key aspect of this protocol is that it is both forward- and backwards-compatible. This bi-directional compatibility is verified by running tests in a special way, but we’ll go into more detail on that later.</p>



<p>Defining a state within a single process is hard enough to get right, but defining it across multiple processes raises the question of how to implement it safely. State updates in Compose Hot Reload are defined atomically and are done through an atomic update function. This means that racing threads, even racing processes, will be able to conveniently update a given state while using a pattern that is widely adopted by application developers:</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/OrchestrationState.png" alt="" class="wp-image-674342" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>The provided <code>update</code> function ensures atomic updates to the state. Like an <code>AtomicReference</code> or a <code>MutableSharedFlow</code>, this update function might be called multiple times if proposed updates are rejected. To enable such atomic updates across numerous processes, the <code>OrchestrationServer</code> acts as the source of truth: Any participant trying to update the state will send binary <code>Update</code> requests to the server. These requests will contain the binary (serialized) form of the expected state and the binary form of the updated state.&nbsp;</p>



<p>The server processes all requests in a single <code>Queue</code>. If the expected binary matches, the update gets accepted, and the updated state binary is distributed to all clients. If many threads or processes are racing to update a given state value, the expected binary representation might have changed so that it no longer matches the update request. Such updates will be rejected; the client will receive the new underlying state value, call the update function again, and send a new update request.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-52.png" alt="" class="wp-image-674022"/></figure>



<h2 class="wp-block-heading">Fast visual feedback</h2>



<p>We’ve now covered the internal workings of Compose Hot Reload. But as interesting as all that is, in our opinion, fast visual feedback is the most important part of the hot reload experience. So, how can we provide this feedback, and more importantly, share it across different processes? Well, the key to doing this is the states that are shared between all processes via the orchestration protocol. The <code>hot-reload-devtooling-api</code> module introduces them:</p>



<ul>
<li><code>WindowsState</code>. By hooking into the user application process and intercepting all the <code>ComposeWindow.setContent</code> invocations, we can keep track of all the windows created by the user application. Each window is assigned a unique <code>windowId</code>, and we keep information about the current position of all windows.</li>
</ul>



<pre class="EnlighterJSRAW">public class WindowsState(
   public val windows: Map&lt;WindowId, WindowState&gt;
) : OrchestrationState {
   public class WindowState(
       public val x: Int,
       public val y: Int,
       public val width: Int,
       public val height: Int,
       public val isAlwaysOnTop: Boolean
   )
}</pre>



<ul>
<li><code>ReloadState</code>. <code>ReloadState</code> keeps track of the current reload status. Basically, it tracks all orchestration messages and updates the state based on reload, recompile, or build status messages exchanged between the processes.&nbsp;</li>
</ul>



<pre class="EnlighterJSRAW">public sealed class ReloadState : OrchestrationState {
   public abstract val time: Instant


   public class Ok(
       override val time: Instant,
   ) : ReloadState()


   public class Reloading(
       override val time: Instant,
       public val reloadRequestId: OrchestrationMessageId?
   ) : ReloadState() {


   public class Failed(
       override val time: Instant,
       public val reason: String,
   ) : ReloadState()
}</pre>



<ul>
<li><code>ReloadCountState</code>. In addition to the reload state, it is also nice to keep track of the history of reload attempts. Working on the UI of your application and seeing that you have iterated on it over 30 times already is a very inspiring feeling!</li>
</ul>



<pre class="EnlighterJSRAW">public class ReloadCountState(
   	    public val successfulReloads: Int = 0,
   	    public val failedReloads: Int = 0
) : OrchestrationState</pre>



<p>As we mentioned before, all these states are shared between the processes. So if you feel like it, you can actually create your own UI tooling for Compose Hot Reload!&nbsp;</p>



<h3 class="wp-block-heading">In-app effects</h3>



<p>The Compose Hot Reload agent hooks to the user application process and intercepts Compose calls that initialize the window: <code>ComposeWindow.setContent</code> and <code>ComposeDialog.setContent</code>. To be more precise, we don’t just intercept these calls; we actually replace them with our own implementation that wraps the user content into a special <code>DevelopmentEntryPoint</code> function.</p>



<pre class="EnlighterJSRAW">@Composable
public fun DevelopmentEntryPoint(
   window: Window,
   child: @Composable () -&gt; Unit
) {
   startWindowManager(window)
   val currentHotReloadState by hotReloadState.collectAsState()


   CompositionLocalProvider(hotReloadStateLocal provides currentHotReloadState) {
       key(currentHotReloadState.key) {
           when {
               reloadEffectsEnabled -&gt; ReloadEffects(child)
               else -&gt; child()
           }
       }
   }
}</pre>



<p>This is a very high-level implementation of the <code>DevelopmentEntryPoint</code>. As you can see, it provides us with three key features:</p>



<ul>
<li>We start a window manager that updates the <code>WindowState</code> of the current window.</li>



<li>We wrap the user app&#8217;s contents in a separate scope guarded by a special hot-reload state. If we ever want to reset the user application&#8217;s UI state, we can do so by resetting the hot-reload state.</li>



<li>We wrap the user content into the <code>ReloadEffects</code> function, which renders all in-app effects based on the shared states.</li>
</ul>



<h3 class="wp-block-heading">Floating toolbar</h3>



<p>The floating toolbar, or the Compose Hot Reload <em>Dev tools</em> window, is a separate process that starts together with the user application and connects to the orchestration. Then, it just tracks the <code>WindowsState</code>, and launches a new toolbar for each window of the user application. The toolbar just tracks the target window&#8217;s state and updates its position accordingly.</p>



<p>The toolbar also contains action buttons that control the user application: <em>Reload UI</em>, <em>Reset UI</em>, and <em>Shutdown</em>. These actions are implemented via the orchestration protocol as well: Clicking a button just triggers a corresponding orchestration message to be sent to all connected processes. Each process then knows how to handle received commands.</p>



<figure class="wp-block-video"><video controls src="https://blog.jetbrains.com/wp-content/uploads/2026/01/toolbar.mov"></video></figure>



<h3 class="wp-block-heading">IDE integration</h3>



<p>IDE support for Compose Hot Reload is implemented in the <a href="https://plugins.jetbrains.com/plugin/14936-kotlin-multiplatform" target="_blank" rel="noreferrer noopener">Kotlin Multiplatform</a> plugin. When you open a Kotlin Multiplatform project in your IDE, the KMP plugin checks whether the Compose Hot Reload plugin is applied to the project. If it is, the KMP plugin also checks the versions for compatibility (IDEs support Compose Hot Reload versions from 1.0.0-beta07 onward). Via IDE integration with the build systems, the KMP plugin can extract all the information needed to run the app in hot-reload mode. And when you click on the <em>Run</em> button in the gutter next to <code>main</code>, the KMP plugin automatically generates a new run configuration with hot reload enabled.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/runcomposeApp.png" alt="" class="wp-image-674355" style="width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>Everything else works very similarly to the <em>Dev tools</em> window. The KMP plugin connects to the orchestration server of the running application and displays information about the app&#8217;s current state: logs, reload status, errors, etc.</p>



<h2 class="wp-block-heading">Testing</h2>



<p>This project required the team to think about many components across the entire Kotlin and JetBrains technology stack, and we have spent a lot of time debugging, experimenting, and writing production code. We would like to claim that <strong>most</strong> of our time was spent on our project infrastructure. However, we estimate that roughly 30% of all our commits were purely for introducing test infrastructure, highlighting how complicated testing a system that reloads code can be.</p>



<h3 class="wp-block-heading">Hot-reload unit tests</h3>



<p>Tests running assertions within the JVM that reload code are called hot-reload unit tests. An example of such a test case was shown earlier in this blog post.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/EnumClass2.png" alt="" class="wp-image-674366"/></figure>



<p>The tests here can define <strong>code of interest</strong> right next to the actual test function. But the real magic happens when calling the <code>compileAndReload</code> method.&nbsp;</p>



<p>This method allows us to compile the provided source code within the current process and reload it. Once this <code>compileAndReload</code> method finishes, we can safely assume the new code is available and begin to write assertions. The example above shows a test that defines an enum with three cases. After reloading the enum with one case added, we can safely assert that the <code>.entries</code> property contains the newly added case. This test suite implements a custom <strong>test executor</strong> for Gradle, which launches each test case in a fresh JetBrains Runtime with hot reload enabled and provides a Kotlin compiler for the <code>compileAndReload </code>function. We used such tests in cases where reloading either crashed or had some issues, as mentioned previously (reinitializing statics).</p>



<h3 class="wp-block-heading"><code>HotReloadTestFixture</code>: Orchestration-based tests</h3>



<p>Since this project integrates into many other systems, having a heavier, end-to-end test fixture at our disposal seems natural. Similar to how Gradle plugins would write Gradle integration tests using Gradle-specific fixtures, we have implemented a <code>HotReloadTestFixture</code> that launches actual applications with Gradle in hot-reload mode and communicates with Gradle and the application using the previously mentioned orchestration protocol. Such tests were implemented to cover the integration with the JDWP commands for reloading and testing generic Gradle tasks, but they were also very useful for building screenshot tests:</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/HotReloadTest.png" alt="" class="wp-image-674377" style="width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>Just as unit tests do, orchestration-based tests have a convenient way to replace code, thanks to the <code>HotReloadTestFixture</code>; however, this test fixture actually changes source code on disk and thus relies on the entire Gradle/Compose Hot Reload machinery to pick the change up correctly, issue the reload request, and perform other relevant actions, right up until Compose actually updates the UI. After that, the test then takes a screenshot. We have many tests that ensure, through screenshots, that the code change was handled properly, i.e. that only the corresponding state was reset and the UI picked up the changes.</p>



<h4 class="wp-block-heading">Testing the backwards and forwards compatibility of the orchestration protocol</h4>



<p>As we mentioned before, compatibility is one of the key properties of the orchestration protocol. For example, the IDE might have a different client version bundled compared to the server version hosted by the application.&nbsp;</p>



<p>Such compatibility tests typically define a communication flow between a server and a client. Let’s say the client connects, the server sends a message <code>Foo</code>, and the client responds with <code>Bar</code>. Now, to test the compatibility, this flow will be separated into two parts:&nbsp;<br>The first part is called <code>main</code>, which contains one side of the communication (e.g. the server’s) and runs with the currently compiled version of the code. The second part is called <code>Isolate</code>, and this code will be running in a separate process, launched with the previous JARs of the protocol.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/main-Server.png" alt="" class="wp-image-674403"/></figure>



<p>The Isolate class can be defined right next to the test function, making it easy to write compatibility test cases where both ends of the communication are close together. Still, only one will be launched in isolation, running the test against many different, previously released versions of Compose Hot Reload.</p>



<h2 class="wp-block-heading">Continuing the journey</h2>



<p>Compose Hot Reload is a very complex technical project, and we are proud of the engineering work behind it. We tried to highlight what we consider the most interesting aspects of Compose Hot Reload in this blog post. But if you are interested in learning more about the project, check out our <a href="https://github.com/JetBrains/compose-hot-reload" target="_blank" rel="noreferrer noopener">GitHub repository</a>. And don’t hesitate to create new <a href="https://github.com/JetBrains/compose-hot-reload/issues" target="_blank" rel="noreferrer noopener">issues</a> or <a href="https://github.com/JetBrains/compose-hot-reload/discussions" target="_blank" rel="noreferrer noopener">discussions</a> if you have any questions or ideas.</p>



<p>Compose Hot Reload version 1.0.0 is bundled automatically with the latest Compose Multiplatform 1.10 release. But we are continuing to work on improving both the IDE experience and the underlying technology. So check out our latest <a href="https://github.com/JetBrains/compose-hot-reload/releases" target="_blank" rel="noreferrer noopener">releases</a> and share your feedback!</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Building AI Agents in Kotlin – Part 4: Delegation and Sub-Agents</title>
		<link>https://blog.jetbrains.com/ai/2026/01/building-ai-agents-in-kotlin-part-4-delegation-and-sub-agents/</link>
		
		<dc:creator><![CDATA[Bruno Lannoo]]></dc:creator>
		<pubDate>Tue, 13 Jan 2026 08:27:09 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/KG-social-BlogFeatured-1280x720-1.png</featuredImage>		<product ><![CDATA[kotlin]]></product>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[tutorials]]></category>
		<category><![CDATA[ai]]></category>
		<category><![CDATA[ai-agents]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=ai&#038;p=672689</guid>

					<description><![CDATA[Previously in this series: In the previous installment, we saw how to set up tracing, which brings us to two new questions: What should we experiment with based on the information this tool provides? And what parts of our agent could we improve using its observations? The first idea we had was to experiment with [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Previously in this series:</p>



<ul>
<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Building AI Agents in Kotlin – Part 1: A Minimal Coding Agent</a></li>



<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-2-a-deeper-dive-into-tools/">Building AI Agents in Kotlin – Part 2: A Deeper Dive Into Tools</a></li>



<li><a href="https://blog.jetbrains.com/ai/2025/12/building-ai-agents-in-kotlin-part-3-under-observation/">Building AI Agents in Kotlin – Part 3: Under Observation</a></li>
</ul>



<p>In the previous installment, we saw how to set up tracing, which brings us to two new questions: What should we experiment with based on the information this tool provides? And what parts of our agent could we improve using its observations?</p>



<p>The first idea we had was to <a href="https://github.com/JetBrains/koog/tree/develop/examples/code-agent/step-04-add-subagent" target="_blank" rel="noopener">experiment with sub-agents</a>, or more specifically, a <code>find</code> sub-agent. This will give us a chance to have a look at how Koog makes it easier to implement common patterns like sub-agents. Our hypothesis is that a <code>find</code> sub-agent might reduce overall cost while maintaining, or even improving, performance.</p>



<p>Why would we think that? Well, the main driver of cost is context growth. Each LLM request contains the full context from start to finish, which means each subsequent request is more expensive (at least in terms of input tokens) than the previous one. If we could limit context growth, especially early in the agent&#8217;s run, we might significantly reduce cost. An unnecessarily large context could also distract the agent from its core task. Therefore, by narrowing the context, we might even see a performance improvement, though that’s harder to predict.</p>



<p>The <code>find</code> functionality is particularly suited for removal from the long-term context. When searching for something, you typically open many files that don&#8217;t contain your target. Remembering those dead ends isn&#8217;t useful. Remembering what you actually found is. You could think of this as a natural way of compressing the agent&#8217;s history (we&#8217;ll look at actual compression in a later article).</p>



<p>This task is also a good candidate for a sub-agent because it&#8217;s relatively simple. That simplicity means we could also make use of the sub-agent’s ability to use a different LLM model. In this case, a faster and cheaper one. This offers flexibility that regular compression doesn&#8217;t.</p>



<p>Of course, we could have built a traditional procedural tool to do this. In fact, we did build one called <code>RegexSearchTool</code>, but for the purposes of this experiment, we put it inside the <code>find</code> agent rather than directly in the <code>main</code> agent. This approach provides us with flexibility in terms of model choice while also incorporating an extra layer of intelligence.</p>



<h2 class="wp-block-heading">The <code>find</code> agent</h2>



<p>To be able to have a sub-agent pattern, we first need a second agent. We&#8217;ve already covered agent creation in depth in <a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Part 1</a> of the series, so we won&#8217;t spend much time on this now. However, a few details are still worth noting.</p>



<p>First, a minor point: We&#8217;re using GPT4.1 Mini for this sub-agent because its task is much simpler and doesn&#8217;t require a model as capable as the one used by the <code>main</code> agent.</p>



<p>Second, it&#8217;s useful to look at which tools this agent can access. Like the <code>main</code> agent, it has access to the <code>ListDirectoryTool</code> and <code>ReadFileTool</code>, but not the <code>EditFileTool</code> or <code>ExecuteShellCommandTool</code>. We’ve also given it access to the new procedural search tool we mentioned above, <code>RegexSearchTool</code>, which allows us to search a comprehensive range of files inside a folder and its subfolders using a regex pattern.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">ToolRegistry {
    tool(ListDirectoryTool(JVMFileSystemProvider.ReadOnly))
    tool(ReadFileTool(JVMFileSystemProvider.ReadOnly))
    tool(RegexSearchTool(JVMFileSystemProvider.ReadOnly))
}</pre>



<p>For more detailed information, check out the full implementation <a href="https://github.com/JetBrains/koog/blob/develop/examples/code-agent/step-04-add-subagent/src/main/kotlin/FindAgent.kt" target="_blank" rel="noopener">here</a>.</p>



<h2 class="wp-block-heading">Building a <code>find</code> sub-agent</h2>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-20.png" alt="" class="wp-image-673091"/></figure>



<p>First things first – what is a sub-agent? A sub-agent is really quite simple; it is an agent that is being controlled by another agent. In this specific case, we are working with the agent-as-a-tool sub-agent pattern, where the sub-agent is running inside a tool that is provided to the <code>main</code> agent.</p>



<p>Creating a sub-agent turns out to be straightforward. We know a tool is essentially a function paired with descriptors that the agent can read to understand when and how to call it. We could simply define <a href="https://github.com/JetBrains/koog/blob/3a8b1174458fe0d5a3e02a8c60bbaaf14f6f4caf/agents/agents-core/src/commonMain/kotlin/ai/koog/agents/core/agent/AIAgentTool.kt#L79" target="_blank" rel="noopener">a tool</a> whose <a href="https://github.com/JetBrains/koog/blob/7feb6d49a45fbc8ed7cbb30f5aed67909969a8d1/agents/agents-core/src/commonMain/kotlin/ai/koog/agents/core/agent/AIAgentTool.kt#L119" target="_blank" rel="noopener"><code>.execute()</code></a> function calls our sub-agent. But Koog provides tools to remove even this boilerplate:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">fun createFindAgentTool(): Tool&lt;*, *> {
    return AIAgentService
        .fromAgent(findAgent as GraphAIAgent&lt;String, String>)
        .createAgentTool&lt;String, String>(
            agentName = "__find_in_codebase_agent__",
            agentDescription = """
                &lt;when to call your agent>
            """.trimIndent(),
            inputDescription = """
                &lt;how to call your agent>
            """.trimIndent()
        )
}</pre>



<p>You could think of this as roughly equivalent to:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class FindAgentTool(): Tool&lt;FindAgentTool.Args, FindAgentTool.Result>() {
   override val name: String = "__find_in_codebase_agent__"
   override val description: String = """
      &lt;when to call your agent>
   """
   @Serializable
   public data class Args(
      @property: LLMDescription(
         """
            &lt;how to call your agent>
         """
      )
      val input: String
   )
   @Serializable
   public data class Result(
	val output: String
   )
   override suspend fun execute(args: Args): Result = when {
      output = findAgent.run(args.input)
      Result(output)
   }
}</pre>



<p>In either case, the only things we need to do are:&nbsp;</p>



<ol>
<li>Create our sub-agent.</li>



<li>Give it an <code>agentName</code>.</li>



<li>Specify <strong>when</strong> to call the agent through the <code>agentDescription</code> prompt.</li>



<li>Specify <strong>how</strong> to call the agent through the <code>inputDescription</code> prompt.</li>
</ol>



<p>The prompts are, perhaps, the trickiest part. There’s plenty of room for fine-tuning. But there’s some indication that newer LLMs need less precisely tuned prompts, so perfectly fine-tuned prompts may not be worth our time. We&#8217;re still exploring this topic ourselves, and it will take more experimentation to really come to a strong conclusion.</p>



<p>One thing we did notice is that, if we&#8217;re not careful with the prompts, the <code>main</code> agent sometimes confuses the <code>find</code> agent with a simple <em>Ctrl+F </em>/<em> ⌘F</em> function, sending only the tokens it wants to search for. That’s clearly suboptimal. With so little context, the <code>find</code> agent can’t reason about what it should actually be looking for. To address this, we include instructions requiring the main agent to specify why it&#8217;s looking for something. That way, the find agent can fully leverage its intelligence to <code>find</code> the actual thing the <code>main</code> agent is looking for.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
This tool is powered by an intelligent micro agent that analyzes and understands code context to find specific elements in your codebase.
Unlike simple text search (Ctrl+F / ⌘F), it intelligently interprets your query to locate classes, functions, variables, or files that best match your intent.
It requires a detailed query describing what to search for, why you need this information, and an absolute path defining the search scope.
...
"""</pre>



<figure class="wp-block-table"><table><thead><tr><th>Query WITH highlighting (not <em>Ctrl+F </em>/<em>⌘F</em>)</th><th>Query WITHOUT highlighting (not <em>Ctrl+F </em>/<em>⌘F</em>)</th></tr></thead><tbody><tr><td>Search for changes in <code>get_search_results</code> regarding unnecessary <code>joins</code> to see if there are comment or logic on unnecessary <code>joins</code>.</td><td><code>get_search_results</code></td></tr><tr><td>Search for environment variable usage with <code>SKLEARN_ALLOW</code> or similar in repository to find potential bypass of <code>check_build</code>.</td><td><code>SKLEARN_ALLOW</code></td></tr></tbody></table></figure>



<p>We also noticed that the <code>main</code> agent sometimes still chooses to call the shell tool with a <code>grep</code> command instead of the <code>find</code> agent, which undermines the entire purpose of having a dedicated sub-agent. To avoid this pattern, we added this section to the main system prompt in order to push it harder:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
...
You also have an intelligent find micro agent at your disposal,
which can help you find code components and other constructs more
cheaply than you can yourself. Lean on it for any and all
search operations. Do not use shell execution for find tasks.
...
"""</pre>


<aside style="background: #f8f9fa;border-left: 4px solid #007bff;padding: 1rem 1.5rem;margin: 1.5rem 0;border-radius: 4px">
<p style="margin: 0;color: #555">We also took some lessons from years of IDE development. When you search in your IDE, you don&#8217;t just get file paths and line numbers. You get snippets of the code around each match. This helps you quickly determine whether that&#8217;s actually what you were looking for without opening every file.</p>
<p>We wanted to create a similar experience for the <code>main</code> agent, which is why we prompt the <code>find</code> sub-agent to include snippets in its results:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
...
Prioritize accuracy and relevance in your search results.
* For each result, provide a clear and concise explanation of why it was selected.
* The explanation should state the specific criteria that led to its selection.
* If the match is partial or inferred, clearly state the limitations and potential inaccuracies.
* Include only relevant snippets in the results.
...</pre>
<p>This way, the <code>main</code> agent gets the same rich context we get as engineers, without needing to read through entire files just to verify it found the right thing.</p>
</aside>


<p>This is the &#8220;natural compression&#8221; we mentioned in the opening. The <code>find</code> agent opens many files, follows dead ends, and explores the codebase. But the <code>main</code> agent only sees the results: relevant file paths, snippets, and explanations. All that exploration stays in the <code>find</code> agent&#8217;s context and disappears after it returns. Only the stuff that really mattered is then added to the <code>main</code> agent&#8217;s context.</p>



<h2 class="wp-block-heading">The trade-offs</h2>



<p>Using a sub-agent has its benefits, but it also has downsides. This is certainly the kind of change that warrants experimentation to show whether it delivers the benefits we&#8217;re hoping for without too many sacrifices.</p>



<p>The first trade-off is cost and time. While shortening the context in the main thread helps bring down the cost and time there, we now also have to pay and wait for a number of LLM calls in the sub-agent. The hope is that the total cost and time spent are less, but that depends on how the <code>main</code> agent uses the sub-agent. If it ends up doing a large number of small queries, that benefit might not materialize. We will look at the costs when we run the benchmarks again in a later section, and we will just assume that cost and time are correlated.</p>



<p>We did notice this happening in some of our runs, so we added a segment to the tool’s <code>agentDescription</code> that explains the issue to the <code>main</code> agent and tries to limit the frequency of such high volumes of small queries:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
...
While this agent is much more cost efficient at executing searches than using shell commands, it does lose context in between searches. So give preference to clustering similar searches in one call rather than doing multiple calls to this tool.
...
"""
</pre>



<p>A second trade-off is that this approach treats context retention in a far more black-and-white way than humans do. We may not pull everything that happened in the past into active memory, but we do keep vague impressions of what happened and can retrieve additional context when needed. There are ways to model this kind of behavior, but they are far beyond the scope of the current iteration of our agent and are more related to the deep and complex subject of agentic memory.</p>



<p>Another challenge is that it creates more complexity in tracing. In Langfuse, we no longer only have to look at the trace of just one agent. Indeed, we might even need to look at the behavior from multiple perspectives – both the full view and each agent separately.</p>



<h2 class="wp-block-heading">Think wider: The engineering team analogy</h2>



<p>This technique of using sub-agents isn&#8217;t limited to simple cases like the <code>find</code> agent. You could, for example, replicate the separation of concerns in team structures by assigning analysis, implementation, testing, and planning to different sub-agents.&nbsp;</p>



<p>It&#8217;s still an open question whether an agent with all these capabilities does better or worse than a system where such capabilities are divided among sub-agents, but it&#8217;s not hard to imagine potential benefits. Think of Conway&#8217;s law: &#8220;Organizations design systems that mirror their communication structure.&#8221; One interpretation is that these communication structures evolved to discover efficient patterns worth keeping. The reverse Conway maneuver even suggests this is desirable.<br><br>Could the same be true for role distribution? Maybe the division of tasks across different specializations in software teams also evolved to discover efficient ways of working. Maybe LLMs could benefit from that, too.</p>



<p>Yet this is not guaranteed. The efficiencies might stem largely from spreading the human learning processes, and this might not apply to LLMs. But in the book <a href="https://frc3624wiki.readthedocs.io/en/latest/docs/software/advanced/read/CleanCode.html" target="_blank" rel="noopener"><em>Clean Code</em></a>, we read about wearing different hats: a writer hat (creator), a reader hat (maintainer), and a tester hat (tester). The idea is to focus on one role without being distracted by the perspectives of the others. This suggests task division goes deeper than just learning efficiency, meaning it might indeed be relevant to LLMs.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-8.png" alt="" class="wp-image-672692"/></figure>



<p>All of this is to say that you can take sub-agents a lot further, but whether this is a beneficial approach is still unproven. It&#8217;s still an art form for now, not a hard science.</p>



<h2 class="wp-block-heading">Benchmark results: Testing the hypothesis</h2>



<p>We&#8217;re happy to report that our version without the <code>find</code> sub-agent shows a cost of about $814, or $1.63 per instance, while our version with this sub-agent shows a cost of about $733, or $1.47 per instance. That&#8217;s a <strong>10% cost saving</strong>, which is definitely worth noting.</p>



<p>One interesting observation is how strongly the results depend on the choice of LLM for the sub-agent. In a smaller experiment, we tried keeping our sub-agent connected to GPT-5 Codex, and that dramatically increased the cost to $3.30 per example, averaged over 50 examples.</p>



<figure class="wp-block-table"><table><tbody><tr><td>Experiment</td><td>Success rate</td><td>Cost per instance</td></tr><tr><td>Part 03 (Langfuse)</td><td>56% (278/500)</td><td>$1.63 ($814/500)</td></tr><tr><td>Part 04&nbsp;(sub-agent GPT4.1 mini)</td><td>58% (290/500)</td><td>$1.47 ($733/500)&nbsp;</td></tr><tr><td>Part 04 (sub-agent GPT-5 Codex)</td><td>58% (29/50)</td><td>$3.30 ($165/50)</td></tr></tbody></table></figure>



<p>However, it is interesting to note that we hypothesized two ways to reduce cost. The first was shrinking the context size through the natural compression achieved by task handoffs, and the second was offloading work to a cheaper model. The data suggests that just splitting off a sub-agent (and keeping the GPT-5 Codex model) actually increases the cost significantly, so our first method doesn’t seem to work, while our second (cheaper models) is the one that seems to do the trick – though this may not be rigorous proof.</p>



<p>As for performance improvements, we see a small uptick from 56% to 58%. This could be within the tolerance of statistical variance, but it&#8217;s encouraging that performance at least stayed consistent while we reduced costs.</p>



<h2 class="wp-block-heading">Conclusion</h2>



<p>We&#8217;ve seen that creating sub-agents is both simple and potentially powerful. Koog provides convenient tooling to streamline the process even further, leaving only the prompts for the agent-as-a-tool for you to define.</p>



<p>This technique clearly delivers worthwhile cost savings. We achieved nearly a<strong> 10% reduction</strong> – a clear, measurable improvement. The performance impact is less clear, but it does look like it might be some gains there, too.</p>



<p>At the same time, these kinds of evaluations are expensive. Even with reduced costs, this benchmark still totaled $730. That’s why, in the next part, we will take a closer look at another strategy for lowering costs: a more general approach to compression. In it, we&#8217;ll answer the question, “How do you prevent your context from growing indefinitely, and your costs growing with it?”</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Advent of Code 2025 in Kotlin: Puzzles, Prizes, and Community</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/advent-of-code-2025-in-kotlin/</link>
		
		<dc:creator><![CDATA[Ksenia Shneyveys]]></dc:creator>
		<pubDate>Mon, 12 Jan 2026 19:33:14 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/Featured_1280x720-2x-4.png</featuredImage>		<category><![CDATA[education]]></category>
		<category><![CDATA[news]]></category>
		<category><![CDATA[advent-of-code]]></category>
		<category><![CDATA[aoc]]></category>
		<category><![CDATA[prizes]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=673883</guid>

					<description><![CDATA[Thank you to everyone who participated in Advent of Code 2025 in Kotlin! Once again, it was a joy to see so many of you sharing solutions, cheering each other on in Slack, and keeping the holiday coding spirit alive. This year, we kicked things off with five days of livestreams on December 1–5, with [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Thank you to everyone who participated in <a href="https://adventofcode.com/2025" target="_blank" rel="noreferrer noopener">Advent of Code 2025 in Kotlin</a>! Once again, it was a joy to see so many of you sharing solutions, cheering each other on in Slack, and keeping the holiday coding spirit alive.</p>



<p>This year, we kicked things off with <a href="https://www.youtube.com/watch?v=qJIqcGXuuQs&amp;embeds_referring_euri=https%3A%2F%2Fblog.jetbrains.com%2F" target="_blank" rel="noreferrer noopener">five days of livestreams</a> on December 1–5, with Sebastian Aigner and fantastic guests solving puzzles live, discussing strategies, and showing off idiomatic Kotlin approaches.</p>



<p>If you missed the streams or want to revisit a clever trick, you can still catch up with the recordings:</p>



<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<iframe loading="lazy" title="Advent of Code 2025 in Kotlin. Day 1." src="https://www.youtube.com/embed/qJIqcGXuuQs?list=PLlFc5cFwUnmx9-VIcfxqhjHrwD3Lab4o4" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div></figure>



<h1 class="wp-block-heading">Community</h1>



<p>The Advent of Code puzzles remain available all year round, and so does the community energy. The <a href="https://slack-chats.kotlinlang.org/c/advent-of-code" target="_blank" rel="noreferrer noopener">#advent-of-code</a> channel in the Kotlinlang Slack was once again full of:</p>



<ul>
<li>Creative Kotlin snippets</li>



<li>Non-spoiler hints</li>



<li>Lots of encouragement</li>
</ul>



<p>Whether you took part in discussions every day or just lurked and learned, thank you for making the channel such a friendly, collaborative space.</p>



<p align="center"><a class="ek-link jb-download-button" title="Join the AoC channel in Slack" href="https://slack-chats.kotlinlang.org/c/advent-of-code" target="_blank" rel="noopener">Join the AoC channel in Slack</a></p>



<h1 class="wp-block-heading">Winners</h1>



<p>As in previous years, we invited you to solve Advent of Code puzzles in Kotlin, join our Kotlin leaderboards, and share your solutions on GitHub with the <code>aoc-2025-in-kotlin</code> topic for a chance to win special Kotlin prizes.</p>



<p>This year, we’re celebrating nine winners across three categories: Fastest to Solve, Random, and Community.</p>



<h2 class="wp-block-heading">Fastest to Solve</h2>



<p>These three contestants topped the combined Kotlin leaderboards, consistently solving the puzzles at impressive speed:</p>



<ul>
<li><a href="https://github.com/Kroppeb/AdventOfCodeSolutions2" target="_blank" rel="noreferrer noopener">Kroppeb</a></li>



<li><a href="https://github.com/AndrejStratmann/aoc-2025-in-kotlin" target="_blank" rel="noreferrer noopener">AndrejStratmann</a></li>



<li><a href="https://github.com/770grappenmaker/advent-of-code" target="_blank" rel="noreferrer noopener">770grappenmaker</a><br></li>
</ul>



<p>Congratulations on those lightning-fast stars and Kotlin-powered solutions!</p>



<h2 class="wp-block-heading">Random winners</h2>



<p>To give everyone a chance regardless of speed, we also randomly selected three prize winners from all the participants:</p>



<ul>
<li><a href="http://lbcp" target="_blank" rel="noreferrer noopener">lbcp</a></li>



<li><a href="https://github.com/FelixDombek/AdventOfCode" target="_blank" rel="noreferrer noopener">FelixDombek</a></li>



<li><a href="https://github.com/bjdupuis/Advent-Of-Code252" target="_blank" rel="noreferrer noopener">bjdupuis</a></li>
</ul>



<p></p>



<p>If you see your name here, keep an eye on your inbox. We’ll be in touch about your prize soon.</p>



<h2 class="wp-block-heading">Community winners</h2>



<p>Finally, Advent of Code in Kotlin wouldn’t be the same without the people who answer questions, share insights and alternative solutions, help newcomers get started, and keep the #advent-of-code channel buzzing throughout December.</p>



<p>This year, we’d like to give a special shout-out to these three community stars:</p>



<ul>
<li><a href="https://github.com/jakubgwozdz/advent-of-code-2025" target="_blank" data-type="link" data-id="https://github.com/jakubgwozdz/advent-of-code-2025" rel="noreferrer noopener">jakubgwozdz</a></li>



<li><a href="https://github.com/bj0/aoc-kotlin" target="_blank" rel="noreferrer noopener">bj0</a></li>



<li><a href="https://github.com/ephemient/aoc2025" target="_blank" rel="noreferrer noopener">ephemient</a><br></li>
</ul>



<p>Thank you for your team spirit in the Kotlin community!</p>



<h1 class="wp-block-heading">Keep learning and solving</h1>



<p>Advent of Code might be over for this year, but the puzzles and the learning opportunities remain. If you’d like to keep sharpening your skills and prepare for future events, here are some resources:</p>



<ul>
<li><a href="https://www.youtube.com/playlist?list=PLlFc5cFwUnmx9-VIcfxqhjHrwD3Lab4o4" target="_blank" rel="noreferrer noopener">Advent of Code 2025 in Kotlin</a> YouTube playlist.</li>



<li><a href="https://kotlinlang.org/docs/advent-of-code.html" target="_blank" rel="noreferrer noopener">Solutions to Advent of Code puzzles</a> from previous years in idiomatic Kotlin.</li>



<li><a href="https://www.youtube.com/watch?v=nWPYGH-1hcw" target="_blank" rel="noreferrer noopener">A tutorial</a> on how to explore and solve programming puzzles using Kotlin Notebooks.</li>
</ul>



<p></p>



<p>We want to say a huge thank-you, as always, to Eric Wastl and the Advent of Code team for creating such a beloved set of puzzles year after year.</p>



<p>Let’s keep exploring Kotlin, solving algorithmic challenges, and supporting each other. We hope to see you for the next Advent of Code in Kotlin! 🎄</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How Mobile Development Teams Use Kotlin in 2025: Insights From a Certified Trainer</title>
		<link>https://blog.jetbrains.com/kotlin/2025/12/how-mobile-development-teams-use-kotlin-in-2025/</link>
		
		<dc:creator><![CDATA[Ksenia Shneyveys]]></dc:creator>
		<pubDate>Fri, 19 Dec 2025 14:44:34 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/KT-social-BlogFeatured-1280x720-1-2.png</featuredImage>		<category><![CDATA[news]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=670271</guid>

					<description><![CDATA[This is the second guest post in a two-part series from José Luis González. José Luis has a PhD in software development and is a JetBrains-certified Kotlin Trainer, who works with developers and engineering teams to deepen their Kotlin skills and apply the language effectively in real projects. At Hyperskill, he runs&#160;Kotlin instructor-led training for [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><em>This is the second guest post in a two-part series from José Luis González. José Luis has a PhD in software development and is a JetBrains-certified Kotlin Trainer, who works with developers and engineering teams to deepen their Kotlin skills and apply the language effectively in real projects. At Hyperskill, he runs&nbsp;<a href="https://bootcamps.hyperskill.org/kotlin-bootcamp-for-engineering-teams?utm_source=google&amp;utm_medium=organic&amp;utm_campaign=organic" target="_blank" rel="noreferrer noopener">Kotlin instructor-led training for teams at Hyperskill</a>&nbsp;that focus on advanced topics and practical problem-solving rather than theory.</em></p>



<p><strong>First post in the series:</strong> <a href="https://blog.jetbrains.com/kotlin/2025/12/how-backend-development-teams-use-kotlin-in-2025/">How Backend Development Teams Use Kotlin in 2025: Insights from a Certified Trainer</a></p>



<p>I’d probably have to say swallowing <code>CancellationException</code> in general <code>catch</code> blocks (including <code>runCatching</code>). It looks harmless, but it disables cooperative cancellation, so timeouts, parent scopes, and lifecycles keep running “mysteriously.” In recent talks, linters, and guides, you still see this called out as a real-world production bug. Official docs stress that cancellation must propagate, detekt ships a rule warning if you don’t rethrow, and the coroutines library provides mechanisms that avoid catching <code>CancellationException</code> in generic catch-alls.</p>



<p>Use the following pattern instead to always rethrow cancellations (or choose a helper that preserves them):</p>



<pre class="EnlighterJSRAW">suspend fun &lt;T&gt; safeCall(block: suspend () -&gt; T, fallback: () -&gt; T): T = try {
    block()
} catch (e: CancellationException) {
    throw e // never swallow cancellation
}
// catch other specific exceptions
} catch (e: Exception) {
    logger.error(&quot;call failed&quot;, e)
    fallback()
}</pre>



<p>If you like Result-style API, mirror the <code>kotlinx</code> approach as follows:</p>



<pre class="EnlighterJSRAW">suspend inline fun &lt;T&gt; runSuspendCatching(block: () -&gt; T): Result&lt;T&gt; =
    try { Result.success(block()) }
    catch (e: CancellationException) { throw e }
    catch (e: Throwable) { Result.failure(e) }</pre>



<p>This tiny rethrow keeps structured concurrency intact and matches the guidance you’ll hear in the latest coroutine discussions.</p>



<p><strong>2. If a team has only two hours to set up monitoring for their mobile Kotlin app, which specific dashboards should they prioritize?</strong></p>



<p>Begin with metrics that indicate whether users can successfully use the app. Crash-free users and ANR rate by version and device model tell you whether a release is safe to ship.</p>



<p>Firebase Crashlytics handles this out of the box – just tag builds for quick filtering:</p>



<pre class="EnlighterJSRAW">FirebaseCrashlytics.getInstance().setCustomKeys {
    key(&quot;version&quot;, BuildConfig.VERSION_NAME)
    key(&quot;commit&quot;, BuildConfig.GIT_SHA)
}</pre>



<p>As for UI issues, use JankStats to log when and where frames drop, so you know which screens stutter:</p>



<pre class="EnlighterJSRAW">val jankStats = JankStats.create(window) { frame -&gt;
    if (frame.isJank) Log.d(&quot;Jank&quot;,
        &quot;Jank on ${currentScreen()} – ${(frame.frameDurationUiNanos / 1_000_000)}ms&quot;)
}
jankStats.isTrackingEnabled = true</pre>



<p>Another main concern is performance, of course. With Sentry, you get end-to-end insights into what is actually slowing down your app: startup, navigation, network calls, etc. It correlates frontend and backend timing so you can spot bottlenecks and regressions fast.</p>



<p>Here is a standard setup with tracing and profiling:</p>



<pre class="EnlighterJSRAW">SentryAndroid.init(this) { options -&gt;
    options.dsn = &quot;&lt;dsn&gt;&quot;
    options.tracesSampleRate = 0.1
    options.profilesSampleRate = 0.05
    options.release = &quot;${BuildConfig.VERSION_NAME} (${BuildConfig.VERSION_CODE})&quot;
    options.environment = BuildConfig.BUILD_TYPE
}</pre>



<p>Now, let’s add some custom transactions for key flows:</p>



<pre class="EnlighterJSRAW">val tx = Sentry.startTransaction(&quot;screen:${currentScreen()}&quot;, &quot;ui.load&quot;)
Sentry.configureScope { it.setTransaction(tx) }

val net = tx.startChild(&quot;http.client&quot;, &quot;GET /api/items&quot;)
try { /* network call */ } finally { net.finish() }

val db = tx.startChild(&quot;db.query&quot;, &quot;SELECT items&quot;)
try { /* read */ } finally { db.finish() }

tx.finish()</pre>



<p>And auto-tracing for network calls (<code>OkHttp</code> and <code>Ktor</code>):</p>



<p>OkHttp:</p>



<pre class="EnlighterJSRAW">val client = OkHttpClient.Builder()
    .addInterceptor(SentryOkHttpInterceptor())
    .build()</pre>



<p>Ktor:</p>



<pre class="EnlighterJSRAW">val client = HttpClient(CIO) {
    install(Sentry) {
        tracesSampleRate = 0.1
        profilesSampleRate = 0.05
    }
}</pre>



<p>Sentry Mobile Insights provides a prebuilt dashboard for this. It groups slow transactions and crash-free rate by release and device model, so you can see exactly where users struggle the most without the need for a custom setup.</p>



<p>Here’s how a real trace looks in <code>Sentry</code>: You can see a cold start (<code>app.start.cold</code>), API calls, and rendering time, all visualized in one timeline, for a detailed breakdown of how much time the app spends on various tasks.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobile.png" alt="" class="wp-image-670286"/></figure>



<p>Check these dashboards in <code>Sentry</code>:</p>



<ul>
<li><strong>Performance / Transactions</strong>: p95 duration for <code>app.start.cold</code>, <code>ui.load</code>, and <code>checkout</code>.</li>



<li><strong>Traces / Slow spans</strong> to find lags in HTTP, database, or main-thread work.</li>



<li><strong>Releases / Crash-free and ANR</strong>: Correlate stability with performance.</li>
</ul>



<p><code>Sentry</code> (or <code>Crashlytics</code>) combined with <code>JankStats</code> will give you the full picture. Can users open the app, interact smoothly, and exit without crashes or leaks? <code>Sentry</code> covers both performance and crash tracking, so you can often use it alone, while <code>Crashlytics</code> remains a lightweight alternative many teams already have in place.</p>



<p><strong>3. When a mobile Kotlin application is running slowly in production, what are your top three profiling techniques, and what tools do you use for each?</strong></p>



<p>I wouldn’t say there’s anything groundbreaking here. I usually start with the same baseline we talked about earlier: <code>Crashlytics</code>, <code>JankStats</code>, and <code>Sentry</code> traces. They will provide a comprehensive overview of what’s going on. From there, my top three profiling techniques are pretty straightforward but extremely effective.</p>



<p>Honestly, the standalone <code>Android Studio</code> profiler is still the most powerful and underrated tool out there. I spend most of my time in its CPU and memory profilers, checking which methods block the main thread or which allocations spike during transitions. I always check the <code>Sample Call Stack</code> view, as it’s the fastest way to see where time is actually spent per frame, instead of guessing from logs.</p>



<p>It sounds basic, but it often reveals that a single <code>RecyclerView</code> binding or JSON parser allocates thousands of tiny objects per frame.</p>



<p>Also, I would typically do network profiling. Using the Network Inspector or Sentry’s tracing, I check which requests block rendering or input. If scrolling freezes when images load, you can immediately tell whether it’s an uncompressed call or a missing cache layer without guessing. If you’ve already enabled Sentry Performance in the <em>Monitoring </em>section of the settings menu, it doubles as lightweight production profiling. You can literally see slow transactions by endpoint.</p>



<p>Frame-time profiling is something that comes in handy as well. I like using <code>JankStats</code> or even <code>adb shell dumpsys gfxinfo</code> to see which screens consistently drop frames. Then I pair that with <code>LeakCanary</code> to catch activities or bitmaps that stay alive longer than they should. Together, that tells me exactly what’s slowing the UI down.</p>



<p>In short, you don’t really need fancy tools. CPU, memory, network, and frame-time profiling, all within Android Studio, cover about 90% of the real issues. These profiling tools help identify what&#8217;s making the app feel slow, so you can easily fix the underlying problems.&nbsp;</p>



<p><strong>4. When teams ask about Kotlin Multiplatform, what&#8217;s the smallest project they should start with to prove the concept?</strong></p>



<p>I usually remind teams that they’re probably using <code>Kotlin Multiplatform</code> already. Libraries like <code>kotlinx.coroutines</code> or <code>kotlinx.serialization</code> are basically multiplatform under the hood. You’re just using them from Android today, but they work the same on iOS, too.</p>



<p>The smallest realistic project to actually prove Kotlin Multiplatform in your environment is a shared data or utility layer – something both applications can call without touching the UI. A great first step is to share one simple function, like returning the current time or a version string:</p>



<pre class="EnlighterJSRAW">// commonMain
expect fun currentTime(): Long

// androidMain / iosMain
actual fun currentTime() = System.currentTimeMillis() // or NSDate().timeIntervalSince1970</pre>



<p>Here’s how to connect the Kotlin framework generated from the <code>Kotlin Multiplatform</code> project to your Xcode project:</p>



<p>The <code>embedAndSignAppleFrameworkForXcode</code> task only registers if the <code>binaries.framework</code> configuration option is declared. In your Kotlin Multiplatform project, check the iOS target declaration in the <code>build.gradle.kts</code> file.</p>



<pre class="EnlighterJSRAW">kotlin {
    ios() // or iosArm64(), iosX64(), iosSimulatorArm64()
    binaries {
        framework {
            baseName = &quot;Shared&quot;
        }
    }
}</pre>



<p>To automatically build a shared module in <code>Xcode</code>, you need to add a script. In the <strong>Build Phases</strong> tab, add a run script with the following code:</p>



<pre class="EnlighterJSRAW">cd &quot;$SRCROOT/..&quot;
./gradlew :shared:embedAndSignAppleFrameworkForXcode</pre>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobile1.jpg" alt="" class="wp-image-670297"/></figure>



<p>Using the specified script, access the Gradle task to create and embed the library into the native iOS application.</p>



<p>Then you should move the <strong>Run Script</strong> phase higher, placing it before the <strong>Compile Sources</strong> phase.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobil2.jpg" alt="" class="wp-image-670308"/></figure>



<p>After running the build on the iOS app side or <code>iosApp</code> configuration from the Kotlin Multiplatform project, the compiled <code>xcode-frameworks</code> will appear in the build folder of the shared module.</p>



<p>This will generate the framework at:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobile3.jpg" alt="" class="wp-image-670319"/></figure>



<p>Then import it into Swift:</p>



<pre class="EnlighterJSRAW">import Shared

let t = currentTime() // works directly from the shared Kotlin code</pre>



<p>If that builds and runs cleanly, you’ve already proven that Kotlin code can compile and interop on both sides. From there, you can expand to something slightly more useful. For example, a shared module that fetches and parses a list of items using <code>Ktor</code> and <code>kotlinx.serialization</code>.</p>


    <div class="about-author ">
        <div class="about-author__box">
            <div class="row">
                                                            <div class="about-author__box-img">
                            <img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/1604594047817.jpeg" alt="José Luis González" loading="lazy">
                        </div>
                                        <div class="about-author__box-text">
                                                    <h4>José Luis González</h4>
                                                <p><span style="font-weight: 400;">José Luis González, PhD, is a JetBrains-certified Kotlin Trainer who teaches Kotlin and advanced techniques to development teams. If your team has more questions about Kotlin anti-patterns, idiomatic design, or wants to learn how to write more maintainable Kotlin code, explore his </span><a href="https://bootcamps.hyperskill.org/kotlin-bootcamp-for-engineering-teams" target="_blank" rel="noopener"><span style="font-weight: 400;">instructor-led Kotlin workshops</span></a><span style="font-weight: 400;"> at Hyperskill.</span></p>
                    </div>
                            </div>
        </div>
    </div>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>The Ultimate Guide to Successfully Adopting Kotlin in a Java-Dominated Environment</title>
		<link>https://blog.jetbrains.com/kotlin/2025/12/the-ultimate-guide-to-successfully-adopting-kotlin-in-a-java-dominated-environment/</link>
		
		<dc:creator><![CDATA[Alyona Chernyaeva]]></dc:creator>
		<pubDate>Thu, 18 Dec 2025 15:04:44 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/Blog-Featured-1280x720-1-5.png</featuredImage>		<product ><![CDATA[idea]]></product>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=669909</guid>

					<description><![CDATA[Adopting Kotlin in a Java-centric company&#160; is not about flipping a switch or rewriting everything “the right way”. It’s about people, timing, risk, and trust. Over the last four weeks, we’ve published a series of blog posts by Urs Peter, covering all of these aspects of migrating to Kotlin. In this post, we’ll tie the [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Adopting Kotlin in a Java-centric company&nbsp; is not about flipping a switch or rewriting everything “the right way”. It’s about people, timing, risk, and trust.</p>



<p>Over the last four weeks, we’ve published a series of blog posts by <a href="https://www.linkedin.com/in/urs-peter-70a2882/?originalSubdomain=nl" data-type="link" data-id="https://www.linkedin.com/in/urs-peter-70a2882/?originalSubdomain=nl" target="_blank" rel="noreferrer noopener">Urs Peter</a>, covering all of these aspects of migrating to Kotlin. In this post, we’ll tie the series together and give you one file you can hand to any engineer, tech lead, or manager to help them make the change.</p>



<div class="wp-block-file"><object class="wp-block-file__embed" data="https://blog.jetbrains.com/wp-content/uploads/2025/12/Kotlin-Adoption-Journey.pdf" type="application/pdf" style="width:100%;height:600px" aria-label="Embed of Kotlin Adoption Guide."></object><a id="wp-block-file--media-f1b063f5-cf8d-4fe4-ad98-1a828177863d" href="https://blog.jetbrains.com/wp-content/uploads/2025/12/Kotlin-Adoption-Journey.pdf">Kotlin Adoption Guide</a><a href="https://blog.jetbrains.com/wp-content/uploads/2025/12/Kotlin-Adoption-Journey.pdf" class="wp-block-file__button wp-element-button" aria-describedby="wp-block-file--media-f1b063f5-cf8d-4fe4-ad98-1a828177863d" download>Download</a></div>



<p>Use this post as a map, and when you spot a topic that resonates, check out the PDF for detailed instructions, side‑by‑side code examples, and concrete migration patterns.</p>



<h2 class="wp-block-heading">The journey in five parts</h2>



<p>Kotlin adoption starts with a spark: one or two engineers who feel that Kotlin could make their code a bit clearer, safer, or easier to work with in the long run.</p>



<p>The guide walks you through a five-stage process to make this happen.</p>



<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/10/getting-started-with-kotlin-for-java-developers/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/10/getting-started-with-kotlin-for-java-developers/" rel="noreferrer noopener">&nbsp;Part 1: Getting Started With Kotlin for Java Developers</a></h3>



<p>We’re starting small. And for good reason: You want to introduce Kotlin in a way that can’t possibly hurt production – by using your test suite.</p>



<p>This part shows you how to:</p>



<ul>
<li>Wire Kotlin into an existing Java project.</li>



<li>Use tools like Kotest and MockK.</li>



<li>Use Kotlin’s null safety and collections in code you run every day.</li>
</ul>



<p>The goal here is not to become an expert, but to answer a simple question: “Does working with this language feel better?”</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/10/getting-started-with-kotlin-for-java-developers/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/10/evaluating-kotlin-in-real-projects/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/10/evaluating-kotlin-in-real-projects/" rel="noreferrer noopener">Part 2: Evaluating Kotlin in Real Projects&nbsp;</a></h3>



<p>Once tests feel comfortable, you’ll inevitably start asking yourself, “Can we trust this in production?”</p>



<p>Part 2 explores two paths:</p>



<ul>
<li>Starting a new service in Kotlin (often with Spring Boot).</li>



<li>Adding Kotlin modules to an existing Java system.</li>
</ul>



<p>You’ll see how to avoid the “Java in Kotlin syntax” trap, teaching you how to use extension functions instead of static helpers, nullable types instead of Optional, and data classes and immutability instead of boilerplate models and builders.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/10/evaluating-kotlin-in-real-projects/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/11/growing-kotlin-adoption-in-your-company-2/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/11/growing-kotlin-adoption-in-your-company-2/" rel="noreferrer noopener">Part 3: Growing Kotlin Adoption in Your Company&nbsp;</a></h3>



<p>Part 3 looks at the human side: how to get your colleagues on board with Kotlin by piquing their interest rather than pushing it on them.</p>



<p>This part will give you practical ways to:</p>



<ul>
<li>Provide small, focused examples of Java and Kotlin that respect people’s existing code.</li>



<li>Share a starter repository with Kotlin, linting, tests, and CI already set up.</li>



<li>Hold short clinics, pairing sessions, and chats to give your colleagues a chance to ask you questions.</li>



<li>Build an in‑house Kotlin community that doesn’t depend on a single proponent.</li>
</ul>



<p>The aim is simple: make it easy for others to say, “Let me try this on my next task.”</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/11/growing-kotlin-adoption-in-your-company-2/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/11/helping-decision-makers-say-yes-to-kotlin/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/11/helping-decision-makers-say-yes-to-kotlin/" rel="noreferrer noopener">Part 4: Helping Decision‑Makers Say Yes to Kotlin&nbsp;</a></h3>



<p>Persuading your tech-savvy employees is one thing – but what about your colleagues who ask, “How does Kotlin benefit us as a business?”</p>



<p>Part 4 helps you explain the benefits of Kotlin in terms of business value:</p>



<ul>
<li>Less code to read and maintain.</li>



<li>Fewer defects thanks to null safety and safer defaults.</li>



<li>No re-writing required, as Kotlin has full Java interop and existing frameworks still work.</li>



<li>Developer happiness and hiring – people want to work with thoughtful, cutting-edge tools.</li>



<li>Predictable costs for training, gradual migration, and knowledge‑sharing.<br></li>
</ul>



<p>This part is written to help you have honest conversations with managers and architects who are accountable for risk, not just syntax.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/11/helping-decision-makers-say-yes-to-kotlin/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/11/scaling-kotlin-adoption-across-your-organization/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/11/scaling-kotlin-adoption-across-your-organization/" rel="noreferrer noopener">Part 5: Scaling Kotlin Adoption Across Your Organization</a></h3>



<p>Okay – let’s say you’ve managed to bring managers on board and teams are enjoying coding in Kotlin. Now to address the final question: “We have a lot of Java. How do we migrate without breaking things or burning people out?”</p>



<p>Part 5 focuses on strategy at scale. It suggests:</p>



<ul>
<li>Treating systems differently based on lifecycle:
<ul>
<li>Leave end‑of‑life apps as they are.</li>



<li>Default new builds to Kotlin.</li>



<li>Migrate active systems step by step, not as big‑bang rewrites.</li>
</ul>
</li>



<li>Using the right tools for the job:
<ul>
<li>IDE conversion.</li>



<li>Null‑safety annotations like JSpecify’s.</li>



<li>AI‑assisted refactoring where tests are strong.</li>



<li>Rule‑based automation for large codebases.</li>
</ul>
</li>



<li>Capturing everything in a Kotlin “house playbook” so teams don’t have to re-learn it all from scratch.</li>
</ul>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/11/scaling-kotlin-adoption-across-your-organization/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h2 class="wp-block-heading">Who this guide is for</h2>



<p>The guide is written for people who currently work in Java codebases and care about moving them forward responsibly:</p>



<ul>
<li>Java developers who want safer, more expressive tools without throwing away their experience.</li>



<li>Backend and platform engineers running Spring Boot or similar stacks who need a clear, low‑risk path.</li>



<li>Tech leads and architects who are responsible for consistency across many services and teams.</li>



<li>Engineering managers and decision‑makers who need a transparent view of costs, benefits, and risks.</li>
</ul>



<h2 class="wp-block-heading">Download the complete series as a PDF</h2>



<p>The PDF version brings everything together:</p>



<ul>
<li>All five parts of the journey.</li>



<li>Side‑by‑side Java and Kotlin examples.</li>



<li>Migration patterns, pitfalls to avoid, and success factors at scale.</li>
</ul>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://drive.google.com/file/d/108gx4qiU501_5p9rNZVfsZ5TGqC5zV4q/view?usp=sharing" class="btn" target="_blank" rel="noopener">Download the Kotlin Adoption Guide (PDF)</a>
                                                    </div>
    </div>







<p>Take a look and let us know what you think in the comments. We can&#8217;t wait to hear about how you use it.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Industry Leaders on the KotlinConf&#8217;25 Stage: What Global Brands Built With Kotlin</title>
		<link>https://blog.jetbrains.com/kotlin/2025/12/industry-leaders-on-the-kotlinconf25-stage/</link>
		
		<dc:creator><![CDATA[Daria Voronina]]></dc:creator>
		<pubDate>Wed, 17 Dec 2025 10:24:25 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/JB-social-BlogFeatured-1280x720-1-5.png</featuredImage>		<category><![CDATA[news]]></category>
		<category><![CDATA[case-studies]]></category>
		<category><![CDATA[kotlinconf]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=668688</guid>

					<description><![CDATA[The Kotlin ecosystem continues to grow among the world’s most recognized brands, including Meta, AWS, Duolingo, Uber, and others. At KotlinConf 2025, these companies took the stage to share practical, real-world engineering stories. KotlinConf is where developers can learn directly from the teams building products at global scale. Software engineers showcase how they are tackling [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><strong>The Kotlin ecosystem continues to grow among the world’s most recognized brands, including Meta, AWS, Duolingo, Uber, and others. At KotlinConf 2025, these companies took the stage to share practical, real-world engineering stories.</strong></p>



<p>KotlinConf is where developers can learn directly from the teams building products at global scale. Software engineers showcase how they are tackling challenges in navigation, performance, cross-platform architecture, build tooling, and large-scale migrations. These sessions offer rare, firsthand insights into how industry leaders use Kotlin to solve complex problems in production.</p>



<div style="background-color: #E9D2F7; margin-bottom: 2px; padding: 5px; margin-right: 0%; text-align: left; min-height: px;">
<p><i>Learn directly from the teams building products at global scale. Join KotlinConf’26 and connect with engineers from the world’s leading brands.</i></p>
</div>



<p></p>



<p align="center"><a class="ek-link jb-download-button" title="Save your seat" href="https://pretix.eu/jetbrains/kotlinconf2026/c/XgA8Vnr4a/?utm_source=blog&#038;utm_medium=button&#038;utm_campaign=bigbrands" target="_blank" rel="noopener">Save your seat</a></p>



<p>Here’s a look at some of the standout talks from KotlinConf’25 and the global brands behind them.</p>



<h2 class="wp-block-heading">Real-world Kotlin use at scale</h2>



<p>From navigation systems and build tools to AI-driven migrations and cross-platform architectures, global brands are using Kotlin to solve engineering challenges at massive scale.</p>



<h3 class="wp-block-heading">1. <strong>AWS</strong></h3>



<p><a href="https://2025.kotlinconf.com/talks/794336/" target="_blank" rel="noreferrer noopener"><strong>Blueprints for Scale: What AWS Learned Building a Massive Multiplatform Project</strong></a><strong> </strong>| Matas Lauzadis, Ian Botsford</p>



<p>The AWS team shared firsthand insights from designing, developing, and scaling the AWS SDK for Kotlin – a massive multiplatform project spanning over 300 services and targeting eight distinct platforms. They discussed the challenges they faced, the best practices they adopted, and the strategies that succeeded (and failed) at AWS scale.</p>



<p><em><mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-black-color">Level up your KMP expertise with our workshop on seamless code sharing</mark> </em>➡️<em> </em><a href="https://kotlinconf.com/workshops/#deep-dive-into-kotlin-multiplatform" target="_blank" rel="noreferrer noopener"><em><strong><mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-vivid-purple-color">Learn more</mark></strong></em></a></p>



<h3 class="wp-block-heading">2. <strong>Duolingo</strong></h3>



<p><a href="https://2025.kotlinconf.com/talks/812400/" target="_blank" rel="noreferrer noopener"><strong>Duolingo + KMP: A Case Study in Developer Productivity</strong></a> | John Rodriguez, Johnny Ye</p>



<p>Duolingo ships weekly to more than 40 million daily active users across 176 countries, and Kotlin Multiplatform is playing a growing role in how they move fast. In this talk, the team discussed how they delivered features like Video Call, Math, and Adventures across Android, iOS, and web, which upcoming projects may benefit from KMP, and the challenges faced and lessons learned along the way.</p>



<h3 class="wp-block-heading">3. <strong>Googl</strong>e</h3>



<p><a href="https://2025.kotlinconf.com/talks/793515/" target="_blank" rel="noreferrer noopener"><strong>Deploying Kotlin Multiplatform at Google Workspace</strong></a><strong> </strong>| Jason Parachoniak, Troels Lund</p>



<p>The Google Workspace team discussed the bugs, performance issues, and areas for potential optimization while rolling out Kotlin Multiplatform for certain users. The session included real comparisons with Objective-C, insights into the fixes they implemented, and a Q&amp;A session with the developers who worked on the project.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/Google_2.png" alt="KotlinConf'25 talk: Deploying Kotlin Multiplatform at Google Workspace" class="wp-image-669146"/></figure>



<h3 class="wp-block-heading">4. Meta</h3>



<p><a href="https://2025.kotlinconf.com/talks/857571/" target="_blank" rel="noreferrer noopener"><strong>Build your Kotlin and Android apps with Buck2</strong></a><strong> </strong>| Sergei Rybalkin</p>



<p>Meta announced that Buck2, its large-scale open-source build system, now supports Kotlin and Android. The talk explored building an app from scratch and advanced Buck2 capabilities like remote execution, source-only ABI, and build tool API integrations.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/Meta.png" alt="KotlinConf'25 talk: Build your Kotlin and Android apps with Buck2 (Meta)" class="wp-image-669033"/></figure>



<h3 class="wp-block-heading">5. <strong><strong>Umain, McDonald’s App</strong></strong></h3>



<p><a href="https://2025.kotlinconf.com/talks/779451/" target="_blank" rel="noreferrer noopener"><strong>Leveraging KMP for navigation in the McDonald&#8217;s app</strong></a> | Cas van Luijtelaar, Anthony Bassey</p>



<p>The team behind the McDonald’s app revealed how they extended Kotlin Multiplatform beyond the domain layer to handle navigation on both Android and iOS. The talk covered how they approached cross-platform navigation, the challenges they overcame, and what the architecture looks like today.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/McDonalds.png" alt="KotlinConf'25 talk: Leveraging KMP for navigation in the McDonald's app" class="wp-image-669044"/></figure>



<p><em><mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-black-color">Explore how to build reusable, cross-platform UIs with Compose Multiplatform in our hands-on workshop</mark> </em>➡️<em> </em><a href="https://kotlinconf.com/workshops/#shared-ui-with-compose-multiplatform" target="_blank" rel="noreferrer noopener"><em><mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-vivid-purple-color"><strong>Learn more</strong></mark></em></a></p>



<h3 class="wp-block-heading">6. <strong>Uber</strong></h3>



<p><a href="https://2025.kotlinconf.com/talks/811915/" target="_blank" rel="noreferrer noopener"><strong>Large Scale Changes with AI – Migrating millions of lines of Java to Kotlin at Uber</strong></a> | Ty Smith</p>



<p>Uber has one of the world’s largest Android codebases, and while Kotlin is now first-class, millions of lines of Java still need to be migrated. In this talk, the team outlined the tooling, AI-driven workflows, and processes they’ve developed to safely migrate production code at scale. They covered motivations, challenges in large monorepos, data generation for AI models, agentic systems for deterministic migrations, risk mitigation strategies, PR management, and where this technology is heading next.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/Uber.png" alt="KotlinConf'25 Talk: Large Scale Changes with AI – Migrating millions of lines of Java to Kotlin at Uber" class="wp-image-669055"/></figure>



<p><em><mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-black-color">Explore agentic AI development in our Kotlin workshop using JetBrains’ Koog framework </mark></em>➡️<em> </em><a href="https://kotlinconf.com/workshops/#building-ai-agents-in-kotlin-with-Koog" target="_blank" rel="noreferrer noopener"><em><strong><mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-vivid-purple-color">Learn more</mark></strong></em></a></p>



<h3 class="wp-block-heading">7. X (formerly Twitter)</h3>



<p><a href="https://2025.kotlinconf.com/talks/793302/" target="_blank" rel="noreferrer noopener"><strong>One Codebase, Three Platforms: X&#8217;s Experience with Kotlin Multiplatform</strong></a> | Arkadii Ivanov, Eric Denman</p>



<p>At X, a small team used Kotlin Multiplatform to rebuild a core feature for a multi-million-user platform. Their talk covered the highs and lows of adopting KMP in a real-world project. The speakers provided a rundown of their development process, architectural decisions, libraries used, cross-platform UX considerations, and the challenges of gaining buy-in across iOS and web teams. Watch the recording for a practical look at the lessons learned and how KMP transformed their cross-platform strategy.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/X.png" alt="KotlinConf'25 talk: One Codebase, Three Platforms: X's Experience with Kotlin Multiplatform" class="wp-image-669066"/></figure>



<h2 class="wp-block-heading">Connect with global brands at the flagship Kotlin event of the year</h2>



<p>KotlinConf is where the global Kotlin community comes together to share real engineering breakthroughs, practical lessons, and the ideas shaping the future of the language. At KotlinConf’26, you&#8217;ll meet the teams behind products used around the world, learn directly from the people pushing Kotlin forward, and take home knowledge you can apply immediately.</p>



<p>If you want to sharpen your skills, explore emerging tooling, and connect with the companies driving innovation in Kotlin, this is the place to be.</p>



<p align="center"><a class="ek-link jb-download-button" title="Get tickets" href="https://pretix.eu/jetbrains/kotlinconf2026/c/XgA8Vnr4a/?utm_source=blog&#038;utm_medium=button&#038;utm_campaign=bigbrands" target="_blank" rel="noopener">Get tickets</a></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Kotlin 2.3.0 Released</title>
		<link>https://blog.jetbrains.com/kotlin/2025/12/kotlin-2-3-0-released/</link>
		
		<dc:creator><![CDATA[Alejandra Pedroza Marchena]]></dc:creator>
		<pubDate>Tue, 16 Dec 2025 16:10:38 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/Kotlin-Release-Social-Share-Blog-1280x720-1.png</featuredImage>		<category><![CDATA[releases]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=668086</guid>

					<description><![CDATA[The Kotlin 2.3.0 release is out! This version includes new language features, stable ones, and other features now enabled by default. This release also brings tooling updates, performance improvements for different platforms, and important fixes. Here are some additional highlights from this release: For the complete list of changes, refer to What’s new in Kotlin [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>The Kotlin 2.3.0 release is out! This version includes new language features, stable ones, and other features now enabled by default. This release also brings tooling updates, performance improvements for different platforms, and important fixes. Here are some additional highlights from this release:</p>



<ul>
<li><strong>Language:</strong> More stable and default features, unused return value checker, explicit backing fields, and changes to context-sensitive resolution.</li>



<li><strong>Kotlin/JVM:</strong> Support for Java 25.</li>



<li><strong>Kotlin/Native:</strong> Improved interop through Swift export, faster build time for release tasks, C and Objective-C library import in Beta.</li>



<li><strong>Kotlin/Wasm:</strong> Fully qualified names and new exception handling proposal enabled by default, as well as new compact storage for Latin-1 characters.</li>



<li><strong>Kotlin/JS: </strong>New experimental suspend function export, <code data-enlighter-language="generic" class="EnlighterJSRAW">LongArray</code> representation, unified companion object access, and more.</li>



<li><strong>Gradle:</strong> Compatibility with Gradle 9.0 and a new API for registering generated sources.</li>



<li><strong>Compose compiler:</strong> Stack traces for minified Android applications.</li>



<li><strong>Standard library:</strong> Stable time tracking functionality and improved UUID generation and parsing.</li>
</ul>



<p></p>



<p>For the complete list of changes, refer to <a href="https://kotlinlang.org/docs/whatsnew23.html" target="_blank" rel="noopener">What’s new in Kotlin 2.3.0</a> or the <a href="https://github.com/JetBrains/kotlin/releases/tag/v2.3.0" target="_blank" rel="noopener">release notes on GitHub.</a></p>



<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<iframe loading="lazy" title="What&#039;s New in Kotlin 2.3" src="https://www.youtube.com/embed/_6PSSkqwbp8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div></figure>



<h2 class="wp-block-heading">How to install Kotlin 2.3.0</h2>



<p>The Kotlin plugin is distributed as a bundled plugin in IntelliJ IDEA and Android Studio.</p>



<p>To update to the new Kotlin version, <a href="https://kotlinlang.org/docs/releases.html#update-to-a-new-kotlin-version" target="_blank" rel="noopener">change the Kotlin version</a> to 2.3.0 in your build scripts.</p>



<p>If you need the command-line compiler, download it from the <a href="https://github.com/JetBrains/kotlin/releases/tag/v2.3.0" data-type="link" data-id="https://github.com/JetBrains/kotlin/releases/tag/v2.3.0" target="_blank" rel="noopener">GitHub release page</a>.</p>



<p><strong>If you run into any problems:</strong></p>



<ul>
<li>Find help on <a href="https://app.slack.com/client/T09229ZC6" target="_blank" rel="noopener">Slack</a> (<a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up" target="_blank" rel="noopener">get an invite</a>).</li>



<li>Report issues to our issue tracker, <a href="https://youtrack.jetbrains.com/issues/KT" target="_blank" rel="noopener">YouTrack</a>.</li>
</ul>



<div style="background-color: #f1f6fe; margin-bottom: 2px; padding: 5px; margin-right: 0%; text-align: left; min-height: px;">
<p>Stay up to date with the latest Kotlin features! Subscribe to receive Kotlin updates by filling out the form at the bottom of this post. &#x2b07;&#xfe0f;</p>
</div>



<h2 class="wp-block-heading">Top issue reporters from YouTrack</h2>



<p><a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20rnett" target="_blank" rel="noopener">Ryan Nett</a> (39 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20jsjeon" target="_blank" rel="noopener">Jinseong Jeon</a> (25 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20gamalik" target="_blank" rel="noopener">Andreas Malik</a> (25 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20aviroop" target="_blank" rel="noopener">Aviroop Pal</a> (15 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20apolo" target="_blank" rel="noopener">Pau M</a> (13 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20ZacSweers" target="_blank" rel="noopener">Zac Sweers</a> (13 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20kyay10" target="_blank" rel="noopener">Youssef Shoaib</a> (13 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20clovisai" target="_blank" rel="noopener">Ivan Canet</a> (12 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20martinbonnin" target="_blank" rel="noopener">Martin Bonnin</a> (12 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20Turansky" target="_blank" rel="noopener">Victor Turansky</a> (12 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20Xiaotian-Ma" target="_blank" rel="noopener">xyzboom</a> (11 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20l.wasylkowski" target="_blank" rel="noopener">Łukasz Wasylkowski</a> (10 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20deltazulu" target="_blank" rel="noopener">Donald Duo Zhao</a> (10 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20viuginick.erwg" target="_blank" rel="noopener">Nickolay Viuginov</a> (9 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20rickclephas" target="_blank" rel="noopener">Rick Clephas</a> (8 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20vadim.shabanov" target="_blank" rel="noopener">Vadim Shabanov</a> (7 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20glebminaev" target="_blank" rel="noopener">Gleb Minaev</a> (7 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20Oliver_O" target="_blank" rel="noopener">Oliver O.</a> (7 issues), <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20darksnake" target="_blank" rel="noopener">Alexander Nozik</a> (7 issues), and <a href="https://youtrack.jetbrains.com/issues/?q=project:KT,%20KTIJ%20created:%202025-06-23%20..%20*%20created%20by:%20h0tk3y" target="_blank" rel="noopener">Sergey Igushkin</a> (7 issues).</p>



<h2 class="wp-block-heading">External contributors</h2>



<p>We’d like to thank all of our contributors whose pull requests were included in this release:</p>



<p><a href="https://github.com/ShikaSD" target="_blank" rel="noopener">Andrei Shikov</a>, <a href="https://github.com/troelsbjerre" target="_blank" rel="noopener">Troels Bjerre Lund</a>, <a href="https://github.com/derekxu16" target="_blank" rel="noopener">Derek Xu</a>, <a href="https://github.com/johanbay" target="_blank" rel="noopener">Johan Bay</a>, <a href="https://github.com/aviroop-123" target="_blank" rel="noopener">aviroop</a>, <a href="https://github.com/y9san9" target="_blank" rel="noopener">Alex Sokol / y9san9</a>, <a href="https://github.com/jsjeon" target="_blank" rel="noopener">Jinseong Jeon</a>, <a href="https://github.com/scaventz" target="_blank" rel="noopener">Xin Wang</a>, <a href="https://github.com/edisongz" target="_blank" rel="noopener">Yijie Jiang</a>, <a href="https://github.com/dmaclach" target="_blank" rel="noopener">Dave MacLachlan</a>, <a href="https://github.com/jaebaek" target="_blank" rel="noopener">Jaebaek Seo</a>, <a href="https://github.com/nikita-nazarov" target="_blank" rel="noopener">Nikita Nazarov</a>, <a href="https://github.com/cketti" target="_blank" rel="noopener">cketti</a>, <a href="https://github.com/CharlesLgn" target="_blank" rel="noopener">Charles Lgn</a>, <a href="https://github.com/chuckjaz" target="_blank" rel="noopener">Chuck Jazdzewski</a>, <a href="https://github.com/colincross" target="_blank" rel="noopener">Colin Cross</a>, <a href="https://github.com/Antimonit" target="_blank" rel="noopener">David Khol</a>, <a href="https://github.com/hfmehmed" target="_blank" rel="noopener">Hakan Mehmed</a>, <a href="https://github.com/kralliv" target="_blank" rel="noopener">Iven Krall</a>, <a href="https://github.com/kotcrab" target="_blank" rel="noopener">Kotcrab</a>, <a href="https://github.com/TheMrMilchmann" target="_blank" rel="noopener">Leon Linhart</a>, <a href="https://github.com/gharrma" target="_blank" rel="noopener">Matthew Gharrity</a>, <a href="https://github.com/hondaya14" target="_blank" rel="noopener">Yasuhisa Honda</a>, <a href="https://github.com/ZacSweers" target="_blank" rel="noopener">Zac Sweers</a>, <a href="https://github.com/freya022" data-type="link" data-id="https://github.com/freya022" target="_blank" rel="noopener">freya02</a>, <a href="https://github.com/jitokim" target="_blank" rel="noopener">jitokim</a>, <a href="https://github.com/dev-jonghoonpark" target="_blank" rel="noopener">jonghoonpark</a>, <a href="https://github.com/zangzhicong" target="_blank" rel="noopener">zangzhicong</a></p>



<h2 class="wp-block-heading">Special thanks to our EAP Champions</h2>



<ul>
<li><a href="https://github.com/ychescale9" target="_blank" rel="noreferrer noopener">Yang</a></li>



<li><a href="https://github.com/rickclephas" target="_blank" rel="noreferrer noopener">Rick Clephas</a></li>



<li><a href="https://github.com/JesusMcCloud" target="_blank" rel="noreferrer noopener">Bernd Prünster</a></li>



<li><a href="https://github.com/BoD" target="_blank" rel="noreferrer noopener">Benoit Lubek</a></li>



<li><a href="https://github.com/HagamosVideojuegos" target="_blank" rel="noreferrer noopener">David Lopez</a></li>



<li><a href="https://github.com/molikuner" target="_blank" rel="noreferrer noopener">Florian Schreiber</a></li>



<li><a href="https://github.com/msotho" target="_blank" rel="noreferrer noopener">Sechaba</a></li>



<li><a href="https://github.com/dayanruben" target="_blank" rel="noreferrer noopener">Dayan Ruben</a></li>



<li><a href="https://bsky.app/profile/zacsweers.dev" target="_blank" rel="noreferrer noopener">Zac Sweers</a></li>



<li><a href="https://x.com/noraltavir" target="_blank" rel="noreferrer noopener">Alexander Nozik</a></li>



<li><a href="https://jakewharton.com/" target="_blank" rel="noreferrer noopener">Jake Wharton</a></li>



<li><a href="https://www.linkedin.com/in/lukasz-wasylkowski/" target="_blank" rel="noreferrer noopener">Łukasz Wasylkowski</a></li>



<li><a href="https://github.com/MohamedRejeb" target="_blank" rel="noreferrer noopener">Mohamed Rejeb</a></li>



<li><a href="https://x.com/andy_lamax" target="_blank" rel="noreferrer noopener">Anderson Lameck</a></li>



<li><a href="https://www.linkedin.com/in/yuri-geronimus/" data-type="link" data-id="https://www.linkedin.com/in/yuri-geronimus/" target="_blank" rel="noopener">Yuri Geronimus</a></li>



<li><a href="https://www.linkedin.com/in/johannessvensson/" target="_blank" rel="noreferrer noopener">Johannes Svensson</a></li>



<li><a href="https://www.linkedin.com/in/kacper-wojciechowski-7283561b4/" target="_blank" rel="noreferrer noopener">Kacper Wojciechowski</a></li>
</ul>



<h2 class="wp-block-heading">What else to read</h2>



<ul>
<li><a href="https://kotlinlang.org/docs/whatsnew23.html" target="_blank" rel="noopener">What’s new in Kotlin 2.3.0 documentation</a></li>



<li><a href="https://kotlinlang.org/docs/compatibility-guide-23.html" target="_blank" rel="noopener">Kotlin 2.3.0 compatibility guide</a></li>



<li><a href="https://blog.jetbrains.com/kotlin/2022/11/eap-champions/">Kotlin EAP Champions</a></li>
</ul>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Building AI Agents in Kotlin – Part 3: Under Observation</title>
		<link>https://blog.jetbrains.com/ai/2025/12/building-ai-agents-in-kotlin-part-3-under-observation/</link>
		
		<dc:creator><![CDATA[Denis Domanskii]]></dc:creator>
		<pubDate>Fri, 12 Dec 2025 11:58:45 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/KG-social-BlogFeatured-1280x720-1-1.png</featuredImage>		<product ><![CDATA[kotlin]]></product>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[tutorials]]></category>
		<category><![CDATA[ai]]></category>
		<category><![CDATA[ai-agents]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=ai&#038;p=668115</guid>

					<description><![CDATA[Previously in this series: Two articles in, and our coding agent can already do quite a bit. It can explore projects, read and write code, execute shell commands, and run tests. Adding a definition of done (DoD) in our last article gave it the feedback loop it needed – the agent now iterates until all [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><em>Previously in this series:</em></p>



<ol>
<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Building AI Agents in Kotlin – Part 1: A Minimal Coding Agent</a></li>



<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-2-a-deeper-dive-into-tools/">Building AI Agents in Kotlin – Part 2: A Deeper Dive Into Tools</a></li>
</ol>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p>Two articles in, and our coding agent can already do quite a bit. It can explore projects, read and write code, execute shell commands, and run tests. Adding a definition of done (DoD) in our last article gave it the feedback loop it needed – the agent now iterates until all tests pass, not until it decides it&#8217;s done.</p>



<p>We should be celebrating, right? Well, yes and no.</p>



<p>As the agent gets more capable, debugging becomes more challenging. Each tool adds surface area. The DoD loop adds more calls and tokens. Evaluation runs can take hours, and when something fails, it is often unclear what failed or where the issue started.</p>



<p>Our agent can solve tasks now. Too bad we can&#8217;t see how.</p>



<p>This becomes a problem when you want to improve the agent, debug failures, or estimate costs. In this article, we work through this visibility gap. We start with the obvious options (they don&#8217;t quite work), review common observability tools for LLM apps, and integrate tracing with Langfuse. The result is a step-by-step view of the agent’s actions, including cost per action. Along the way, we uncover behavioral patterns and even find a bug we didn&#8217;t know existed.</p>



<p>Let&#8217;s start by understanding what we&#8217;re missing.</p>



<h2 class="wp-block-heading">Your agent story</h2>



<p>When your agent completes a coding task, it produces a chain of decisions and actions: Read this file, analyze that function, modify this code, run those tests. This chain is the agent&#8217;s trajectory, and it tells the story of how the agent works.</p>



<p>Trajectories matter because they reveal where the agent wastes time and where it goes off track. They show you when the agent reads the same file 47 times, or why it rewrites half your codebase when you asked for a simple bug fix. In short, you can&#8217;t improve what you can&#8217;t observe.</p>



<p>Up to now, we&#8217;ve been getting by with this simple setup:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">handleEvents {  
    onToolCallStarting { ctx ->  
        println("Tool '${ctx.tool.name}' called with args: ${ctx.toolArgs.toString().take(100)}")  
    }  
}</pre>



<p>This was fine for the early steps. It at least showed activity. But we&#8217;ve outgrown it. Without full parameters and observations, we can&#8217;t understand agent behavior in enough detail. And if we print everything, the console turns into noise: object dumps, file contents, and error messages all mixed together.</p>



<p>We need something better.</p>



<h3 class="wp-block-heading">&#8220;Just turn on logging&#8221;</h3>



<p>Let&#8217;s try the obvious solution first. <a href="https://docs.koog.ai/" target="_blank" rel="noopener">Koog</a> has built-in debug logging, so we switch Logback from <code>ERROR</code> to <code>DEBUG</code> and run it again:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/image-23.png" alt="" class="wp-image-668118"/></figure>



<p>Three minutes and thousands of lines later: Informative? Yes. Convenient? No! </p>



<p>Verbose logs have their place. In production, they help with postmortems. They also help when you want to extract insights and analyze behavior patterns across many runs. But when you’re debugging a single run and trying to understand why your agent is stuck in a loop, you need something built for humans, not statistical analysis.</p>



<h3 class="wp-block-heading">The money trail</h3>



<p>While those logs aren&#8217;t ideal for debugging, they did remind us about something else we should be tracking: usage statistics. OpenAI&#8217;s dashboard provides detailed breakdowns of API consumption per key. It answers one question quickly: Are we burning through our budget?</p>



<p>But it still doesn’t answer the question that matters during development: What does one run cost?</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/image-24.png" alt="" class="wp-image-668129"/></figure>



<p>Okay, $25 in one week. Useful, but not the complete picture. The OpenAI dashboard does what it&#8217;s designed to do: track organization-level API usage. But for agent development, we need run-level insights. We can see the total, but not which tasks cost $0.50 and which cost $5.00.</p>



<p>Now add more moving parts. If we split work across sub-agents and use different providers for specific steps (to be discussed in upcoming articles), we end up with multiple dashboards and no single view of the true cost of a run. And if several people share the same agent setup, it gets even harder to see who spent what and where.</p>



<p>The API key approach works for one agent, one provider, and limited runs. It’s a start, but it doesn’t scale. We need observability.</p>



<h3 class="wp-block-heading">The four-line integration</h3>



<p>We&#8217;re not the first to encounter this issue. Over the last few years, an ecosystem of observability tools has formed around LLM apps and agents. There are proprietary tools such as Weights &amp; Biases Weave and LangSmith, as well as open-source options like Langfuse, Opik, Arize Phoenix, OpenLLMetry, Helicone, OpenLIT, and Lunary. Some are cloud-based, others support self-hosting, and some offer both. Each comes with its own strengths and trade-offs.</p>



<p>After evaluating several options, our team chose Langfuse. The decision came down to practical factors: It&#8217;s open source with a self-hosted option (so traces stay under your control), it offers a free cloud tier for getting started, the UI makes it easier to inspect traces, and the team is responsive when questions come up.</p>



<p>The integration itself is straightforward. Koog needs four lines to connect to Langfuse:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">) {
+   install(OpenTelemetry) {  
+       setVerbose(true) 
+       addLangfuseExporter()  
+   }
    handleEvents {  
        // existing handlers remain
    }
}</pre>



<p>That&#8217;s it.</p>


<aside style="background: #f8f9fa; border-left: 4px solid #007bff; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
<p style="margin: 0; color: #555;">If you use another OpenTelemetry-compatible service, <a href="https://docs.koog.ai/opentelemetry-support/#opentelemetry-http-exporter" target="_blank" rel="noopener">generic OpenTelemetry integration</a> works as well.</p>
</aside>


<p>A quick note about the <code>setVerbose(true)</code>: Koog sends only telemetry metadata by default. Full details are sent only if you enable verbose mode. Prompts and responses remain hidden, which makes sense when traces can include customer data. During agent development, you often need full visibility, and verbose mode enables that.</p>



<p>Setting up Langfuse takes about five minutes. For this article, we’re using their free cloud instance, but you can also run <a href="https://langfuse.com/self-hosting/deployment/docker-compose" target="_blank" rel="noopener">the full stack locally in Docker</a>.</p>



<ol>
<li>Create an account at <a href="https://cloud.langfuse.com/" target="_blank" rel="noopener">cloud.langfuse.com</a>.</li>



<li>Create an organization.</li>



<li>Create a project.</li>



<li>Click <em>Create API Key</em>.</li>
</ol>



<p>You&#8217;ll get three values:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">export LANGFUSE_HOST="https://cloud.langfuse.com"
export LANGFUSE_PUBLIC_KEY="&lt;your-public-key>"
export LANGFUSE_SECRET_KEY="&lt;your-secret-key>"</pre>



<p>Koog reads these values from the execution environment. If you need to pass them in code, you can pass them directly to <code>addLangfuseExporter</code>. Here&#8217;s our complete agent with observability enabled:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val executor = simpleOpenAIExecutor(System.getenv("OPENAI_API_KEY"))
val agent = AIAgent(
    promptExecutor = executor,
    llmModel = OpenAIModels.Chat.GPT5Codex,
    toolRegistry = ToolRegistry {
        tool(ListDirectoryTool(JVMFileSystemProvider.ReadOnly))
        tool(ReadFileTool(JVMFileSystemProvider.ReadOnly))
        tool(EditFileTool(JVMFileSystemProvider.ReadWrite))
        tool(ExecuteShellCommandTool(JvmShellCommandExecutor(), PrintShellCommandConfirmationHandler()))
    },
    systemPrompt = """
        You are a highly skilled programmer tasked with updating the provided codebase according to the given task.
        Your goal is to deliver production-ready code changes that integrate seamlessly with the existing codebase and solve given task.
        Ensure minimal possible changes done - that guarantees minimal impact on existing functionality.
        
        You have shell access to execute commands and run tests.
        After investigation, define expected behavior with test scripts, then iterate on your implementation until the tests pass.
        Verify your changes don't break existing functionality through regression testing, but prefer running targeted tests over full test suites.
        Note: the codebase may be fully configured or freshly cloned with no dependencies installed - handle any necessary setup steps.
        """.trimIndent(),
    strategy = singleRunStrategy(ToolCalls.SEQUENTIAL),
    maxIterations = 400
) {
    install(OpenTelemetry) {
        setVerbose(true) // Send full strings instead of HIDDEN placeholders
        addLangfuseExporter()
    }
    handleEvents {
        onToolCallStarting { ctx ->
            println("Tool '${ctx.tool.name}' called with args: ${ctx.toolArgs.toString().take(100)}")
        }
    }
}</pre>



<h3 class="wp-block-heading">The first trace</h3>



<p>Let&#8217;s start with a simple task: Find the <code>main()</code> function in your project. Run it, wait for it to finish, and then open the <em>Tracing</em> tab in your Langfuse project.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/image-28.png" alt="" class="wp-image-668292"/></figure>



<p>Immediately, the table displays something useful: the <em>Total Cost</em> column. Koog reports token counts, Langfuse applies pricing, and you can see that finding <code>main()</code> costs $0.016.</p>



<p>Open the trace to see the full run.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/image-26.png" alt="" class="wp-image-668146"/></figure>



<p>The left-hand panel shows your agent&#8217;s trajectory: messages, tool calls, and observations in order, with indentation indicating the call hierarchy. The right-hand panel displays details for each step: prompts, responses, tool parameters, and per-span cost breakdown.</p>



<p>At the bottom, you’ll also see an execution graph that visualizes the flow. For more details on Koog&#8217;s graph-based strategies, check out the <a href="https://docs.koog.ai/custom-strategy-graphs/" target="_blank" rel="noopener">documentation</a>. You can also read a deep dive by the Koog tech lead: <a href="https://blog.kotlin-academy.com/how-to-design-a-flexible-graph-based-strategy-in-koog-52b1fb24802d" target="_blank" rel="noopener">Mixing the Secret AI Sauce: How to Design a Flexible, Graph-Based Strategy in Koog</a>.</p>



<h3 class="wp-block-heading">Discovering issues through observability</h3>



<p>While preparing examples for this article, we noticed a failed tool call highlighted in red.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/image-25.png" alt="" class="wp-image-668144"/></figure>



<p>The observation was:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">endLine=400 must be &lt;= lineCount=394 or -1</pre>



<p>The agent requested lines 0–400, but the file had only 394 lines. This points to a limitation in our tool implementation. Instead of failing, it should clamp the range and return the available lines (0–394), allowing the agent to continue. Without traces, this kind of issue often gets buried in logs. With traces, you see it in the exact run, at the exact step, and with the exact input.</p>



<p>That’s why observability matters. It shows not just <em>that</em> something failed, but also <em>how</em> and <em>why</em>, which makes fixes much easier.</p>



<h3 class="wp-block-heading">Working with evaluation runs</h3>



<p>Single traces are great for debugging, but evaluation runs need a batch view.&nbsp;</p>



<p>When you run your agent across multiple <a href="https://openai.com/index/introducing-swe-bench-verified/" target="_blank" rel="noopener">SWE-bench Verified</a> tasks (a standard benchmark for coding agents), you want grouped traces and aggregated cost.</p>



<p>Langfuse supports this through sessions. Add a session ID as a trace attribute:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">install(OpenTelemetry) {
    setVerbose(true)
    addLangfuseExporter(  
        traceAttributes = listOf(  
            CustomAttribute("langfuse.session.id", "eval-run-1"),  
        )  
    )
}</pre>


<aside style="background: #f8f9fa;border-left: 4px solid #007bff;padding: 1rem 1.5rem;margin: 1.5rem 0;border-radius: 4px">
<p style="margin: 0;color: #555">You can also add other attributes, such as user IDs or environment tags. See the <a href="https://langfuse.com/integrations/native/opentelemetry#trace-level-attributes" target="_blank" rel="noopener">trace-level attributes documentation</a> if you need them. For now, session grouping is enough.</p>
</aside>


<p>With this configuration, traces from the evaluation share a session ID. In Langfuse, navigate to the <em>Sessions</em> tab to see aggregate duration and total cost.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/image-27.png" alt="" class="wp-image-668173"/></figure>



<p>In our run, we executed 50 SWE-bench Verified tasks (out of 500). With ten parallel instances, the run took 30 minutes and cost $66. This gives a baseline for future experiments: success rate, runtime<em>, </em>and cost.</p>



<p>Langfuse doesn&#8217;t show success scores by default. That&#8217;s expected. Tracing records what happened, not whether a run passed. If you want success metrics in Langfuse, your evaluation harness needs to score each attempt and report <a href="https://langfuse.com/docs/evaluation/evaluation-methods/custom-scores" target="_blank" rel="noopener">custom scores</a>. It&#8217;s worth implementing if you have the supporting infrastructure.</p>



<h3 class="wp-block-heading">Looking ahead</h3>



<p>Observability isn&#8217;t just about debugging. It&#8217;s also how you learn about the agent’s behavior.&nbsp;</p>



<p>With a few lines of code, we turned the agent from a black box into something you can inspect. We caught that line-range error that would likely have gone unnoticed. We learned that our 50-task evaluation costs $66. And we can now see which tasks consume tokens and which run efficiently.</p>



<p>In the next article, we’ll introduce a sub-agent pattern: Delegate specific tasks to smaller, cheaper models. With traces in place, you can decide what to delegate based on what the agent does in each run. No more guessing.</p>



<h3 class="wp-block-heading">Resources</h3>



<ul>
<li><a href="https://github.com/JetBrains/koog/tree/develop/examples/code-agent/step-03-add-observability" target="_blank" rel="noopener">Complete code for this article</a></li>



<li><a href="https://docs.koog.ai/opentelemetry-support/" target="_blank" rel="noopener">Koog OpenTelemetry documentation</a></li>



<li><a href="https://docs.koog.ai/opentelemetry-langfuse-exporter/" target="_blank" rel="noopener">Koog Langfuse integration</a></li>



<li><a href="https://langfuse.com/integrations/native/opentelemetry" target="_blank" rel="noopener">Langfuse OpenTelemetry support</a></li>
</ul>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p><em>Thank you for reading! I&#8217;d be happy to hear about your own approaches to trace analysis – what patterns have you spotted in your agents&#8217; behavior? What surprised you? Feel free to share your experience in the comments!</em></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>A Better Way to Explore kotlinx-benchmark Results with Kotlin Notebooks</title>
		<link>https://blog.jetbrains.com/kotlin/2025/12/a-better-way-to-explore-kotlinx-benchmark-results-with-kotlin-notebooks/</link>
		
		<dc:creator><![CDATA[Filipp Zhinkin]]></dc:creator>
		<pubDate>Thu, 11 Dec 2025 16:02:35 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/KT-social-BlogFeatured-1280x720-1-1.png</featuredImage>		<category><![CDATA[news]]></category>
		<category><![CDATA[benchmark]]></category>
		<category><![CDATA[kotlin-notebook]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=667810</guid>

					<description><![CDATA[Benchmarking is an important part of writing efficient Kotlin code. The kotlinx-benchmark library helps you measure and compare performance across different implementations or hardware configurations. However, raw text results only take you so far. Sometimes you need to visualize your data, not just read it. That’s where Kotlin notebooks come in. Kotlin notebooks combine the [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Benchmarking is an important part of writing efficient Kotlin code. The <a href="https://github.com/Kotlin/kotlinx-benchmark" target="_blank" rel="noopener"><code>kotlinx-benchmark</code></a> library helps you measure and compare performance across different implementations or hardware configurations.</p>



<p>However, raw text results only take you so far. Sometimes you need to visualize your data, not just read it. That’s where <strong>Kotlin notebooks</strong> come in.</p>



<p>Kotlin notebooks combine the expressiveness of Kotlin with the interactivity of notebook-style development. They give you one convenient place where you can:</p>



<ul>
<li>Load results as structured data.</li>



<li>Explore results using the DataFrame API.</li>



<li>Visualize results with charts.</li>
</ul>



<h3 class="wp-block-heading"><strong>Why use notebooks for benchmarking?</strong></h3>



<p>Let’s say you’ve run a benchmark suite and obtained text output from kotlinx.benchmark:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Benchmark                              Mode     Cnt Score    Error  Units

maps.LinearSearch                      avgt     10  12.500 ± 0.900  ms/op

maps.BinarySearch                      avgt     10   8.300 ± 0.600  ms/op

maps.HashLookup                        avgt     10   4.700 ± 0.400  ms/op

lists.Filter                           avgt     10  15.200 ± 1.200  ms/op

lists.Map                              avgt     10   9.800 ± 0.700  ms/op</pre>



<p>The table works fine for a quick look, but once you accumulate more data, it becomes harder to navigate. Visualizing the same data gives you an instant overview of which implementations perform better and how stable the results are.</p>



<p>You can use Kotlin notebooks to visualise that data quickly:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/image-18.png" alt="" class="wp-image-667820"/></figure>



<p>You can also run the same notebook on another machine and compare the results visually, revealing performance differences between environments or commits.</p>



<h3 class="wp-block-heading"><strong>Comparing benchmark results</strong></h3>



<p>Kotlin notebooks make it easy to analyze and plot results from one or more benchmark runs.<br>For example, you can:</p>



<ul>
<li>Read benchmark JSON files generated by <code>kotlinx-benchmark</code>.</li>



<li>Convert the results into typed DataFrames.</li>



<li>Compute metrics such as percentage improvements.</li>



<li>Plot the results with Kandy charts.</li>



<li>Account for confidence intervals to perform statistically rigorous comparisons.</li>
</ul>



<p>Several benchmark examples are available in the examples folder of the kotlinx-benchmark repository.&nbsp;</p>



<p><strong>Generating and sharing notebooks</strong></p>



<p>Once your notebook is ready, you can:</p>



<ul>
<li>Create a GitHub gist to share results quickly.</li>



<li>Commit the notebook to your project for reproducible performance tracking.</li>



<li>Publish it with<a href="https://datalore.jetbrains.com" target="_blank" rel="noopener"> JetBrains Datalore</a> for interactive viewing online.</li>
</ul>



<p>This workflow makes benchmark results easier to understand and share with your team.</p>



<h3 class="wp-block-heading"><strong>Learn more</strong></h3>



<ul>
<li><a href="https://kotl.in/pnq8fr" target="_blank" data-type="link" data-id="https://github.com/Kotlin/kotlinx-benchmark/tree/master/examples" rel="noreferrer noopener">kotlinx-benchmark examples</a></li>



<li><a href="https://kotlinlang.org/docs/kotlin-notebook-overview.html" target="_blank" rel="noopener">Kotlin Notebook documentation<br></a></li>
</ul>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
