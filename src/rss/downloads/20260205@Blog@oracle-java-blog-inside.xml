<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2026-02-05T07:13:24+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">LazyConstants in JDK 26 - Inside Java Newscast #106</title><link href="https://inside.java/2026/02/05/newscast-106/" rel="alternate" type="text/html" title="LazyConstants in JDK 26 - Inside Java Newscast #106" /><published>2026-02-05T00:00:00+00:00</published><updated>2026-02-05T00:00:00+00:00</updated><id>https://inside.java/2026/02/05/Newscast-106</id><content type="html" xml:base="https://inside.java/2026/02/05/newscast-106/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/BZlXZyXA4jY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Lazily initializing fields in Java is error-prone and undermines constant-folding. JDK 26 comes with JEP 526, which previews <code class="language-plaintext highlighter-rouge">LazyConstant</code>, a type that lazily initializes a value through a given <code class="language-plaintext highlighter-rouge">Supplier</code>. It executes that supplier at most once successfully and then assigns the value to a field annotated with <code class="language-plaintext highlighter-rouge">@Stable</code>, which allows constant folding. This API is also a poster child for how OpenJDK develops and evolves features.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=BZlXZyXA4jY">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><summary type="html"><![CDATA[Lazily initializing fields in Java is error-prone and undermines constant-folding. JDK 26 comes with JEP 526, which previews LazyConstant, a type that lazily initializes a value through a given Supplier. It executes that supplier at most once successfully and then assigns the value to a field annotated with @Stable, which allows constant folding. This API is also a poster child for how OpenJDK develops and evolves features.]]></summary></entry><entry><title type="html">Level Up Your LangChain4j Apps for Production</title><link href="https://inside.java/2026/02/01/devoxxbelgium-production-langchain4j/" rel="alternate" type="text/html" title="Level Up Your LangChain4j Apps for Production" /><published>2026-02-01T00:00:00+00:00</published><updated>2026-02-01T00:00:00+00:00</updated><id>https://inside.java/2026/02/01/DevoxxBelgium-Production-Langchain4j</id><content type="html" xml:base="https://inside.java/2026/02/01/devoxxbelgium-production-langchain4j/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/yXuKLPpleBg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This session demonstrates how LangChain4j can help, showcasing a set of often overlooked techniques that keep AI systems on track and unlock more advanced use cases. We explore LangChain4j’s advanced RAG methods for finding all relevant information across documents, databases, APIs, and more, and share practical tips for effective tool calls and responsible MCP usage. You will also see how LangChain4j’s agentic approach lets you decompose complex workflows for greater clarity and control. The presentation wraps up with a guided build of a production-ready agentic system, including the operational and legal considerations that matter once you move beyond PoC.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;LizeRaes&quot;]</name></author><category term="AI" /><summary type="html"><![CDATA[This session demonstrates how LangChain4j can help, showcasing a set of often overlooked techniques that keep AI systems on track and unlock more advanced use cases. We explore LangChain4j’s advanced RAG methods for finding all relevant information across documents, databases, APIs, and more, and share practical tips for effective tool calls and responsible MCP usage. You will also see how LangChain4j’s agentic approach lets you decompose complex workflows for greater clarity and control. The presentation wraps up with a guided build of a production-ready agentic system, including the operational and legal considerations that matter once you move beyond PoC.]]></summary></entry><entry><title type="html">Episode 44 “Java, Collections &amp;amp; Generics, BeJUG”</title><link href="https://inside.java/2026/01/29/podcast-044/" rel="alternate" type="text/html" title="Episode 44 “Java, Collections &amp;amp; Generics, BeJUG”" /><published>2026-01-29T00:00:00+00:00</published><updated>2026-01-29T00:00:00+00:00</updated><id>https://inside.java/2026/01/29/Podcast-044</id><content type="html" xml:base="https://inside.java/2026/01/29/podcast-044/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/ChadMic.jpg?628608795" /></p>

<p><br /></p>

<iframe title="Libsyn Player" style="border: none" src="//html5-player.libsyn.com/embed/episode/id/39908260/height/90/theme/custom/thumbnail/yes/direction/forward/render-playlist/no/custom-color/000000/" height="90" width="100%" scrolling="no"></iframe>

<div class="youtube-embed">
<iframe src="https://www.youtube.com/embed/P4f0FHizUCg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</div>

<p><br /></p>

<p>In this special episode of the Inside Java Podcast, Nicolai Parlog talks to Adam Bien about scripting with Java, to Maurice Naftalin about the history and tradeoffs of the collections framework and erasure, and to Tom Cools about the innovative way the Belgian Java User Group organizes itself.</p>

<p><br />
Make sure to also check the <strong>Duke’s Corner podcast</strong> on <a href="https://dev.java/duke/corner/">dev.java</a>.</p>

<p><br /></p>

<h3 id="additional-resources">Additional resources</h3>

<ul>
  <li><a href="https://inside.java">Inside.java</a> : News and views from members of the Java team at Oracle</li>
  <li><a href="https://dev.java">Dev.java</a> : The Destination for Java Developers</li>
  <li><a href="https://openjdk.java.net/">OpenJDK</a></li>
  <li><a href="https://www.oracle.com/java/">Oracle Java</a></li>
</ul>

<p>For more episodes, check out <a href="https://inside.java/podcast">Inside Java</a>, our <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzV_hXbRevwzrXSMcGNzhxiZ">YouTube playlist</a>, and follow <a href="https://twitter.com/java">@Java</a> on Twitter.</p>

<p>Contact us <a href="https://inside.java/about/">here</a>.</p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="Java Language" /><category term="Community" /><summary type="html"><![CDATA[In this special episode of the Inside Java Podcast, Nicolai Parlog talks to Adam Bien about scripting with Java, to Maurice Naftalin about the history and tradeoffs of the collections framework and erasure, and to Tom Cools about the innovative way the Belgian Java User Group organizes itself.]]></summary></entry><entry><title type="html">Data-Oriented Programming for Java: Beyond Records</title><link href="https://inside.java/2026/01/27/beyond-records/" rel="alternate" type="text/html" title="Data-Oriented Programming for Java: Beyond Records" /><published>2026-01-27T00:00:00+00:00</published><updated>2026-01-27T00:00:00+00:00</updated><id>https://inside.java/2026/01/27/beyond-records</id><content type="html" xml:base="https://inside.java/2026/01/27/beyond-records/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;BrianGoetz&quot;]</name></author><category term="Amber" /><summary type="html"><![CDATA[Records, sealed classes, and destructuring with record patterns constitute the first feature arc of “data-oriented programming” for Java. After considering numerous design ideas, we’re now ready to move forward with the next “data oriented programming” feature arc: carrier classes (and interfaces.)]]></summary></entry><entry><title type="html">Oracle Java Extension for Visual Studio Code Version 25.0.1 Is Now Available!</title><link href="https://inside.java/2026/01/23/java-vscode-extension-update/" rel="alternate" type="text/html" title="Oracle Java Extension for Visual Studio Code Version 25.0.1 Is Now Available!" /><published>2026-01-23T00:00:00+00:00</published><updated>2026-01-23T00:00:00+00:00</updated><id>https://inside.java/2026/01/23/java-vscode-extension-update</id><content type="html" xml:base="https://inside.java/2026/01/23/java-vscode-extension-update/"><![CDATA[<p>New release of Java Platform Extension for VS Code</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/duke-vscode.jpg?622874632" /></p>]]></content><author><name>[&quot;ArvindAprameya&quot;]</name></author><category term="Oracle" /><summary type="html"><![CDATA[New release of Java Platform Extension for VS Code]]></summary></entry><entry><title type="html">Carrier Classes; Beyond Records - Inside Java Newscast #105</title><link href="https://inside.java/2026/01/22/newscast-105/" rel="alternate" type="text/html" title="Carrier Classes; Beyond Records - Inside Java Newscast #105" /><published>2026-01-22T00:00:00+00:00</published><updated>2026-01-22T00:00:00+00:00</updated><id>https://inside.java/2026/01/22/Newscast-105</id><content type="html" xml:base="https://inside.java/2026/01/22/newscast-105/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/cpGceyn7DBE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This episode presents Project Amber lead Brian Goetz’s recent email “Data Oriented Programming, Beyond Records”, wherein he describes plans to improve Java’s data handling capabilities by introducing carrier classes, a generalization of records.</em> 
<em>Like them, carrier classes describe their state through a component list that defines the type’s external API: accessors, a constructor, and matching deconstructor - this allows carrier classes to participate in pattern matching and reconstruction. Unlike records, the implementation of this API remains the developer’s task although component fields offer a shortcut for the common case where the API does map to a field. Carrier classes don’t have to be final (and can hence participate in inheritance) and neither do their fields (so they can be mutable data carriers).</em></p>

<p><em>The email also mentions carrier interfaces, allowing records to be abstract as well as a relaxation of deconstruction patterns that make them more amenable to evolution of the matched type. This episode also briefly touches on Gavin Bierman’s mail to the Project Amber mailing list that announces pattern assignments and constant patterns.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=cpGceyn7DBE">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="Amber" /><summary type="html"><![CDATA[This episode presents Project Amber lead Brian Goetz’s recent email “Data Oriented Programming, Beyond Records”, wherein he describes plans to improve Java’s data handling capabilities by introducing carrier classes, a generalization of records.]]></summary></entry><entry><title type="html">Optimizing GPU Programs from Java using Babylon and HAT</title><link href="https://inside.java/2026/01/19/hat-matmul-gpu/" rel="alternate" type="text/html" title="Optimizing GPU Programs from Java using Babylon and HAT" /><published>2026-01-19T00:00:00+00:00</published><updated>2026-01-19T00:00:00+00:00</updated><id>https://inside.java/2026/01/19/hat-matmul-gpu</id><content type="html" xml:base="https://inside.java/2026/01/19/hat-matmul-gpu/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;JuanFumero&quot;]</name></author><category term="Babylon" /><summary type="html"><![CDATA[The Heterogeneous Accelerator Toolkit (HAT) is a parallel programming framework that allows Java developers to offload Java code and dispatch the generated code on modern hardware accelerators, such as Graphics Processing Units (GPUs). This article provides an overview of the HAT programming model: using matrix-multiplication as an example, we demonstrate how Java developers can tune GPU workloads from the Java side to achieve performance close to native cuBLAS, scaling from 7 GFLOP/s on CPUs to 14 TFLOP/s on an NVIDIA A10 GPU.]]></summary></entry><entry><title type="html">1B Rows with the Memory API - JEP Cafe #25</title><link href="https://inside.java/2026/01/17/jepcafe25/" rel="alternate" type="text/html" title="1B Rows with the Memory API - JEP Cafe #25" /><published>2026-01-17T00:00:00+00:00</published><updated>2026-01-17T00:00:00+00:00</updated><id>https://inside.java/2026/01/17/JEPCafe25</id><content type="html" xml:base="https://inside.java/2026/01/17/jepcafe25/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/lVORyDhQzf8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>In this JEP Café episode, we take on the well-known ‘1 Billion Rows Challenge’ and implement it using the standard Memory API introduced in JDK 22. The goal of this implementation is not to break any speed records, but to show you how one can process binary data using standard patterns offered by the JDK, in a clean and efficient way.</em></p>

<p><em>You will see how the different elements of the Memory API are working together. First, you will see which Arena implementation to choose from, among the four given to you by the API. Then you will create Memory Segments to map your multi gigabytes file in the off-heap memory. And then, you will define MemoryLayouts to describe their content in a structured way. Lastly, you will use VarHandles and parallel streams to access and process this data. You see how fast you can go with these clean and standard patterns, that you can use in your own application.</em></p>

<p>Make sure to check the <a href="https://www.youtube.com/watch?v=lVORyDhQzf8">show-notes</a>!</p>]]></content><author><name>[&quot;JosePaumard&quot;]</name></author><category term="Panama" /><category term="Performance" /><summary type="html"><![CDATA[In this JEP Café episode, we take on the well-known '1 Billion Rows Challenge' and implement it using the standard Memory API introduced in JDK 22. The goal of this implementation is not to break any speed records, but to show you how can process binary data using standard patterns offered by the JDK, in a clean and efficient way.]]></summary></entry><entry><title type="html">One Giant Leap: 95% Less Sampling Cost</title><link href="https://inside.java/2026/01/14/user-cpu-time-jvm/" rel="alternate" type="text/html" title="One Giant Leap: 95% Less Sampling Cost" /><published>2026-01-14T00:00:00+00:00</published><updated>2026-01-14T00:00:00+00:00</updated><id>https://inside.java/2026/01/14/user-cpu-time-jvm</id><content type="html" xml:base="https://inside.java/2026/01/14/user-cpu-time-jvm/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;JonasNorlinder&quot;]</name></author><category term="JDK 26" /><category term="HotSpot" /><category term="Performance" /><summary type="html"><![CDATA[The public standard in Linux for reading thread CPU time is the computational equivalent of printing a spreadsheet to paper, then scanning it with a camera, only to digitize it back into a spreadsheet just to read a value. It works, but it destroys throughput. I recently integrated a patch into OpenJDK that replaces this legacy logic with direct calls. The result is a 20x speedup for thread monitoring of user CPU time. Here is the story behind the optimization and why "everything is a file" isn't the right philosophy for performance.]]></summary></entry><entry><title type="html">The Static Dynamic JVM – A Many Layered Dive #JVMLS</title><link href="https://inside.java/2026/01/11/jvmls-static-dynamic-jvm/" rel="alternate" type="text/html" title="The Static Dynamic JVM – A Many Layered Dive #JVMLS" /><published>2026-01-11T00:00:00+00:00</published><updated>2026-01-11T00:00:00+00:00</updated><id>https://inside.java/2026/01/11/JVMLS-Static-Dynamic-JVM</id><content type="html" xml:base="https://inside.java/2026/01/11/jvmls-static-dynamic-jvm/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/RCxYsdeglDA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Dive deep into the Java Virtual Machine and discover how it masterfully balances static analysis with dynamic execution. John Rose explores what makes the JVM both powerful and efficient, from theoretical computer science to real-world optimization techniques.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;JohnRose&quot;]</name></author><category term="Performance" /><summary type="html"><![CDATA[Dive deep into the Java Virtual Machine and discover how it masterfully balances static analysis with dynamic execution. John Rose explores what makes the JVM both powerful and efficient, from theoretical computer science to real-world optimization techniques.]]></summary></entry></feed>