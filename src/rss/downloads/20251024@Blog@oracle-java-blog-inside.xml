<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-10-24T09:14:25+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">NUMA-Aware Relocation in ZGC</title><link href="https://inside.java/2025/10/24/zgc-numa-aware-relocation/" rel="alternate" type="text/html" title="NUMA-Aware Relocation in ZGC" /><published>2025-10-24T00:00:00+00:00</published><updated>2025-10-24T00:00:00+00:00</updated><id>https://inside.java/2025/10/24/zgc-numa-aware-relocation</id><content type="html" xml:base="https://inside.java/2025/10/24/zgc-numa-aware-relocation/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;JoelSikstrom&quot;]</name></author><category term="GC" /><category term="JDK 26" /><summary type="html"><![CDATA[NUMA-aware relocation is a feature recently added to ZGC, one of the garbage collectors in the OpenJDK, and is set to be released in JDK 26 through the introduction of JDK-8359683. Building on the recent memory allocation overhaul, this feature further enhances NUMA support and optimization in ZGC.]]></summary></entry><entry><title type="html">Three Upcoming G1 Improvements - Inside Java Newscast #99</title><link href="https://inside.java/2025/10/23/newscast-99/" rel="alternate" type="text/html" title="Three Upcoming G1 Improvements - Inside Java Newscast #99" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-10-23T00:00:00+00:00</updated><id>https://inside.java/2025/10/23/Newscast-99</id><content type="html" xml:base="https://inside.java/2025/10/23/newscast-99/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/w9mY8c72Ouk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Java’s (almost) default garbage collector G1 is undergoing even more improvements:</em> 
<em>From the already merged JEP 522, which introduces a second card table for improved throughput, and the candidate JEP 523,</em> 
<em>which aims to make G1 the default even where Serial GC used to be, to draft proposals for automatic heap sizing for G1 and ZGC.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=w9mY8c72Ouk">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="GC" /><summary type="html"><![CDATA[Java's (almost) default garbage collector G1 is undergoing even more improvements: From the already merged JEP 522, which introduces a second card table for improved throughput, and the candidate JEP 523, which aims to make G1 the default even where Serial GC used to be, to draft proposals for automatic heap sizing for G1 and ZGC.]]></summary></entry><entry><title type="html">HTTP/3 Support in JDK 26</title><link href="https://inside.java/2025/10/22/http3-support/" rel="alternate" type="text/html" title="HTTP/3 Support in JDK 26" /><published>2025-10-22T00:00:00+00:00</published><updated>2025-10-22T00:00:00+00:00</updated><id>https://inside.java/2025/10/22/HTTP3-Support</id><content type="html" xml:base="https://inside.java/2025/10/22/http3-support/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p>One new JDK 26 feature is that <code class="language-plaintext highlighter-rouge">HttpClient</code>, which has been part of Java SE since JDK 11, now supports HTTP/3.</p>

<p>Before discussing some API details, let’s briefly review what HTTP/3 is. From an HTTP protocol perspective, it is not vastly different from HTTP/2 in terms of features. However, the major difference lies in the underlying transport protocol: whereas HTTP/2 operates over <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>, HTTP/3 uses <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>. HTTP/3 is built on top of the QUIC protocol. For more details, please refer to <a href="https://openjdk.org/jeps/517">JEP 517</a>.</p>

<p><br /></p>
<h2 id="using-the-httpclient-api">Using the HttpClient API</h2>

<p>Let’s now see how to use HTTP/3 support with the <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient API</code>. If you have never used this API before, its <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/package-summary.html">Javadoc</a> is a good place to start.</p>

<p>In summary, an application creates a <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> instance and typically maintains it for the application’s lifetime. When issuing HTTP requests, the application code then builds a <code class="language-plaintext highlighter-rouge">java.net.http.HttpRequest</code> instance and uses the <code class="language-plaintext highlighter-rouge">HttpClient.send(...)</code> method to send the request and obtain a <code class="language-plaintext highlighter-rouge">java.net.http.HttpResponse</code>. In more advanced use cases where the application does not want to wait for the response, the <code class="language-plaintext highlighter-rouge">HttpClient.sendAsync(...)</code> method can be used to send the request asynchronously. This method returns a <code class="language-plaintext highlighter-rouge">java.util.concurrent.CompletableFuture</code>, which the application can use later to obtain the related <code class="language-plaintext highlighter-rouge">HttpResponse</code>.</p>

<p><code class="language-plaintext highlighter-rouge">HttpResponse</code> provides methods to retrieve the response body, the HTTP response code, the protocol version used, etc. A typical usage example is shown below:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a HttpClient instance</span>
<span class="o">...</span>
<span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">).</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a request instance</span>

<span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span> <span class="c1">// send the request and obtain the response as a String content</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span> <span class="c1">// print the response status code and the HTTP protocol version used</span>
</code></pre></div></div>

<p>None of this is new as this API has been around since JDK 11. So, let’s now see what’s new in JDK 26 and how to enable HTTP/3 support in <code class="language-plaintext highlighter-rouge">HttpClient</code>.</p>

<p>By default, the <code class="language-plaintext highlighter-rouge">HttpClient</code> (even in JDK 26) uses HTTP/2 as the preferred HTTP version when issuing requests. You can override the default per <code class="language-plaintext highlighter-rouge">HttpClient</code>-instance behavior by setting a preferred version. For example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_1_1</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>will construct a client that uses HTTP/1.1 as the preferred version for all requests it issues.
The HTTP protocol version set at the client level can also be overridden at the <code class="language-plaintext highlighter-rouge">HttpRequest</code> level as the following example.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>In this example, the <code class="language-plaintext highlighter-rouge">HttpClient</code> will use the preferred version specified by the <code class="language-plaintext highlighter-rouge">HttpRequest</code>, i.e., HTTP/2 in this case, when issuing the request.
If the server doesn’t support HTTP/2, the internal <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation will automatically downgrade the request to the HTTP/1.1 protocol, establish an HTTP/1.1 request/response exchange with the server, and provide the application with the related HTTP/1.1 response.</p>

<p>This behavior has been present in previous <code class="language-plaintext highlighter-rouge">HttpClient</code> implementations. What is new in JDK 26 is the introduction of a new protocol version value: <code class="language-plaintext highlighter-rouge">HttpClient.Version.HTTP_3</code>.
Applications can opt in to use the HTTP/3 protocol version by either setting it as a preferred version at the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance level:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>or on specific <code class="language-plaintext highlighter-rouge">HttpRequest</code> instance:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>In either case, when <code class="language-plaintext highlighter-rouge">HTTP_3</code> is set as the preferred version, the <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation will attempt to establish a UDP-based connection (since HTTP/3 operates over UDP) to the target server.
If that UDP-based QUIC connection attempt fails, either because the server does not support HTTP/3 or if the connection does not complete in a timely manner, 
the <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation will automatically downgrade the protocol version to HTTP/2 (over TCP) and attempt to complete the request using HTTP/2. 
If the server does not support HTTP/2, the request will be further downgraded to HTTP/1.1, as before.</p>

<p>So, the application code would look similar to what we saw previously with just one change, where the preferred version is set as HTTP/3 either when building the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance or when building the <code class="language-plaintext highlighter-rouge">HttpRequest</code> instance:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a HttpClient instance with HTTP/3 as the preferred version</span>
<span class="o">...</span>
<span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a request instance</span>

<span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span> <span class="c1">// send the request and obtain the response as a String content</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> 
        <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span> <span class="c1">// print the response status code and the HTTP protocol version used</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="http-version-discovery">HTTP Version Discovery</h2>
<p>Please note that setting HTTP/3 as the preferred version does not guarantee that the request will use HTTP/3 as the protocol version.
This is why it is referred to as the “preferred” version. The <code class="language-plaintext highlighter-rouge">HttpClient</code> cannot determine in advance whether the server to which the request is sent actually supports HTTP/3.</p>

<p>Therefore for the first request, the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance will use an internal implementation specific algorithm which involves an attempt to establish a TCP based communication (HTTP/2) or a UDP based communication (HTTP/3) against that server. 
Whichever succeeds first will be used as the communication mode and thus decides which HTTP protocol version is used for that request.</p>

<p>For more information on HTTP/3 version discovery, please refer to the <a href="https://download.java.net/java/early_access/jdk26/docs/api/java.net.http/java/net/http/HttpOption.Http3DiscoveryMode.html">Http3DiscoveryMode</a> Javadoc.</p>

<p>With that background, let’s now look into a few specific cases and some code examples demonstrating the usage.</p>

<p>Let’s consider the case where the application wants to force the use of HTTP/3 - i.e. try and communicate with the server only through QUIC (i.e. over UDP) and then issue the HTTP/3 request. And if that fails, the connection should not be downgraded to HTTP/2. Applications would typically do this only when they are absolutely certain that the target server (represented by the host and port used in the request URI) supports HTTP/3 over that host/port combination.</p>

<p>For example, consider google.com as the server against which we will issue that request. Based on prior experiments, we know that google.com supports HTTP/3 at the same host/port where it supports HTTP/2 (or HTTP/1.1). Here’s what the code would look like in this case:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.net.http.HttpClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption.Http3DiscoveryMode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpClient.Version</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse.BodyHandlers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.URI</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="o">...</span>

<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                     <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span> <span class="c1">// configure HTTP/3 as the preferred version of the client</span>
                     <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                   <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
                   <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span> <span class="c1">// enforce that only HTTP/3 is used</span>
                   <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span> <span class="c1">// send the request and obtain the response as a String content</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span> <span class="c1">// print the response status code and the HTTP protocol version used</span>
</code></pre></div></div>

<p>Apart from configuring the HttpClient instance with version(<code class="language-plaintext highlighter-rouge">Version.HTTP_3</code>) as the preferred version, the other important detail in this code is the line where we configure the <code class="language-plaintext highlighter-rouge">HttpRequest</code> with:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span> <span class="c1">// enforce that only HTTP/3 is used</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">H3_DISCOVERY</code> option with a value of <code class="language-plaintext highlighter-rouge">Http3DiscoveryMode.HTTP_3_URI_ONLY</code> instructs the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance that this request must only use HTTP/3, and if it’s not possible, then the request should fail (with an exception).</p>

<p>At this point, we know for certain (and even demonstrated) that requests to www.google.com support HTTP/3, so the <code class="language-plaintext highlighter-rouge">HttpRequest</code> can enforce the use of HTTP/3 as shown below.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.net.http.HttpClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption.Http3DiscoveryMode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpClient.Version</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse.BodyHandlers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.URI</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Http3Usage</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">printRespHeaders</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"--print-response-headers"</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                         <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
                                         <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

            <span class="kd">final</span> <span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                       <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
                                       <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span>
                                       <span class="o">.</span><span class="na">build</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"issuing first request: "</span> <span class="o">+</span> <span class="n">req</span><span class="o">);</span>

            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstResp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"received response, status code: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> 
                    <span class="s">" HTTP protocol version used: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">printRespHeaders</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"response headers: "</span><span class="o">);</span>
                <span class="n">firstResp</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">().</span><span class="na">entrySet</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>When you use JDK 26 early access build and run this as:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">java Http3Usage.java
</span></code></pre></div></div>

<p>you should see the following output:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">issuing first request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_3
</span></code></pre></div></div>

<p>Notice that the response’s protocol version is HTTP_3, so it did indeed use HTTP/3 as the protocol version for that request.</p>

<p>Let’s now check what would have happened if we had not instructed the <code class="language-plaintext highlighter-rouge">HttpClient</code> to enforce the HTTP/3 usage. So, let’s remove (or comment out)  <code class="language-plaintext highlighter-rouge">.setOption(HttpOption.H3_DISCOVERY, Http3DiscoveryMode.HTTP_3_URI_ONLY)</code> from the above code and keep the rest of the code as-is.
When you do that and run that program again using <code class="language-plaintext highlighter-rouge">java Http3Usage.java</code> you should see the following output:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">issuing first request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_2
</span></code></pre></div></div>

<p>Notice the difference in the response’s protocol version: even though HTTP/3 was set as the preferred version, the request/response exchange used HTTP/2. As mentioned earlier, this is expected behavior because the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance cannot guarantee that the server at the given host and port supports the “preferred” HTTP/3 version. Therefore, the <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation used used an internal algorithm which ended up establishing a TCP based connection first and thus using it to issue the HTTP/2 request.</p>

<p>Taking this example a step further, some of you might wonder whether, over time, the <code class="language-plaintext highlighter-rouge">HttpClient</code> can learn that a server at a particular host and port supports HTTP/3.</p>

<p>The answer is yes, there are several mechanisms for this. In fact, the “HTTP Alternative Services” standard (<a href="https://datatracker.ietf.org/doc/html/rfc7838">RFC 7838 </a>) defines one such approach.  HTTP Alternative Services (referred to as “Alt-Services” from now on) is a standard mechanism that allows servers to advertise alternative services they support. The RFC outlines several methods for advertising alternative services. One common approach is for the server to include an HTTP response header named “alt-svc” in response to some HTTP requests. The response header value should contain details about the Alt-Services the server supports and the host/port combination where each is supported.</p>

<p>For example, an “alt-svc” header of the following form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alt-svc=h3=":443"
</code></pre></div></div>

<p>indicates that the server on the host, which was used for the HTTP request, at port 443 supports HTTP/3 protocol (h3 represents an ALPN for HTTP/3 support).
When such a response header is advertised by the server, the <code class="language-plaintext highlighter-rouge">HttpClient</code> recognizes this as a standard header and makes note of this detail.
So, the next time a request is issued to the same server and port, <code class="language-plaintext highlighter-rouge">HttpClient</code> will check its internal registry to determine if an “h3” Alt-Service was previously advertised for that server. If so, it will attempt to establish the HTTP/3 connection using the alternate host and port.</p>

<p>Let’s see this behavior in action. As before, we’ll configure the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance with HTTP/3 as the preferred version, but this time we will not enforce HTTP/3 on the <code class="language-plaintext highlighter-rouge">HttpRequest</code>. We will then send 2 requests to the same Google URI using the same <code class="language-plaintext highlighter-rouge">HttpClient</code> instance and observe how it behaves.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.net.http.HttpClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption.Http3DiscoveryMode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpClient.Version</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse.BodyHandlers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.URI</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Http3Usage</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">printRespHeaders</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"--print-response-headers"</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                         <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
                                         <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

            <span class="kd">final</span> <span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                       <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
                                       <span class="o">.</span><span class="na">build</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"issuing first request: "</span> <span class="o">+</span> <span class="n">req</span><span class="o">);</span>

            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstResp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"received response, status code: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> 
                    <span class="s">" HTTP protocol version used: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">printRespHeaders</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"response headers: "</span><span class="o">);</span>
                <span class="n">firstResp</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">().</span><span class="na">entrySet</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"issuing second request: "</span> <span class="o">+</span> <span class="n">req</span><span class="o">);</span>

            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">secondResp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"received response, status code: "</span> <span class="o">+</span> <span class="n">secondResp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> 
                    <span class="o">+</span> <span class="s">" HTTP protocol version used: "</span> <span class="o">+</span> <span class="n">secondResp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">printRespHeaders</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"response headers: "</span><span class="o">);</span>
                <span class="n">secondResp</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">().</span><span class="na">entrySet</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s run it again with a JDK 26 EA build.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">java Http3Usage.java
</span></code></pre></div></div>

<p>This command should output the following:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">issuing first request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_2
issuing second request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_3
</span></code></pre></div></div>

<p>Notice that the first request used HTTP/2, and the second request against the same request URI, using the same <code class="language-plaintext highlighter-rouge">HttpClient</code> instance, used the preferred HTTP/3 version. That demonstrates that the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance can determine whether a server at a particular host/port supports HTTP/3 and then use that knowledge to issue HTTP/3 requests against that server, if the application prefers that protocol version.</p>

<p>Earlier, we discussed how servers advertise Alt-Services through response headers. Since our code has access to the <code class="language-plaintext highlighter-rouge">HttpResponse</code>, let’s check whether www.google.com actually advertised the “h3” Alt-Service in its response headers.</p>

<p>The code above will output response headers when it is launched with the <code class="language-plaintext highlighter-rouge">--print-response-headers</code> program argument.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">java Http3Usage.java --print-response-headers
</span></code></pre></div></div>

<p>You can see that the first request/response exchange ended up using HTTP/2, while the second request/response exchange used HTTP/3.
You will see many more lines in the output, as all the response headers from the <code class="language-plaintext highlighter-rouge">HttpResponse</code> are printed. Among these lines, if you search for “alt-svc,” you should find:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alt-svc=[h3=":443"; ma=2592000,h3-29=":443"; ma=2592000]
</code></pre></div></div>

<p>So www.google.com responded to the request and included this additional response header advertising the Alt-Service representing HTTP/3 support.</p>

<p>There are more ways the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance can discover HTTP/3 support, but those are beyond the scope of this article.</p>

<p><br /></p>
<h2 id="conclusion">Conclusion</h2>

<p>Support for HTTP/3 in Java’s <code class="language-plaintext highlighter-rouge">HttpClient</code> has been integrated into the mainline JDK repository and is available in the <a href="https://jdk.java.net/26/">JDK 26 early access builds</a>.</p>

<p>Although the API enhancement appears trivial from a usage perspective (by design), supporting QUIC and subsequently HTTP/3 on top of QUIC represents the result of several years of development effort within the JDK.</p>

<p>New tests have been added, and extensive manual testing has been conducted. However, this implementation is still new and has not seen much usage outside of the JDK development team. If the HTTP/3 support in JDK’s <code class="language-plaintext highlighter-rouge">HttpClient</code> is of interest to you, it will be very valuable if you run your applications/experiments using an <a href="https://jdk.java.net/26/">early access build of JDK 26</a> and provide any feedback/bug reports on the <a href="https://mail.openjdk.org/mailman/listinfo/net-dev">net-dev</a> OpenJDK mailing list.</p>

<p><br />~<br /></p>

<p><i>This article was originally published <a href="https://jaitechwriteups.blogspot.com/2025/10/http3-support-now-available-in-java-httpclient.html">here</a>.</i></p>]]></content><author><name>[&quot;JaikiranPai&quot;]</name></author><category term="JDK 26" /><category term="Networking" /><summary type="html"><![CDATA[One new JDK 26 feature is that `HttpClient`, which has been part of Java SE since JDK 11, now supports HTTP/3...]]></summary></entry><entry><title type="html">Assembling Project Leyden #JVMLS</title><link href="https://inside.java/2025/10/21/jvmls-assembling-project-leyden/" rel="alternate" type="text/html" title="Assembling Project Leyden #JVMLS" /><published>2025-10-21T00:00:00+00:00</published><updated>2025-10-21T00:00:00+00:00</updated><id>https://inside.java/2025/10/21/JVMLS-Assembling-Project-Leyden</id><content type="html" xml:base="https://inside.java/2025/10/21/jvmls-assembling-project-leyden/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/fiBNDT9r_4I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Two years ago John Rose stood here at JVMLS and unveiled the Project Leyden prototype efforts the team had been developing.</em> 
<em>Since then, Leyden has delivered JEPs in both JDK 24 and JDK 25.</em> 
<em>These early building blocks provide a foundation to continue assembling new AOT features.</em> 
<em>And speaking of assembly, let’s deep dive into how and when the AOTCache gets created.</em> 
<em>We’ll also touch on what’s next in the Leyden pipeline and look at some of the areas of future exploration as well as discuss some of the surprising learnings from the team along the way.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;DanHeidinga&quot;]</name></author><category term="Leyden" /><category term="Performance" /><summary type="html"><![CDATA[Two years ago John Rose stood here at JVMLS and unveiled the Project Leyden prototype efforts the team had been developing. Since then, Leyden has delivered JEPs in both JDK 24 and JDK 25. These early building blocks provide a foundation to continue assembling new AOT features. And speaking of assembly, let's deep dive into how and when the AOTCache gets created. We'll also touch on what's next in the Leyden pipeline and look at some of the areas of future exploration as well as discuss some of the surprising learnings from the team along the way.]]></summary></entry><entry><title type="html">Performance Improvements in JDK 25</title><link href="https://inside.java/2025/10/20/jdk-25-performance-improvements/" rel="alternate" type="text/html" title="Performance Improvements in JDK 25" /><published>2025-10-20T00:00:00+00:00</published><updated>2025-10-20T00:00:00+00:00</updated><id>https://inside.java/2025/10/20/JDK-25-Performance-Improvements</id><content type="html" xml:base="https://inside.java/2025/10/20/jdk-25-performance-improvements/"><![CDATA[<p>In this article, we’ll take a walk through some of the many notable 
performance improvements and features in JDK 25. This is by no means exhaustive: JDK 25 comes with more than 3.200 issues fixed, 
of which almost a thousand were enhancements. About a hundred of these have been explicitly labeled as performance-related. 
We group the improvements into JDK Libraries, Garbage Collectors, Compiler, and Runtime, and list improvements in no particular order.</p>

<h2 id="enhancements-in-jdk-libraries">Enhancements in JDK Libraries</h2>

<h3 id="jep-506-scoped-values"><a href="https://openjdk.org/jeps/506">JEP 506</a>: Scoped Values</h3>

<p>The scoped values API was added as a preview feature in JDK 21 and has 
now been finalized in JDK 25.</p>

<p>Scoped values provide a novel mean to 
pass implicit parameters to any method transitively called via a 
<code class="language-plaintext highlighter-rouge">ScopedValue</code>. This may be used to improve performance and flexibility in 
applications that use <code class="language-plaintext highlighter-rouge">ThreadLocal</code> to similar effects today, as it allows robust 
and performant sharing of data across a large number of threads.
Instead of duplicating state per thread in an error-prone way, the new mechanism 
allows shared access across any number of threads. This scales better because it has less memory overhead 
(no per-thread copies) and lower synchronization cost. ScopedValues can be
especially beneficial when used in conjunction with virtual threads 
and structured concurrency.</p>

<p>Structured concurrency was first previewed in JDK 21 and is still a preview API in
JDK 25 (see <a href="https://openjdk.org/jeps/505">JEP 505</a>). Among the updates for JDK 25 is that the API 
now neatly handles scoped values such that child tasks inherit scoped values:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ScopedValue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">NAME</span> <span class="o">=</span> <span class="nc">ScopedValue</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

    <span class="nc">ScopedValue</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="no">NAME</span><span class="o">,</span> <span class="s">"duke"</span><span class="o">).</span><span class="na">run</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">open</span><span class="o">())</span> <span class="o">{</span>

            <span class="c1">// each child task can retrieve "duke" from NAME</span>
            <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">childTask1</span><span class="o">());</span>
            <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">childTask2</span><span class="o">());</span>
            <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">childTask3</span><span class="o">());</span>

            <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
             <span class="o">..</span>
        <span class="o">}</span>
    <span class="o">});</span>
</code></pre></div></div>

<p>Nicolai Parlog recently covered this feature and much more in his talk at Devoxx Belgium 2025, <a href="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/">Structured Concurrency in Action</a></p>

<h3 id="jdk-8354300-mark-stringhash-field-stable"><a href="https://bugs.openjdk.org/browse/JDK-8354300">JDK-8354300</a> Mark String.hash field @Stable</h3>

<p>In JDK 25, <code class="language-plaintext highlighter-rouge">String</code> <a href="https://github.com/openjdk/jdk/pull/24625">was improved</a> to make the <code class="language-plaintext highlighter-rouge">String::hashCode</code> function
<a href="https://en.wikipedia.org/wiki/Constant_folding">constant foldable</a>. This might lead to significant performance improvements in some common scenarios,
such as using <code class="language-plaintext highlighter-rouge">String</code> constants as keys in a constant, unmodifiable <code class="language-plaintext highlighter-rouge">Map</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Foo</span><span class="o">&gt;</span> <span class="no">MAP</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"constant"</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="o">...);</span>
        
<span class="no">MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"constant"</span><span class="o">).</span><span class="na">foo</span><span class="o">();</span>
</code></pre></div></div>

<p>In this scenario, constant folding means the JIT can skip the map lookup entirely, replacing the lookup with a direct call to <code class="language-plaintext highlighter-rouge">value.foo()</code> or better. In a targeted microbenchmark such as <a href="https://github.com/openjdk/jdk/blob/072b827/test/micro/org/openjdk/bench/java/lang/StringHashCodeStatic.java#L67">StringHashCodeStatic.nonZero</a>
this brings us about an <strong>8x speed-up</strong>.</p>

<p>In <a href="https://inside.java/2025/05/01/strings-just-got-faster/">this article</a> you can 
read more about the benchmark and additional implementation details. In short, 
the hash code for the string is now stored in a field that is marked with the 
internal <code class="language-plaintext highlighter-rouge">@Stable</code> annotation. This allows the JIT compiler to trust and constant 
fold the value if it is no longer the default zero value. While <code class="language-plaintext highlighter-rouge">@Stable</code> annotation is JDK-internal,
a general-purpose approach is on the way through the next feature of our article.</p>

<h3 id="jep-502-stable-values-preview"><a href="https://openjdk.org/jeps/502">JEP 502</a>: Stable Values (Preview)</h3>

<p>Using the <code class="language-plaintext highlighter-rouge">StableValue</code> API (previewed in JDK 25), anyone can declare a lazy constant that is implicitly
<em>stable</em>, which means the JVM will treat it as a constant once a value has been lazily
computed. Computation is done using a computing function provided  at declaration time, and the constant is
cached in a <code class="language-plaintext highlighter-rouge">Supplier</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Logger</span><span class="o">&gt;</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">StableValue</span><span class="o">.</span><span class="na">supplier</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="nc">OrderController</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>

    <span class="kt">void</span> <span class="nf">submitOrder</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order started"</span><span class="o">);</span>
        <span class="o">...</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order submitted"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In the example above, the field <code class="language-plaintext highlighter-rouge">logger</code> is of type <code class="language-plaintext highlighter-rouge">Supplier&lt;Logger&gt;</code>, but, 
at construction, no constant is yet initialized. 
When we invoke <code class="language-plaintext highlighter-rouge">logger.get()</code> the first time, the underlying computing 
function, <code class="language-plaintext highlighter-rouge">() -&gt; Logger.create(OrderController.class)</code>, is evaluated, 
causing the constant to be initialized.</p>

<p>Once the constant is initialized, the JIT compiler can trust that the 
constant will never change and is thus free to omit further 
reads of the constant, i.e., constant folding. This technique can 
provide significant performance improvements, including eliminating 
code. Effectively, this has the same impact as the <code class="language-plaintext highlighter-rouge">@Stable</code> annotation
available in internal JDK code, but made available to library and application 
developers in a safe and enforced manner.</p>

<p>It’s prudent to note that preview APIs are subject to change. At the time of 
writing <code class="language-plaintext highlighter-rouge">StableValue</code> is set to be renamed to <code class="language-plaintext highlighter-rouge">LazyConstant</code> in JDK 26.</p>

<h3 id="jdk-8345687-improve-the-implementation-of-segmentfactoriesallocatesegment"><a href="https://bugs.openjdk.org/browse/JDK-8345687">JDK-8345687</a> Improve the Implementation of SegmentFactories::allocateSegment</h3>

<p>This Panama Foreign Function and Memory (FFM) enhancement speeds up allocating
native memory segments by up to 2x. This is achieved by explicitly aligning
memory, avoiding unnecessary merges and object allocation, improving zeroing, 
and a few other tricks.
Better handling of shared memory in the <code class="language-plaintext highlighter-rouge">java.lang.foreign</code> component means 
better performance when interoperating with native libraries. FFM was finalized 
in JDK 22 with the delivery of <a href="https://openjdk.org/jeps/454">JEP 454</a> and brings a promise of simplifying 
native integration while outperforming JNI. Per has blogged about this in more 
depth <a href="https://minborgsjavapot.blogspot.com/2023/08/java-22-panama-ffm-provides-massive.html">here</a>.</p>

<h3 id="jdk-8354674-aarch64-intrinsify-unsafesetmemory"><a href="https://bugs.openjdk.org/browse/JDK-8354674">JDK-8354674</a> AArch64: Intrinsify Unsafe::setMemory</h3>

<p>This enhancement added an intrinsic to speed up <code class="language-plaintext highlighter-rouge">Unsafe::setMemory</code>, which is an API commonly used in I/O, 
desktop and Foreign Function and Memory(FFM) APIs. The supplied microbenchmark showcases a ~2.5x speed-up when writing chunks of 
data using <code class="language-plaintext highlighter-rouge">java.lang.foreign.MemorySegment::fill</code>.</p>

<h3 id="added-intrinsics-for-ml-kem-and-ml-dsa-api">Added Intrinsics for ML-KEM and ML-DSA API</h3>

<p>JDK 24 added Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism, or ML-KEM (<a href="https://openjdk.org/jeps/496">JEP 496</a>),
and Quantum-Resistant Module-Lattice-Based Digital Signature Algorithm, or ML-DSA (<a href="https://openjdk.org/jeps/497">JEP 497</a>).</p>

<p>In JDK 25, the performance of many of these new APIs has doubled on AArch64 and Intel AVX-512 platforms thanks to specialized intrinsics. This puts the OpenJDK roughly on par with OpenSSL for many of these security operations on modern hardware.</p>

<ul>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8349721">JDK-8349721</a> Add aarch64 intrinsics for ML-KEM</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8351412">JDK-8351412</a> Add AVX-512 intrinsics for ML-KEM</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8348561">JDK-8348561</a> Add aarch64 intrinsics for ML-DSA</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8351034">JDK-8351034</a> Add AVX-512 intrinsics for ML-DSA</li>
</ul>

<h3 id="jdk-8350748-vectorapi-method-checkmaskfromindexsize-should-be-force-inlined"><a href="https://bugs.openjdk.org/browse/JDK-8350748">JDK-8350748</a> VectorAPI: Method “checkMaskFromIndexSize” Should Be Force Inlined</h3>

<p>In low-level libraries, fine-tuning how the JIT inlines can help ensure that some critical optimizations occur as expected. 
This enhancement addresses such an issue in the Vector API by forcing inlining to happen at a critical place, leading to a
<strong>14x speed-up</strong> on targeted benchmarks.</p>

<h3 id="jdk-8350493-improve-performance-of-delayed-task-handling"><a href="https://bugs.openjdk.org/browse/JDK-8350493">JDK-8350493</a> Improve Performance of Delayed Task Handling</h3>

<p>The <code class="language-plaintext highlighter-rouge">java.util.concurrent.ForkJoinPool</code> was updated to implement <code class="language-plaintext highlighter-rouge">ScheduledExecutorService</code> to better deal with delayed tasks.</p>

<p>This major overhaul removes some locking-related bottlenecks and notably improves the performance of canceling delayed tasks (such 
as timeout handlers). Added some convenient methods such as <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#submitWithTimeout(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit,java.util.function.Consumer)">submitWithTimeout</a> too!</p>

<h3 id="other-jdk-library-performance-enhancements-and-bug-fixes">Other JDK Library Performance Enhancements and Bug Fixes</h3>

<ul>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8356709">JDK-8356709</a> Avoid redundant <code class="language-plaintext highlighter-rouge">String</code> formatting in <code class="language-plaintext highlighter-rouge">BigDecimal.valueOf(double)</code></p>

    <p>Gives a <strong>6-9x speed-up</strong> of <code class="language-plaintext highlighter-rouge">BigDecimal.valueOf</code> for typical inputs.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8353686">JDK-8353686</a> Optimize <code class="language-plaintext highlighter-rouge">Math.cbrt</code> for x86 64 bit platforms</p>

    <p>Together with a follow-up fix (<a href="https://bugs.openjdk.org/browse/JDK-8358179">JDK-8358179</a>) this x86 enhancement brings a <strong>3x speed-up</strong> to <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#cbrt(double)">Math.cbrt</a> (cubic root).
A similar change was attempted on AArch64 but failed to show any benefit there.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8357690">JDK-8357690</a> Add <code class="language-plaintext highlighter-rouge">@Stable</code> and <code class="language-plaintext highlighter-rouge">final</code> to <code class="language-plaintext highlighter-rouge">java.lang.CharacterDataLatin1</code> and other <code class="language-plaintext highlighter-rouge">CharacterData</code> classes</p>

    <p>While currently unclear if this has any effects in the wild this could conceivably make some code constant foldable.</p>
  </li>
</ul>

<h2 id="garbage-collection-improvements">Garbage Collection Improvements</h2>

<h3 id="jep-521-generational-shenandoah"><a href="https://openjdk.org/jeps/521">JEP 521</a> Generational Shenandoah</h3>

<p>The generational mode of the Shenandoah garbage collector, introduced in JDK 24, has transitioned to a product feature in JDK 25.</p>

<h3 id="jdk-8350441-zgc-overhaul-page-allocation"><a href="https://bugs.openjdk.org/browse/JDK-8350441">JDK-8350441</a> ZGC: Overhaul Page Allocation</h3>

<p>This major ZGC enhancement replaces the Page Cache in ZGC with a Mapped Cache, which improves how ZGC manages unused
allocated memory. Implemented as a self-balancing binary search tree of contiguous memory ranges, the Mapped Cache
merges memory ranges on insertion. Among other things, this reduces heap memory fragmentation.
Another consequence of the overhaul is that ZGC no longer uses multi-mapped memory, which means that reported RSS usage 
will no longer look artificially inflated.</p>

<p>Joel Sikström has authored a comprehensive deep-dive about how ZGC allocates and manages memory with this large overhaul in focus here: <a href="https://joelsiks.com/posts/zgc-heap-memory-allocation/">How ZGC allocates memory for the Java heap</a>.</p>

<h3 id="jdk-8343782-g1-use-one-g1cardset-instance-for-multiple-old-gen-regions"><a href="https://bugs.openjdk.org/browse/JDK-8343782">JDK-8343782</a> G1: Use One G1CardSet Instance for Multiple Old Gen Regions</h3>

<p>This one allows G1 to merge any old generation region’s <a href="https://docs.oracle.com/en/java/javase/24/gctuning/garbage-first-g1-garbage-collector1.html#GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F">remembered set</a> 
with others, unlocking memory savings. On one GC stress test referenced in the <a href="https://git.openjdk.org/jdk/pull/22015">PR</a>, this reduces the peak memory used by 
remembered sets from 2Gb to 0.75Gb on a JVM with a 64GB heap. Or roughly 2% of the process total:</p>

<p><img alt="Plot of memory reserved by G1 remembered sets before and after the change, showing a roughly 60% decrease at peak." src="/images/performance/g1-groupcardsets.png" size="70%" /></p>

<h3 id="jdk-8351405-g1-collection-set-early-pruning-causes-suboptimal-region-selection"><a href="https://bugs.openjdk.org/browse/JDK-8351405">JDK-8351405</a> G1: Collection Set Early Pruning Causes Suboptimal Region Selection</h3>

<p>G1 will now better estimate the cost of collecting regions during Mixed GCs and skip those that would significantly impact pause times. The result is reduced pause time spikes, particularly toward the end of a Mixed GC cycle, improving overall application performance.
Thomas Schatzl has written in-depth about these and other GC changes on his blog: JDK 25 G1/Parallel/Serial GC changes.</p>

<h3 id="jdk-8357443-zgc-optimize-old-page-iteration-in-remap-remembered-phase"><a href="https://bugs.openjdk.org/browse/JDK-8357443">JDK-8357443</a> ZGC: Optimize Old Page Iteration in Remap Remembered Phase</h3>

<p>This enhancement leverages a pre-existing optimization to find all old pages without scanning the entire page table, 
speeding up significant collections when many pages don’t need to be considered for collection.</p>

<p>While likely a modest improvement on typical usage, this can lead to significant speed-ups in some corner cases, 
such as when you manually trigger significant collections (e.g., using <code class="language-plaintext highlighter-rouge">System.gc()</code>) on large but relatively empty heaps. 
The <a href="https://github.com/openjdk/jdk/pull/25345">PR</a> shows speed-ups of up to <strong>20x</strong> on a 4GB heap, and up to <strong>900x</strong> 
on a 16TB heap for the worst-case setup.</p>

<h2 id="compiler-improvements">Compiler Improvements</h2>

<h3 id="jdk-8343685-c2-superword-refactor-vpointer-with-mempointer"><a href="https://bugs.openjdk.org/browse/JDK-8343685">JDK-8343685</a> C2 SuperWord: Refactor VPointer with MemPointer</h3>

<p>Part of a larger effort to improve auto-vectorization in C2. This is a technique where plain Java code is transformed 
by the JIT to use SIMD instructions, which can allow for large speed-ups.</p>

<p>This enhancement makes more patterns eligible for such optimization to great effect. 
In a <a href="https://www.youtube.com/watch?v=UVsevEdYSwI">recent talk</a> at JVMLS, Emanuel Peter casually mentions how 
this snippet of code runs <strong>33 times faster</strong> after this enhancement:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">a</span><span class="o">.</span><span class="na">byteSize</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">byte</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">ValueLayout</span><span class="o">.</span><span class="na">JAVA_BYTE</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">invarL</span><span class="o">);</span>
    <span class="n">a</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="nc">ValueLayout</span><span class="o">.</span><span class="na">JAVA_BYTE</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">invarL</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Emanuel has blogged extensively on auto-vectorization in the C2 compiler and 
<a href="https://eme64.github.io/blog/2023/02/23/SuperWord-Introduction.html">this introduction</a> might be a good starting point 
for a deep dive.</p>

<h3 id="jdk-8307513-c2-intrinsify-mathmaxlonglong-and-mathminlonglong"><a href="https://bugs.openjdk.org/browse/JDK-8307513">JDK-8307513</a> C2: Intrinsify <code class="language-plaintext highlighter-rouge">Math.max(long,long)</code> and <code class="language-plaintext highlighter-rouge">Math.min(long,long)</code></h3>

<p>This is another auto-vectorization improvement referenced in Emanuel’s Peter JVMLS talk. By giving some special treatment 
to <code class="language-plaintext highlighter-rouge">Math.max</code> and <code class="language-plaintext highlighter-rouge">Math.min</code>, those operations can be considered for auto-vectorization by C2.</p>

<p>In a clipping variant (which combines both <code class="language-plaintext highlighter-rouge">Math.min</code> and <code class="language-plaintext highlighter-rouge">Math.max</code>) in the provided <a href="https://github.com/openjdk/jdk/blob/4e51a8c9ad4e5345d05cf32ce1e82b7158f80e93/test/micro/org/openjdk/bench/java/lang/MinMaxVector.java">MinMaxVector</a> 
microbenchmark, we see <strong>3-5x</strong> speed-ups on a range of platforms:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Benchmark</span>
<span class="kd">public</span> <span class="kt">long</span><span class="o">[]</span> <span class="nf">longClippingRange</span><span class="o">(</span><span class="nc">RangeState</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">.</span><span class="na">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">state</span><span class="o">.</span><span class="na">resultLongs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">longs</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">state</span><span class="o">.</span><span class="na">lowestLong</span><span class="o">),</span> <span class="n">state</span><span class="o">.</span><span class="na">highestLong</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">resultLongs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Improving auto-vectorization allows clearly written, plain Java code to take advantage 
of SIMD capabilities on modern CPUs.</p>

<h3 id="jdk-8347405-mergestores-with-reverse-bytes-order-value"><a href="https://bugs.openjdk.org/browse/JDK-8347405">JDK-8347405</a> MergeStores with Reverse Bytes Order Value</h3>

<p>In JDK 23, C2 was enhanced with a merge store optimization, which allows merging byte-by-byte stores into wider primitives in an efficient way. In JDK 25, this is further enhanced to enable such merges to happen also when bytes are stored in the reversed order. For example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">patchInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">elems</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">elems</span><span class="o">;</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="o">);</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="o">);</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Focused microbenchmarks have seen up to a <em>4x</em> speed-up on such code.</p>

<p>On typical <a href="https://en.wikipedia.org/wiki/Endianness">little-endian systems</a>, such as Intel x64 or Aarch64, this means Java may emit data in network order (big-endian) at significantly greater speed than before.</p>

<h3 id="jdk-8346664-c2-optimize-mask-check-with-constant-offset"><a href="https://bugs.openjdk.org/browse/JDK-8346664">JDK-8346664</a> C2: Optimize Mask Check with Constant Offset</h3>

<p>This enhancement improves mask checks such as <code class="language-plaintext highlighter-rouge">((index + offset) &amp; mask) == 0</code> when <code class="language-plaintext highlighter-rouge">offset</code> is constant. This enables more constant folding of some relatively common low-level expressions.
While this was found and implemented to help specific Panama workloads, the optimization is generic and low-level.</p>

<p>Here’s a microbenchmark adapted from the one in the <a href="https://github.com/openjdk/jdk/pull/22856#issuecomment-2601757857">PR</a> to avoid use of <code class="language-plaintext highlighter-rouge">java.lang.foreign</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">4711</span> <span class="o">&lt;&lt;</span> <span class="mi">3L</span><span class="o">;</span>

    <span class="nd">@Benchmark</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">itsOver9000</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(((</span><span class="n">address</span> <span class="o">+</span> <span class="o">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3L</span><span class="o">))</span> <span class="o">&amp;</span> <span class="mi">7L</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>Since these expressions can now properly constant fold, the JIT goes above and beyond. It sees that the check will always be true and ends up optimizing away the entire loop. 
Result: <strong>10,000x faster</strong>.</p>

<p>The fastest code will always be the code we don’t have to run at all!</p>

<h3 id="other-compiler-performance-enhancements-and-bug-fixes">Other Compiler Performance Enhancements and Bug Fixes</h3>

<ul>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8353359">JDK-8353359</a> C2: <code class="language-plaintext highlighter-rouge">Or(I|L)Node::Ideal</code> is missing <code class="language-plaintext highlighter-rouge">AddNode::Ideal</code> call</p>

    <p>This fixes a regression introduced in JDK 21 where expressions such as <code class="language-plaintext highlighter-rouge">(a | 3) | 6</code> no longer constant folded as expected.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8353041">JDK-8353041</a> NeverBranchNode causes incorrect block frequency calculation</p>

    <p>Fixes an issue where performance of infinite loops could be adversely affected.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8317976">JDK-8317976</a> Optimize SIMD sort for AMD Zen 4</p>

    <p>Makes sure AMD Zen 4 and later processors use appropriate optimized array sort routines.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8351414">JDK-8351414</a> C2: MergeStores must happen after RangeCheck smearing</p>

    <p>Improves some cases where the aforementioned merge store optimization interacted poorly with another optimization by separating the optimization to a separate pass.</p>
  </li>
</ul>

<h2 id="runtime-improvements">Runtime Improvements</h2>

<h3 id="jep-515-ahead-of-time-method-profiling"><a href="https://openjdk.org/jeps/515">JEP 515</a> Ahead-of-Time Method Profiling</h3>

<p><a href="https://openjdk.org/projects/leyden/">Project Leyden</a> aims to improve startup and warmup of Java applications while imposing as few limitations as possible. 
This is achieved by recording what an application is doing during a training run and saving that to an 
Ahead-of-Time cache for subsequent runs.</p>

<p>The AOT cache, introduced via <a href="https://openjdk.org/jeps/483">JEP 483</a> in JDK 24, was extended in JDK 25 by 
<a href="https://openjdk.org/jeps/515">JEP 515</a> to be able to collect method profiles during training runs. This enables the 
JVM to generate optimized native code immediately upon application startup, rather than having to wait for profiles to 
be collected. Hence, the warmup time is improved.</p>

<p>Some example programs start up 15-25% faster with this feature, compared to JDK 24 running a similarly trained application.</p>

<p>With this enhancement and <a href="https://openjdk.org/jeps/514">JEP 514: Ahead-of-Time Command-Line Ergonomics</a> delivered in JDK 25, 
Project Leyden is coming along nicely.</p>

<h3 id="jep-519-compact-object-headers"><a href="https://openjdk.org/jeps/519">JEP 519</a>: Compact Object Headers</h3>

<p>Compact object headers were added as an experimental feature in JDK 24 and have now been promoted to a product feature.</p>

<p>When enabled with <code class="language-plaintext highlighter-rouge">-XX:+UseCompactObjectHeaders</code>, all objects on the heap shrink by 4 bytes, typically. This adds up to 
substantial heap savings, and many benchmarks and real-world applications see significant speed-ups as a result due to 
improved cache locality and reduced GC activity.</p>

<p>Users are strongly encouraged to try this out and provide feedback. We are considering turning it on by default in a
future release.</p>

<h3 id="various-interpreter-improvements">Various Interpreter Improvements</h3>

<ul>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8356946">JDK-8356946</a> x86: Optimize Interpreter Profile Updates</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8357223">JDK-8357223</a> AAarch64: Optimize Interpreter Profile Updates</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8357434">JDK-8357434</a> x86: Simplify Interpreter::profile_taken_branch</li>
</ul>

<p>Together, these improvements significantly enhance how the interpreter updates profile counters. During startup and warmup, 
the bytecode interpreter profiles which methods and branches are used, which informs the JVM on what to compile and how. 
The act of updating these counters can be noticeable during application startup and warmup.</p>

<p>In isolation, such optimizations are often lost in the noise, but over a release, they can and do add up. 
Going from JDK 24 to 25, the time to run a simple “Hello World!” has dropped from ~28.7ms to ~25.5ms in JDK 25. A neat 12% speed-up right off the bat.</p>

<p>While users of Project Leyden may unlock greater wins at scale, we think it’s great to see measurable improvements for free.</p>

<h3 id="other-runtime-performance-enhancements-and-bug-fixes">Other Runtime Performance Enhancements and Bug Fixes</h3>

<ul>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8355646">JDK-8355646</a>: Optimize ObjectMonitor::exit</p>

    <p>This synchronization improvement allows us to immediately unpark waiting threads without releasing and reacquiring a
lock. This reduces latency on some lightly contended locks.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8348402">JDK-8348402</a> PerfDataManager stalls shutdown for 1ms</p>

    <p>Getting rid of a small sleep during JVM shutdown, for one. Good for all the short-running command line tools, build systems, etc.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8241678">JDK-8241678</a> Remove PerfData sampling via StatSampler</p>

    <p>A nice cleanup removing a periodically running task</p>
  </li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8353273">JDK-8353273</a> Reduce number of oop map entries in instances</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8354560">JDK-8354560</a> Exponentially delay subsequent native thread creation in case of EAGAIN</li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8352075">JDK-8352075</a> Perf regression accessing fields</p>

    <p>Fixes an issue from JDK 21 which could cause significant interpreter slowdowns on classes with many fields.</p>
  </li>
</ul>

<h2 id="thats-all-folks">That’s All, Folks!</h2>

<p>JDK 25 has been generally available for a while now, so don’t hesitate to try it out. If you would like to learn how JDK 25 compares to JDK 21 in terms of performance, we also recommend the session <a href="https://inside.java/2025/10/18/devoxxbelgium-java-performance-update/">From JDK 21 to JDK 25 - Java Performance Update 2025</a> presented at Devoxx Belgium 2025.</p>

<p>As you test and migrate your applications, measure how your application performs on JDK 25 versus your current JDK.
Did you notice anything that might have regressed? Get involved in the community and let us know! Join and raise an issue on the relevant <a href="https://mail.openjdk.org/">mailing list</a>.</p>

<p>We are already looking at a healthy set of improvements in the upcoming JDK 26 release and look forward to writing about those in some detail in spring 2026.</p>

<p>Until then… Stay on the fast path!</p>]]></content><author><name>[&quot;ClaesRedestad&quot;, &quot;Per-AkeMinborg&quot;]</name></author><category term="JDK 25" /><category term="Performance" /><summary type="html"><![CDATA[Java is constantly evolving with ever increasing performance. JDK 25 comes with significant performance improvements compared to previous versions including scoped values, improved GCs, lots of compiler improvements, and much more.]]></summary></entry><entry><title type="html">From JDK 21 to JDK 25 - Java Performance Update 2025</title><link href="https://inside.java/2025/10/18/devoxxbelgium-java-performance-update/" rel="alternate" type="text/html" title="From JDK 21 to JDK 25 - Java Performance Update 2025" /><published>2025-10-18T00:00:00+00:00</published><updated>2025-10-18T00:00:00+00:00</updated><id>https://inside.java/2025/10/18/DevoxxBelgium-Java-Performance-Update</id><content type="html" xml:base="https://inside.java/2025/10/18/devoxxbelgium-java-performance-update/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/223_7r0H6OE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>JDK 25 has just been released and is packed with performance improvements compared to JDK 21, allowing your unchanged application code to run even faster.</em></p>

<p><em>In this talk, we will take a closer look at 13 concrete performance improvements made between JDK 21 and JDK 25 involving both the standard Java libraries, the JIT compiler, and the garbage collectors.</em> 
<em>Among these improvements is the newly introduced <code class="language-plaintext highlighter-rouge">Stable Value</code> preview feature, which allows a field to share the benefits of both mutable and immutable fields simultaneously.</em> 
<em>We will learn how this new feature works, how much performance can be improved, and how your code can take advantage of it already today.</em>
<em>We will also explore some of the design considerations made, the importance of developer feedback, and how the JDK engineers evaluate performance in a world of conflicting optimization criteria and varying platform properties.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;Per-AkeMinborg&quot;]</name></author><category term="JDK 25" /><category term="Performance" /><summary type="html"><![CDATA[JDK 25 has just been released and is packed with performance improvements compared to JDK 21, allowing your unchanged application code to run even faster.In this talk, we will take a closer look at 13 concrete performance improvements made between JDK 21 and JDK 25 involving both the standard Java libraries, the JIT compiler, and the garbage collectors. Among these improvements is the newly introduced 'Stable Value' preview feature, which allows a field to share the benefits of both mutable and immutable fields simultaneously. We will learn how this new feature works, how much performance can be improved, and how your code can take advantage of it already today.We will also explore some of the design considerations made, the importance of developer feedback, and how the JDK engineers evaluate performance in a world of conflicting optimization criteria and varying platform properties.]]></summary></entry><entry><title type="html">What’s New in Java 25 in 2 Minutes - Sip of Java</title><link href="https://inside.java/2025/10/17/new-in-jdk-25-2-mins/" rel="alternate" type="text/html" title="What’s New in Java 25 in 2 Minutes - Sip of Java" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>https://inside.java/2025/10/17/new-in-jdk-25-2-mins</id><content type="html" xml:base="https://inside.java/2025/10/17/new-in-jdk-25-2-mins/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/lCNNA1erCfk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p>JDK 25 was released on September 16th, and with it came 18 JEPs (JDK Enhancement Proposals), many of them being final features. Let’s quickly review the major changes that came in JDK 25!</p>

<h2 id="new-features">New Features</h2>

<p>11 JEPs introduced or finalized new features in JDK 25.</p>

<h3 id="jep-506---scoped-values">JEP 506 - Scoped Values</h3>

<p>The second major feature from <a href="https://openjdk.org/projects/loom/">Project Loom</a>, <a href="https://openjdk.org/jeps/506">Scoped Values</a> are an immutable value that is available within a specific scope of an application. They can be useful for providing contextual information, similar to <code class="language-plaintext highlighter-rouge">ThreadLocal</code>, though aren’t a direct replacement for them.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Framework</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ScopedValue</span><span class="o">&lt;</span><span class="nc">FrameworkContext</span><span class="o">&gt;</span> <span class="no">CONTEXT</span>
                        <span class="o">=</span> <span class="nc">ScopedValue</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>    

    <span class="kt">void</span> <span class="nf">serve</span><span class="o">(</span><span class="nc">Request</span> <span class="n">request</span><span class="o">,</span> <span class="nc">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="o">=</span> <span class="n">createContext</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="n">where</span><span class="o">(</span><span class="no">CONTEXT</span><span class="o">,</span> <span class="n">context</span><span class="o">)</span>                         
                   <span class="o">.</span><span class="na">run</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Application</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">PersistedObject</span> <span class="nf">readKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="o">=</span> <span class="no">CONTEXT</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>                    
        <span class="kt">var</span> <span class="n">db</span> <span class="o">=</span> <span class="n">getDBConnection</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">db</span><span class="o">.</span><span class="na">readKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-510---key-derivation-function-api">JEP 510 - Key Derivation Function API</h3>

<p>The <a href="https://openjdk.org/jeps/510">Key Derivation Function (KDF) API</a> is a final feature in JDK 25, after previewing in JDK 24. The KDF API allows for the creation of additional keys from a secret key and other data. The sample code below demonstrates how to use the KDF API.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a KDF object for the specified algorithm</span>
<span class="no">KDF</span> <span class="n">hkdf</span> <span class="o">=</span> <span class="no">KDF</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HKDF-SHA256"</span><span class="o">);</span> 

<span class="c1">// Create an ExtractExpand parameter specification</span>
<span class="nc">AlgorithmParameterSpec</span> <span class="n">params</span> <span class="o">=</span>
    <span class="nc">HKDFParameterSpec</span><span class="o">.</span><span class="na">ofExtract</span><span class="o">()</span>
                     <span class="o">.</span><span class="na">addIKM</span><span class="o">(</span><span class="n">initialKeyMaterial</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">addSalt</span><span class="o">(</span><span class="n">salt</span><span class="o">).</span><span class="na">thenExpand</span><span class="o">(</span><span class="n">info</span><span class="o">,</span> <span class="mi">32</span><span class="o">);</span>

<span class="c1">// Derive a 32-byte AES key</span>
<span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">hkdf</span><span class="o">.</span><span class="na">deriveKey</span><span class="o">(</span><span class="s">"AES"</span><span class="o">,</span> <span class="n">params</span><span class="o">);</span>

<span class="c1">// Additional deriveKey calls can be made with the same KDF object</span>
</code></pre></div></div>

<h3 id="jep-511---module-import-declarations">JEP 511 - Module Import Declarations</h3>

<p><a href="https://openjdk.org/jeps/511">Module Import Declarations</a> allow for the importing of all the exported API of a module in a single line with <code class="language-plaintext highlighter-rouge">import module [module name]</code> like in the example above.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>

<span class="nc">String</span><span class="o">[]</span> <span class="n">fruits</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"berry"</span><span class="o">,</span> <span class="s">"citrus"</span> <span class="o">};</span>

<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span>
    <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">fruits</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> 		<span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">().</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">()));</span>
</code></pre></div></div>

<p>If you are importing multiple modules that contain the same class name, like <code class="language-plaintext highlighter-rouge">Date</code> in the above example, you can resolve the conflict by explicitly importing the class <code class="language-plaintext highlighter-rouge">java.sql.Date</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>      <span class="c1">// exports java.util, which has a public Date class</span>
<span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">;</span>       <span class="c1">// exports java.sql, which has a public Date class</span>

<span class="kn">import</span> <span class="nn">java.sql.Date</span><span class="o">;</span>         <span class="c1">// resolve the ambiguity of the simple name Date!</span>

<span class="o">...</span>
<span class="nc">Date</span> <span class="n">d</span> <span class="o">=</span> <span class="o">...</span>                  <span class="c1">// Ok!  Date is resolved to java.sql.Date</span>
<span class="o">...</span>
</code></pre></div></div>

<h3 id="jep-512---compact-source-files-and-instance-main-methods">JEP 512 - Compact Source Files and Instance Main Methods</h3>

<p>The highlight of the <a href="https://openjdk.org/projects/amber/design-notes/on-ramp">“Paving the On-Ramp”</a> feature set, <a href="https://openjdk.org/jeps/512">Compact Source Files and Instance Main Methods</a> is finalized in JDK 25. Compact source files and instance main methods simplify the requirements for writing very simple applications, including reducing “Hello World” to three lines, like in the example above. Helpful for educational purposes, and when writing “scripts” in Java.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
	<span class="no">IO</span><span class="o">.</span><span class="na">printin</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
<span class="err">｝</span>
</code></pre></div></div>

<h3 id="jep-513---fleixble-constructor-bodies">JEP 513 - Fleixble Constructor Bodies</h3>

<p><a href="https://openjdk.org/jeps/513">Flexible Constructor Bodies</a> is finalized in JDK 25. This feature enables adding statements before the call to <code class="language-plaintext highlighter-rouge">super</code> in a constructor, which can be helpful for performing data validation or setting default values.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="o">...</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Person</span><span class="o">(...,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(...);</span>
        <span class="o">...</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="n">show</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="nc">String</span> <span class="n">officeID</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Office: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">officeID</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Employee</span><span class="o">(...,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">officeID</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(...,</span> <span class="n">age</span><span class="o">);</span>        <span class="c1">// Potentially unnecessary work</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">18</span>  <span class="o">||</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">67</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(...);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">officeID</span> <span class="o">=</span> <span class="n">officeID</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-514---ahead-of-time-command-line-ergonomics">JEP 514 - Ahead-of-Time Command-Line Ergonomics</h3>

<p><a href="https://openjdk.org/jeps/514">Ahead-of-Time Command-Line Ergonomics</a> simplifies the process for creating an AOT cache by allowing it to be done in a single step. <a href="https://openjdk.org/jeps/483#Description">The two-step process</a> of recording the JVM and creating the cache is still valid and supported. With JEP 514, a user can pass the command <code class="language-plaintext highlighter-rouge">-XX:AOTCacheOutput=[cache name]</code> to have a cache created on shut down of the JVM.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Create the AOT cache
$ java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App ...

# Use the AOT cache
$ java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
</code></pre></div></div>

<h3 id="jep-515---ahead-of-time-method-profiling">JEP 515 - Ahead-of-Time Method Profiling</h3>

<p><a href="https://openjdk.org/jeps/515">Ahead-of-Time Method Profiling</a> allows method profiles to be added to an AOT cache. This improves application warmup by allowing the JIT to immediately start generating native code on application startup.</p>

<h3 id="jep-518---jfr-cooperative-sampling">JEP 518 - JFR Cooperative Sampling</h3>

<p><a href="https://openjdk.org/jeps/518">JFR Cooperative Sampling</a> improves JFR’s stability by redesigning its thread stack sampling mechanism. This is an implementation change which shouldn’t have any behavior impacts, outside of improved stability.</p>

<h3 id="jep-519---compact-object-headers">JEP 519 - Compact Object Headers</h3>

<p><a href="https://openjdk.org/jeps/519">Compact Object Headers</a> is now a final feature after being added as an experimental feature in JDK 24. Compact Object Headers reduces the minimum size an object header can be, which reduces heap sizes by 10-20% and also reduces GC pressure reducing latency.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:+UseCompactObjectHeaders ...
</code></pre></div></div>

<h3 id="jep-520---jfr-method-timing--tracing">JEP 520 - JFR Method Timing &amp; Tracing</h3>

<p><a href="https://openjdk.org/jeps/520">JFR Method Timing &amp; Tracing</a> allows JFR to be configured to time and trace methods. This works via JFR events, and can be configured via the command line like in the respective examples below demonstrating method trace and timing and their output.</p>

<h4 id="method-tracing">Method Tracing</h4>

<p>To enable method tracing, you will configure the JFR event <code class="language-plaintext highlighter-rouge">jdk.MethodTrace</code> like in the example below. You can use the <code class="language-plaintext highlighter-rouge">jfr view</code> command to review the results of the recording.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording:
jdk.MethodTrace#filter=
org.springframework.data.jpa.repository.support.SimpleJpaRepository::findAll, \
filename=recording.jfr ...

$jfr view --cell-height 30 --width 200 jdk.MethodTrace recording.jfr
                                                                                              Method Trace

Start Time Duration Event Thread         Stack Trace                                                                     Method                                                                         
---------- -------- -------------------- ------------------------------------------------------------------------------- -------------------------------------------------------------------------------
15:49:48    43.3 ms http-nio-8080-exec-1 java.lang.invoke.LambdaForm$DMH.0x000040000115c000.invokeVirtual(...)           org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Pag
                                         java.lang.invoke.LambdaForm$MH.0x00004000010a8c00.invoke(...)                   eable)                                                                         
                                         java.lang.invoke.Invokers$Holder.invokeExact_MT(Object, Object, Object, Object)                                                                                
                                         jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(Object, Object[])                                                                                   
                                         jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Object, Object[])                                                                                       
                                         java.lang.reflect.Method.invoke(Object, Object[])                                                                                                              
                                         org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(...)                                                                                   
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker$Rep...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker$Rep...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker.doI...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker.inv...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryComposition$Repos...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryComposition.invok...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryFactorySupport$Im...                                                                                
                                         org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()                                                                                         
                                         org.springframework.data.repository.core.support.QueryExecutorMethodIntercep...                                                                                
                                         org.springframework.data.repository.core.support.QueryExecutorMethodIntercep...                                                                                
                                         org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()                                                                                         
                                         org.springframework.transaction.interceptor.TransactionInterceptor$$Lambda.0...                                                                                                                                                                       
...
</code></pre></div></div>

<h4 id="method-timing">Method Timing</h4>

<p>To enable method timing, you will configure the JFR option <code class="language-plaintext highlighter-rouge">method-timing</code> like in the example below. You can use the <code class="language-plaintext highlighter-rouge">jfr view</code> command to review the results of the recording.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording=method-timing='org.springframework.data.jpa.repository.support.SimpleJpaRepository::findAll',dumponexit=true,filename=recording.jfr -jar target/spring-petclinic-3.5.0-SNAPSHOT.jar

$ jfr view method-timing recording.jfr


                                                                                             Method Timing

Timed Method                                                                                                                                         Invocations Minimum Time Average Time Maximum Time
---------------------------------------------------------------------------------------------------------------------------------------------------- ----------- ------------ ------------ ------------
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Pageable)                                                                          2  3.440000 ms 25.700000 ms 47.900000 ms
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Specification, Pageable)                                                           2  3.440000 ms 25.700000 ms 47.900000 ms
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Specification, Specification, Pageable)                                            2  3.420000 ms 25.600000 ms 47.900000 ms
...
</code></pre></div></div>

<h3 id="jep-521---generational-shenandoah">JEP 521 - Generational Shenandoah</h3>

<p><a href="https://openjdk.org/jeps/521">Generational Shenandoah</a> has been made a final feature in JDK 25. If available on your JDK it can be enabled with the above JVM args.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational ...
</code></pre></div></div>

<h2 id="preview-and-incubator-features">Preview and Incubator Features</h2>

<p>There are six JEPs that covered experimental, preview, or incubator features in JDK 25.</p>

<h3 id="jep-470---pem-encodings-of-cryptographic-objects-preview">JEP 470 - PEM Encodings of Cryptographic Objects (Preview)</h3>

<p><a href="https://openjdk.org/jeps/470">PEM Encodings of Cryptographic Objects</a> introduces an API for encoding objects that represent cryptographic keys, and certificate revocation lists into the widely-used Privacy-Enhanced Mail (PEM) transport format.</p>

<h3 id="jep-502---stable-values-preview">JEP 502 - Stable Values (Preview)</h3>

<p><a href="https://openjdk.org/jeps/502">Stable Values</a> is an API for holding immutable data that can be treated as a constant by the JVM. A <code class="language-plaintext highlighter-rouge">StableValue</code> can only be set once, put provides more fleixiblity than what the <code class="language-plaintext highlighter-rouge">final</code> keyword allows, which requires a variable to be set at either class or instance initialization.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>

    <span class="c1">// OLD:</span>
    <span class="c1">// private Logger logger = null;</span>

    <span class="c1">// NEW:</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StableValue</span><span class="o">&lt;</span><span class="nc">Logger</span><span class="o">&gt;</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">StableValue</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>

    <span class="nc">Logger</span> <span class="nf">getLogger</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">logger</span><span class="o">.</span><span class="na">orElseSet</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="nc">OrderController</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">submitOrder</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">getLogger</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order started"</span><span class="o">);</span>
        <span class="o">...</span>
        <span class="n">getLogger</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order submitted"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-505---structured-concurrency-fifth-preview">JEP 505 - Structured Concurrency (Fifth Preview)</h3>

<p><a href="https://openjdk.org/jeps/505">Structured Concurrency</a> treats groups of related tasks running in different threads as single units of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. The fifth preview introduces a major update to the API from previous versions of it.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Response</span> <span class="nf">handle</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>

    <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">open</span><span class="o">())</span> <span class="o">{</span>

        <span class="nc">Subtask</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">findUser</span><span class="o">());</span>
        <span class="nc">Subtask</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">order</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchOrder</span><span class="o">());</span>

        <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>   <span class="c1">// Join subtasks, propagating exceptions</span>

        <span class="c1">// Both subtasks have succeeded, so compose their results</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Response</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">order</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>

    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-507---primitive-types-in-patterns-instanceof-and-switch-third-preview">JEP 507 - Primitive Types in Patterns, instanceof, and switch (Third Preview)</h3>

<p><a href="https://openjdk.org/jeps/507">Primitive Types in Patterns, instanceof, and switch</a> enhances pattern matching allowing primitives to be used in all contexts.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getYearlyFlights</span><span class="o">())</span> <span class="o">{</span>
	<span class="k">case</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">standardRate</span><span class="o">();</span>
	<span class="k">case</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">standardRate</span><span class="o">();</span>
	<span class="k">case</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">issueDiscount</span><span class="o">();</span>
	<span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">-&gt;</span> <span class="n">issueGoldCard</span><span class="o">();</span>
	<span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span> <span class="n">i</span> <span class="err">›</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">-&gt;</span> <span class="n">issueSilverDiscount</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-508---vector-api-tenth-incubator">JEP 508 - Vector API (Tenth Incubator)</h3>

<p><a href="https://openjdk.org/jeps/508">Vector API</a> enables the expressing vector computations that reliably compile at runtime to optimal vector instructions on supported CPUs, thereby achieving performance superior to equivalent scalar computations. The Vector API will remain in incubator status until the promotion of <a href="https://openjdk.org/projects/valhalla/">Project Valhalla</a> features into the mainline JDK.</p>

<h3 id="jep-509---jfr-cpu-time-profiling-experimental">JEP 509 - JFR CPU-Time Profiling (Experimental)</h3>

<p><a href="https://openjdk.org/jeps/509">JFR CPU-Time Profiling</a> allows JFR to capture more accurate CPU-time profiling information. Note this feature only works on Linux.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true, filename=profile.jfr ...
</code></pre></div></div>

<h2 id="removed-features">Removed Features</h2>

<p>Only a single JEP covers a feature that was removed in JDK 25.</p>

<h3 id="jep-503---remove-the-32-bit-x86-port">JEP 503 - Remove the 32-bit x86 Port</h3>

<p><a href="https://openjdk.org/jeps/509">Remove the 32-bit x86 Port</a> removes all code and build support for 32-bit x86 ports. Subsequently 32-bit OpenJDK binaries will no longer be available starting with the JDK 25 release.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Java 25 represents yet another successful release of Java, following the six-month release cadence. Because this release will come with long-term support offerings (colloquially, an “LTS Release”), many Java developers will take a particular interest in it, as well as in 22, 23, and 24. To that end, I would highly suggest watching out <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzXJ2_0FIGleUisXuUm4AESE">Road to Java 25 video series</a>, and checking out our <a href="https://www.youtube.com/watch?v=duIceCXObrA">Java 25 Launch Livestream</a> where we covered all the important changes between Java 21 and 25.</p>]]></content><author><name>[&quot;BillyKorando&quot;]</name></author><category term="JDK 25" /><summary type="html"><![CDATA[JDK 25 has been released! Let’s quickly review the 18 JEPs (JDK Enhancement Proposals) that were included in the JDK 25 release, in 2 minutes, or maybe just a bit more! And if you have more than a few minutes, you can check out the playlist , but fair warning: your coffee might get cold before you’re done!]]></summary></entry><entry><title type="html">Structured Concurrency in Action</title><link href="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/" rel="alternate" type="text/html" title="Structured Concurrency in Action" /><published>2025-10-16T00:00:00+00:00</published><updated>2025-10-16T00:00:00+00:00</updated><id>https://inside.java/2025/10/16/DevoxxBelgium-Structured-Concurrency-Action</id><content type="html" xml:base="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/IosvCU9qM5M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>In Java 25, the structured concurrency API sees its fifth preview with considerable changes over previous iterations. With chances being good that it will finalize without a further overhaul, let’s put it into action and explore how to:</em></p>

<ul>
  <li><em>structure concurrent code</em></li>
  <li><em>process and propagate errors and cancellation</em></li>
  <li><em>observe thread relationships</em></li>
  <li><em>refactor from a reactive approach</em></li>
</ul>

<p><em>After this presentation you’ll be ready to put the structured concurrency API into action in your project.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 25" /><category term="Loom" /><summary type="html"><![CDATA[In Java 25, the structured concurrency API sees its fifth preview with considerable changes over previous iterations. With chances being good that it will finalize without a further overhaul, let's put it into action and explore how to: structure concurrent code, process and propagate errors and cancellation, observe thread relationships, and refactor from a reactive approach. After this presentation you'll be ready to put the structured concurrency API into action in your project.]]></summary></entry><entry><title type="html">Java for AI</title><link href="https://inside.java/2025/10/14/devoxxbelgium-java-for-ai/" rel="alternate" type="text/html" title="Java for AI" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T00:00:00+00:00</updated><id>https://inside.java/2025/10/14/DevoxxBelgium-Java-For-AI</id><content type="html" xml:base="https://inside.java/2025/10/14/devoxxbelgium-java-for-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/hBffN0xW784" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Many Java features, existing and future, can meet the demands of AI. Existing features include the Foreign Function and Memory API and the Vector API.</em> 
<em>Future features include those proposed by Project Valhalla and Project Babylon.</em></p>

<p><em>This presentation will discuss these features and how they might be used by Java libraries and applications to build competitive AI solutions.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;PaulSandoz&quot;]</name></author><category term="AI" /><category term="Babylon" /><category term="Panama" /><category term="Valhalla" /><summary type="html"><![CDATA[Many Java features, existing and future, can meet the demands of AI. Existing features include the Foreign Function and Memory API and the Vector API. Future features include those proposed by Project Valhalla and Project Babylon. This presentation will discuss these features and how they might be used by Java libraries and applications to build competitive AI solutions.]]></summary></entry><entry><title type="html">Pattern Matching, Under the Microscope</title><link href="https://inside.java/2025/10/13/devoxxbelgium-pattern-matching/" rel="alternate" type="text/html" title="Pattern Matching, Under the Microscope" /><published>2025-10-13T00:00:00+00:00</published><updated>2025-10-13T00:00:00+00:00</updated><id>https://inside.java/2025/10/13/DevoxxBelgium-Pattern-Matching</id><content type="html" xml:base="https://inside.java/2025/10/13/devoxxbelgium-pattern-matching/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/hcWKRfRR-7Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Project Amber has introduced pattern matching into the Java language, improving both safety and expressiveness of our programs.</em>
<em>With JEP 507 set to lift restrictions on primitive types in instanceof and switch, pattern matching is positioned as the foundation of safe cast conversions across all Java types.</em> 
<em>But what does this mean for the language, its safety guarantees, and how we test runtime conditions?</em></p>

<p><em>This session takes an in-depth look at the fundamental concepts of exhaustiveness, unconditionality, applicability, remainder, and examine the distinction between exact and inexact conversions as introduced by JEP 507. With practical code comparisons and visual explanations, we will see how these patterns drive safer code and enable innovative language features on the horizon.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;AngelosBimpoudis&quot;]</name></author><category term="Amber" /><category term="Java Language" /><summary type="html"><![CDATA[Project Amber has introduced pattern matching into the Java language, improving both safety and expressiveness of our programs. With JEP 507 set to lift restrictions on primitive types in instanceof and switch, pattern matching is positioned as the foundation of safe cast conversions across all Java types. But what does this mean for the language, its safety guarantees, and how we test runtime conditions? This session takes an in-depth look at the fundamental concepts of exhaustiveness, unconditionality, applicability, remainder, and examine the distinction between exact and inexact conversions as introduced by JEP 507. With practical code comparisons and visual explanations, we will see how these patterns drive safer code and enable innovative language features on the horizon.]]></summary></entry></feed>