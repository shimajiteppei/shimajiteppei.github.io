<?xml version="1.0" encoding="UTF-8"?>
<feed xml:lang="ja-JP" xmlns="http://www.w3.org/2005/Atom">
  <id>tag:qiita.com,2005:/tags/rust/feed</id>
  <link rel="alternate" type="text/html" href="https://qiita.com"/>
  <link rel="self" type="application/atom+xml" href="https://qiita.com/tags/rust/feed"/>
  <title>Rustタグが付けられた新着記事 - Qiita</title>
  <description>QiitaでRustタグが付けられた新着記事</description>
  <updated>2025-09-05T11:55:33+09:00</updated>
  <link>https://qiita.com/tags/rust</link>
  <entry>
    <id>tag:qiita.com,2005:PublicArticle/2076248</id>
    <published>2025-09-05T11:55:33+09:00</published>
    <updated>2025-09-05T11:55:33+09:00</updated>
    <link rel="alternate" type="text/html" href="https://qiita.com/tamkame123/items/fe4d0b9a8fa6e7f4db7f"/>
    <url>https://qiita.com/tamkame123/items/fe4d0b9a8fa6e7f4db7f</url>
    <title>ライフタイムを意識してコードを書く.rs</title>
    <content type="text">今回のお題はこのコードです。
fn main() {
    // スレッド間で安全に使えるようにする
    let counter = Arc::new(Mutex::new(0));
    // スレッドを建てる
    let threads = (0..2).m...</content>
    <author>
      <name>tamkame123</name>
    </author>
  </entry>
  <entry>
    <id>tag:qiita.com,2005:PublicArticle/2076146</id>
    <published>2025-09-05T02:59:13+09:00</published>
    <updated>2025-09-05T02:59:13+09:00</updated>
    <link rel="alternate" type="text/html" href="https://qiita.com/uasi/items/804597f1da7c84e6b3d1"/>
    <url>https://qiita.com/uasi/items/804597f1da7c84e6b3d1</url>
    <title>Cargo.lock のヘッダーコメントにある @generated マーカーの意味を調べた</title>
    <content type="text">Cargo.lock の先頭には以下のコメントが書かれている。
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.

@generated にア...</content>
    <author>
      <name>uasi</name>
    </author>
  </entry>
  <entry>
    <id>tag:qiita.com,2005:PublicArticle/2075984</id>
    <published>2025-09-04T18:13:55+09:00</published>
    <updated>2025-09-04T18:13:55+09:00</updated>
    <link rel="alternate" type="text/html" href="https://qiita.com/m4skedvanir/items/5a2dc0d673d0e990d242"/>
    <url>https://qiita.com/m4skedvanir/items/5a2dc0d673d0e990d242</url>
    <title>初心者プログラマーがAtCoderに挑んだ軌跡-ABC412-A-</title>
    <content type="text">ABC412-A

問題の内容
連続した数値比較

言語
Rust

解法
inputをforループで回す等を思いついた。
ただ、proconioには便利な書き方がありそれを使用した。

課題
二次元配列の読み込み

学んだこと
ab: [(i64, i64); n]と書...</content>
    <author>
      <name>m4skedvanir</name>
    </author>
  </entry>
  <entry>
    <id>tag:qiita.com,2005:PublicArticle/2075979</id>
    <published>2025-09-04T18:01:15+09:00</published>
    <updated>2025-09-04T18:01:15+09:00</updated>
    <link rel="alternate" type="text/html" href="https://qiita.com/m4skedvanir/items/9e658d040357247febd1"/>
    <url>https://qiita.com/m4skedvanir/items/9e658d040357247febd1</url>
    <title>初心者プログラマーがAtCoderに挑んだ軌跡-ABC411-A-</title>
    <content type="text">ABC411-A

問題の内容
文字数カウント

言語
Rust

解法
count変数を作って数え上げてもいいが、イテレータ使って頑張ってみた。

課題
特になし

学んだこと
特になし

提出内容
use proconio::input;

fn main() {
 ...</content>
    <author>
      <name>m4skedvanir</name>
    </author>
  </entry>
</feed>
