<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-11-05T11:45:33+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">JEP targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization</title><link href="https://inside.java/2025/11/05/jep522-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization" /><published>2025-11-05T00:00:00+00:00</published><updated>2025-11-05T00:00:00+00:00</updated><id>https://inside.java/2025/11/05/JEP522-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/05/jep522-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?751878316" /></p>]]></content><author><name>[&quot;IvanWalulya&quot;, &quot;ThomasSchatzl&quot;]</name></author><category term="JDK 26" /><category term="GC" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization]]></summary></entry><entry><title type="html">Integrity by Default</title><link href="https://inside.java/2025/11/04/javaone-integrity-by-default/" rel="alternate" type="text/html" title="Integrity by Default" /><published>2025-11-04T00:00:00+00:00</published><updated>2025-11-04T00:00:00+00:00</updated><id>https://inside.java/2025/11/04/JavaOne-Integrity-By-Default</id><content type="html" xml:base="https://inside.java/2025/11/04/javaone-integrity-by-default/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/uTPRTkny7kQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>To assist performance, portability, and security, the Java Platform is progressing toward a state where its abstractions, as well as programmer-defined abstractions, can be made robust and invariants can be locally guaranteed. Libraries may violate some invariants but only if selectively allowed by the application. This session covers the why and how of the vision of “Integrity by Default”.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzVV1xRJkRbcM2tOgVwytJAi">JavaOne 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;RonPressler&quot;]</name></author><category term="Core Libraries" /><category term="Security" /><summary type="html"><![CDATA[To assist performance, portability, and security, the Java Platform is progressing toward a state where its abstractions, as well as programmer-defined abstractions, can be made robust and invariants can be locally guaranteed. Libraries may violate some invariants but only if selectively allowed by the application. This session covers the why and how of the vision of "Integrity by Default".]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 25: Consistent Behavior of ‘new File(“”)’</title><link href="https://inside.java/2025/11/03/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 25: Consistent Behavior of ‘new File(“”)’" /><published>2025-11-03T00:00:00+00:00</published><updated>2025-11-03T00:00:00+00:00</updated><id>https://inside.java/2025/11/03/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/11/03/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of a <a href="https://mail.openjdk.org/pipermail/quality-discuss/2025-February/001141.html">regular communication</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="inconsistencies-of-new-file">Inconsistencies of ‘new File(“”)’</h2>

<p>On JDK 24 and earlier, the behavior of a <code class="language-plaintext highlighter-rouge">File</code> instance created from the empty string was inconsistent.
Queried for information, it appeared to be non-existent:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "false" on JDK 24</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>Similarly, methods like <code class="language-plaintext highlighter-rouge">canRead</code> returned <code class="language-plaintext highlighter-rouge">false</code> and <code class="language-plaintext highlighter-rouge">length</code>, <code class="language-plaintext highlighter-rouge">lastModified</code>, etc. returned <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>When transformed to an instance representing the absolute path, the behavior changed, though:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">).</span><span class="na">getAbsoluteFile</span><span class="o">();</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>The reason is that <code class="language-plaintext highlighter-rouge">new File("").getAbsoluteFile()</code> maps to the current user directory and the <code class="language-plaintext highlighter-rouge">File</code> API behaves accordingly.
Since <code class="language-plaintext highlighter-rouge">new File("")</code> and <code class="language-plaintext highlighter-rouge">new File("").getAbsoluteFile()</code> should represent the same file system entry, this inconsistency is jarring and can be surprising.</p>

<p>The newer API in <code class="language-plaintext highlighter-rouge">java.nio.file</code> avoids this issue and treats both <code class="language-plaintext highlighter-rouge">Path.of("")</code> and <code class="language-plaintext highlighter-rouge">Path.of("").toAbsolutePath()</code> as the current user directory.
For example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">();</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
</code></pre></div></div>

<h2 id="change-in-jdk-25">Change in JDK 25</h2>

<p>JDK 25 fixed this long-standing inconsistency and <code class="language-plaintext highlighter-rouge">new File("")</code> now properly represents the current user directory:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "true" on JDK 25</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>The <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/File.html">Javadoc for <code class="language-plaintext highlighter-rouge">File</code></a> was updated to spell out the intended behavior:</p>

<blockquote>
  <p>Accessing a file with the empty abstract pathname is equivalent to accessing the current user directory.</p>
</blockquote>

<p>For more details, check <a href="https://bugs.openjdk.org/browse/JDK-8024695">JDK-8024695</a>.</p>

<h2 id="migration">Migration</h2>

<p>Code that relies on the old behavior is often found in unit tests (e.g. to intentionally create non-existent files with <code class="language-plaintext highlighter-rouge">new File("")</code>) or where user input is mapped to file system entries (e.g. to treat “no user entry” and “invalid user entry” the same: as an absent file).
Here it may show itself through misbehavior around file-related arguments or configuration.</p>

<p>While fixing such code should be straightforward, identifying it may not be - a thorough test suite helps.
For dependencies and tools, the recommendation is to rely on their tests and statements regarding JDK 25 compatibility.
Only they can fix potential issues as there is no way to restore the inconsistent behavior of JDK 24 and earlier.</p>

<center>~</center>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 25" /><category term="Core Libraries" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers the behavioral change of `File` instances that were created from the empty path.]]></summary></entry><entry><title type="html">Supercharge your JVM Performance with Project Leyden and Spring Boot</title><link href="https://inside.java/2025/11/02/devoxxbelgium-leyden-supercharge-jvm-performance/" rel="alternate" type="text/html" title="Supercharge your JVM Performance with Project Leyden and Spring Boot" /><published>2025-11-02T00:00:00+00:00</published><updated>2025-11-02T00:00:00+00:00</updated><id>https://inside.java/2025/11/02/DevoxxBelgium-leyden-supercharge-jvm-performance</id><content type="html" xml:base="https://inside.java/2025/11/02/devoxxbelgium-leyden-supercharge-jvm-performance/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/izLzgnMMjbU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Many modern applications and tools rely on Java. Yet, their startup time and time-to-peak performance remain challenging, especially for microservices and Kubernetes workloads that require fast scaling and responsiveness. Project Leyden, an ambitious OpenJDK initiative, aims to overcome these performance bottlenecks.</em></p>

<p><em>In this session, Ana and Moritz show how you can take advantage of Leyden’s optimizations using Java 25 and Spring Boot. You also get practical techniques you can apply today, along with a peek into the ongoing work inside Leyden and what that means for the performance of your Java application.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 25" /><category term="Leyden" /><category term="Performance" /><summary type="html"><![CDATA[Many modern applications and tools rely on Java. Yet, their startup time and time-to-peak performance remain challenging, especially for microservices and Kubernetes workloads that require fast scaling and responsiveness. Project Leyden, an ambitious OpenJDK initiative, aims to overcome these performance bottlenecks. In this session, Ana and Moritz show how you can take advantage of Leyden’s optimizations using Java 25 and Spring Boot. You also get practical techniques you can apply today, along with a peek into the ongoing work inside Leyden and what that means for the performance of your Java application.]]></summary></entry><entry><title type="html">Value Classes Heap Flattening - What to expect from JEP 401 #JVMLS</title><link href="https://inside.java/2025/10/31/jvmls-jep-401/" rel="alternate" type="text/html" title="Value Classes Heap Flattening - What to expect from JEP 401 #JVMLS" /><published>2025-10-31T00:00:00+00:00</published><updated>2025-10-31T00:00:00+00:00</updated><id>https://inside.java/2025/10/31/JVMLS-JEP-401</id><content type="html" xml:base="https://inside.java/2025/10/31/jvmls-jep-401/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/NF4CpL_EWFI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>The initial flattening in Project Valhalla relied on four property value types had at the time: lack of identity, immutability, null-freeness, and non-atomicity.</em> 
<em>As our understanding of value types improved, we realized that null-freeness was not a property inherently part of value types, and that non-atomicity was too challenging to include in the Java language for a first release. So, <a href="https://openjdk.org/jeps/401">JEP 401</a> defines value class instances as identity-less and (mostly) immutable. The value class model has also been relaxed, allowing field inheritance through abstract value classes. All these modifications, combined with the constraints of the Java Memory Model and the limitations of current hardware, created new challenges for the JVM to be able to flatten values. New flattening schemes had to be developed and are presented in the talk.</em></p>

<p><em>As the Valhalla team explored new flattening solutions, it became obvious that flattening is a multi-faceted problem. Flattening is beneficial to memory density: by removing object headers and the indirection pointer, Java heap space is used more efficiently. The spatial locality of the value and its container can lead to better cache efficiency, but a flat value can also have a higher access cost than a non-flat value, especially if properties such as nullability and atomicity must be guaranteed. Memory density can also be improved by using clever encodings to make the most of every bit of the flat representation. However, complex encodings usually have a higher access cost and have a significant impact on the code complexity in the JVM. The talk will explain the different trade-offs JVM engineers had to make when implementing the flattening policies.</em></p>

<p><em>With an improved prototype, benchmarks helped us understand the kinds of improvements flattening can provide, and which scenarios can be negatively impacted. Flat arrays accessed by C2 compiled code were, and remain, the ideal scenario for achieving a significant boost in application raw performance. Field flattening initially performed poorly in comparison until its impact on GC workload was measured. Finally, if C2 is able to exploit flat values to their maximum, other VM components like the interpreter, the runtime, or even C1 have a much harder time handling flat values, possibly leading to performance regressions—an aspect to consider when maintaining good startup times.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;FredericParain&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[Project Valhalla's approach to flattening value types has evolved significantly, driven by a deeper understanding of value type semantics, challenges in the Java language and the JVM.]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API</title><link href="https://inside.java/2025/10/30/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API" /><published>2025-10-30T00:00:00+00:00</published><updated>2025-10-30T00:00:00+00:00</updated><id>https://inside.java/2025/10/30/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/10/30/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of the <a href="https://mail.openjdk.org/pipermail/quality-discuss/">quality outreach</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="http3-support-in-httpclient">HTTP/3 Support in HttpClient</h2>

<p>The <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> API allows Java applications to create reusable HTTP client instances, build HTTP requests, and handle responses synchronously or asynchronously. 
Since JDK 11, you can set the preferred HTTP protocol versions like HTTP/1.1 or HTTP/2 at the <code class="language-plaintext highlighter-rouge">HttpClient</code> or <code class="language-plaintext highlighter-rouge">HttpRequest</code> level.</p>

<p><a href="https://openjdk.org/jeps/517">JEP 517</a> introduces support for HTTP/3 (<code class="language-plaintext highlighter-rouge">HttpClient.Version.HTTP_3</code>) in JDK 26, enabling applications to prefer or enforce HTTP/3 for requests.
While HTTP/3 offers similar features to HTTP/2 at the protocol level, its key difference is that it runs over the QUIC protocol using UDP, whereas HTTP/2 operates over TCP.
Below is a code snippet on how you can prefer and/or enforce HTTP/3:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// prefer HTTP/3</span>
<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// if target server support HTTP/3, add this to enforce it</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>
</code></pre></div></div>

<p>If you set HTTP/3 but it is not available, the client will automatically downgrade to HTTP/2 or HTTP/1.1.
If you configure to strictly require HTTP/3, a failed attempt leads to an exception rather than a downgrade.</p>

<p>However, setting HTTP/3 as the preferred version does not guarantee its use, as the client cannot know beforehand if the server supports it. 
For the first request to a server, the client tries both TCP (HTTP/2) and UDP (HTTP/3) connections and uses whichever succeeds first. 
Over time, the <code class="language-plaintext highlighter-rouge">HttpClient</code> can “learn” about the HTTP version(s) that a server supports by using the “Alt-Svc” mechanism (the “HTTP Alternative Services” standard per <a href="https://datatracker.ietf.org/doc/html/rfc7838">RFC 7838</a>). 
Servers supporting “Alt-Svc” advertise alternative supported protocols such as HTTP/3. This allows subsequent requests to that server to use HTTP/3 when supported. For more details on this mechanism, see <a href="https://inside.java/2025/10/22/http3-support/">this article</a>.</p>

<h2 id="call-to-action">Call to Action</h2>

<p>Although the enhancements to the HTTP Client API appear simple to use, supporting HTTP/3 on top of QUIC represents the result of several years of dedicated development effort within the JDK team.
As this implementation is still new, we encourage you to download the <a href="https://jdk.java.net/26/">Java 26 Early Access builds</a>, try this feature, and share your feedback through the <a href="https://mail.openjdk.org/mailman/listinfo/net-dev">net-dev OpenJDK mailing list</a> (registration required).</p>

<center>~</center>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 26" /><category term="Networking" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers the HTTP/3 support in JDK 26.]]></summary></entry><entry><title type="html">AI World: Georges Saab Unveils Java 25 for AI and Cloud</title><link href="https://inside.java/2025/10/29/aiworld-java-for-ai/" rel="alternate" type="text/html" title="AI World: Georges Saab Unveils Java 25 for AI and Cloud" /><published>2025-10-29T00:00:00+00:00</published><updated>2025-10-29T00:00:00+00:00</updated><id>https://inside.java/2025/10/29/AIWorld-java-for-ai</id><content type="html" xml:base="https://inside.java/2025/10/29/aiworld-java-for-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/a1aro8bq30o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.</em></p>

<p><em>Java is trusted by millions of developers worldwide and remains the backbone of enterprise systems and emerging AI-powered workloads. In this special segment from Oracle TV at Oracle AI World 2025, Georges Saab, Senior Vice President of Development of the Java Platform, highlights the latest features in Java 25 and their impact on developers, IT leaders, and businesses at scale.</em></p>

<p><em>Georges explains the major innovations in Java 25, Oracle’s approach to evolving and supporting the Java language, platform, and ecosystem, and the important role of GraalVM’s alternative runtime. Learn how the Java 25 long-term support (LTS) release enables organizations to modernize legacy applications and embrace cloud-first and multi-cloud strategies. Discover how new features in Java 25 make it easier to build, deploy, and run AI-driven and cloud-native solutions—driving agility and business value. Georges also provides a preview of what’s coming in Java 26, reinforcing Java’s ongoing six-month release cadence and its future in the enterprise and beyond.</em></p>]]></content><author><name>[&quot;GeorgesSaab&quot;]</name></author><category term="AI" /><category term="Cloud" /><category term="Oracle" /><summary type="html"><![CDATA[Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.]]></summary></entry><entry><title type="html">Episode 41 “From Cowboy Mode to Careful Stewardship” with Mark Reinhold</title><link href="https://inside.java/2025/10/27/podcast-041/" rel="alternate" type="text/html" title="Episode 41 “From Cowboy Mode to Careful Stewardship” with Mark Reinhold" /><published>2025-10-27T01:00:00+00:00</published><updated>2025-10-27T01:00:00+00:00</updated><id>https://inside.java/2025/10/27/Podcast-041</id><content type="html" xml:base="https://inside.java/2025/10/27/podcast-041/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/ChadMic.jpg?716070966" /></p>

<p><br /></p>
<iframe title="Libsyn Player" style="border: none" src="//html5-player.libsyn.com/embed/episode/id/38766750/height/90/theme/custom/thumbnail/yes/direction/forward/render-playlist/no/custom-color/000000/" height="90" width="100%" scrolling="no"></iframe>

<div class="youtube-embed">
<iframe src="https://www.youtube.com/embed/ny4CqBX_kaQ?si=YMIp5TbKvjRQaCy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</div>

<p><br /></p>

<p>Java is a 30-year success story, made possible because its development consistently aligned with users’ needs. In its early days, the platform required new features quickly, but over time, minimizing code breakage while carefully evolving the platform became essential. Critical junctures along that path included the introduction of modules and the current strive toward integrity by default.</p>

<p>Nicolai Parlog talks to Mark Reinhold, Chief Architect of the Java Platform, who brings nearly three decades of experience shaping Java’s evolution.</p>

<p><br />
Make sure to also check the <strong>Duke’s Corner podcast</strong> on <a href="https://dev.java/duke/corner/">dev.java</a>.</p>

<p><br /></p>

<h3 id="additional-resources">Additional resources</h3>
<ul>
  <li><a href="https://inside.java">Inside.java</a> : News and views from members of the Java team at Oracle</li>
  <li><a href="https://dev.java">Dev.java</a> : The Destination for Java Developers</li>
  <li><a href="https://openjdk.java.net/">OpenJDK</a></li>
  <li><a href="https://www.oracle.com/java/">Oracle Java</a></li>
</ul>

<p>For more episodes, check out <a href="https://inside.java/podcast">Inside Java</a>, our <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzV_hXbRevwzrXSMcGNzhxiZ">YouTube playlist</a>, and follow <a href="https://twitter.com/java">@Java</a> on Twitter.</p>

<p>Contact us <a href="https://inside.java/about/">here</a>.</p>]]></content><author><name>[&quot;MarkReinhold&quot;, &quot;NicolaiParlog&quot;]</name></author><summary type="html"><![CDATA[Nicolai Parlog talks to Mark Reinhold, Chief Architect of the Java Platform, who has almost 30 years of experience driving Java forward...]]></summary></entry><entry><title type="html">Try Out JEP 401 Value Classes and Objects</title><link href="https://inside.java/2025/10/27/try-jep-401-value-classes/" rel="alternate" type="text/html" title="Try Out JEP 401 Value Classes and Objects" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>https://inside.java/2025/10/27/try-jep-401-value-classes</id><content type="html" xml:base="https://inside.java/2025/10/27/try-jep-401-value-classes/"><![CDATA[<p>The Valhalla team recently published an early-access JDK build that fully implements <a href="https://openjdk.org/jeps/401">JEP 401: Value Classes and Objects (Preview)</a>.
There’s still a lot of work to do to get this code into a future release of the JDK.
Until then, now is a great time for anyone who is interested to try out this transformative new feature!</p>

<h2 id="getting-the-early-access-builds">Getting the Early-Access Builds</h2>

<p>To get started, go to <a href="https://jdk.java.net/valhalla/">jdk.java.net/valhalla</a> and download an early-access JDK build.</p>

<p>Unzip the package, put it somewhere handy, and refer to its <code class="language-plaintext highlighter-rouge">bin</code> directory to run commands like <code class="language-plaintext highlighter-rouge">java</code> and <code class="language-plaintext highlighter-rouge">javac</code>.
On my Mac, I’ll set an environment variable for easy access to these commands in the examples below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; export jdk401="$PWD/jdk-26.jdk/Contents/Home/bin"

% -&gt; "$jdk401"/java --version
openjdk 26-jep401ea2 2026-03-17
OpenJDK Runtime Environment (build 26-jep401ea2+1-1)
OpenJDK 64-Bit Server VM (build 26-jep401ea2+1-1, mixed mode, sharing)
</code></pre></div></div>

<h2 id="experimenting-with-value-objects">Experimenting with Value Objects</h2>

<p>As the JEP explains, <em>value objects</em> are instances of <em>value classes</em>, which have only <code class="language-plaintext highlighter-rouge">final</code> fields and lack object identity.
A handful of JDK classes, including <code class="language-plaintext highlighter-rouge">Integer</code> and <code class="language-plaintext highlighter-rouge">LocalDate</code>, become value classes when we run Java in preview mode.</p>

<p>In JShell, <code class="language-plaintext highlighter-rouge">Objects.hasIdentity</code> makes it easy to tell which objects are value objects and which are regular <em>identity objects</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/jshell --enable-preview
|  Welcome to JShell -- Version 26-jep401ea2
|  For an introduction type: /help intro

jshell&gt; Objects.hasIdentity(Integer.valueOf(123))
$1 ==&gt; false

jshell&gt; Objects.hasIdentity("abc")
$2 ==&gt; true

jshell&gt; Objects.hasIdentity(LocalDate.now())
$3 ==&gt; false

jshell&gt; Objects.hasIdentity(new ArrayList&lt;&gt;())
$4 ==&gt; true
</code></pre></div></div>

<p>Value objects behave just like identity objects in most ways.
But one difference is that <code class="language-plaintext highlighter-rouge">==</code> can’t tell whether two value objects are “the same object” or not—they have no identity to compare.
Instead, <code class="language-plaintext highlighter-rouge">==</code> tests whether two value objects are <em>statewise-equivalent</em>: instances of the same class with the same field values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jshell&gt; LocalDate d1 = LocalDate.now()
d1 ==&gt; 2025-10-23

jshell&gt; LocalDate d2 = d1.plusDays(365)
d2 ==&gt; 2026-10-23

jshell&gt; LocalDate d3 = d2.minusDays(365)
d3 ==&gt; 2025-10-23

jshell&gt; d1 == d3
$8 ==&gt; true
</code></pre></div></div>

<p>Statewise equivalence is no substitute for a meaningful <code class="language-plaintext highlighter-rouge">equals</code> method designed by a class author. In some cases, two instances of a value class with different states should still be considered equal. 
So the best practice, as usual, is to avoid the <code class="language-plaintext highlighter-rouge">==</code> operator and prefer <code class="language-plaintext highlighter-rouge">equals</code> for comparisons.</p>

<p>You can declare your own value classes with the <code class="language-plaintext highlighter-rouge">value</code> keyword.
Many record declarations are good candidates to be value classes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jshell&gt; value record Point(int x, int y) {}
|  created record Point

jshell&gt; Point p = new Point(17, 3)
p ==&gt; Point[x=17, y=3]

jshell&gt; Objects.hasIdentity(p)
$11 ==&gt; false

jshell&gt; new Point(17, 3) == p
$12 ==&gt; true
</code></pre></div></div>

<h3 id="value-object-performance">Value Object Performance</h3>

<p>Why bother to declare a value class instead of regular identity class?</p>

<p>One reason is a semantic one:
If your class represents immutable domain values that are interchangeable when they have the same state, giving these objects all the features of identity just adds unnecessary complexity.
Better to declare a value class and give up identity entirely.</p>

<p>But the most compelling reason is that the JVM can optimize value objects in ways that are impossible for regular objects.
For example, a reference to a value object doesn’t have to point to a canonical memory location for that object.
Instead, the state of the object can be <em>embedded in the reference itself</em>.
This technique is called <em>heap flattening</em>, and can make a huge difference in the cost of loading objects from memory.</p>

<p>As a test, let’s create a very large array of <code class="language-plaintext highlighter-rouge">LocalDate</code> value objects and add up all of their year values.
To simulate a realistic distribution of objects in memory, we’ll populate the array from an unsorted <code class="language-plaintext highlighter-rouge">HashSet</code> of <code class="language-plaintext highlighter-rouge">LocalDate</code> objects.
We can do some rudimentary profiling by tracking the wall-clock time required to iterate through the array.
(Note: For more accurate profiling, <a href="https://github.com/openjdk/jmh">JMH</a> should be used.)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">50_000_000</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">size</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="nc">LocalDate</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">makeArray</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">sumYears</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Attempt "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">/// Expensive task to be timed</span>
<span class="kt">long</span> <span class="nf">sumYears</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">[]</span> <span class="n">dates</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">d</span> <span class="o">:</span> <span class="n">dates</span><span class="o">)</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">d</span><span class="o">.</span><span class="na">getYear</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">/// Make an array of LocalDates, unpredictably ordered</span>
<span class="nc">LocalDate</span><span class="o">[]</span> <span class="nf">makeArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">LocalDate</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">.</span><span class="na">ofEpochDay</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">LocalDate</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
<span class="o">}</span>

<span class="c1">/// Run a task and report the elapsed wall-clock time in ms</span>
<span class="kt">double</span> <span class="nf">time</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="kt">var</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="k">return</span> <span class="nc">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">).</span><span class="na">toNanos</span><span class="o">()</span> <span class="o">/</span> <span class="mf">1_000_000.0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As a baseline, when I put this code in a <code class="language-plaintext highlighter-rouge">DateTest.java</code> file and run it on my MacBook Pro <em>without</em> preview features enabled, I get the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/java DateTest.java
Attempt 1: 82.703
Attempt 2: 77.716
Attempt 3: 74.959
Attempt 4: 71.962
Attempt 5: 71.915
</code></pre></div></div>

<p>When I turn on preview features, <code class="language-plaintext highlighter-rouge">LocalDate</code> becomes a value class, and its instances can be flattened directly in the array.
By avoiding extra memory loads, the JVM can achieve a nearly 3x speedup!:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/java --enable-preview DateTest.java
Attempt 1: 41.959
Attempt 2: 38.992
Attempt 3: 25.466
Attempt 4: 28.404
Attempt 5: 25.027
</code></pre></div></div>

<p>Results will vary on different machines and different array sizes.
But the point is that by using value objects in our performance-critical computation, we’ve enabled the JVM to make significant new optimizations that are impossible for identity objects.</p>

<h2 id="next-steps">Next Steps</h2>

<p>This is beta software, and it’s sure to have some bugs and surprising performance pitfalls.
Now is a great time for interested users to download the early-access build and try it out on their performance-sensitive workloads.
Feedback at <code class="language-plaintext highlighter-rouge">valhalla-dev@openjdk.org</code> is welcome and encouraged!</p>

<p>Of course, sprinkling the <code class="language-plaintext highlighter-rouge">value</code> keyword around a code base is not going to automatically address whatever performance bottlenecks the program faces.</p>

<p>Users are encouraged to review the <a href="https://openjdk.org/projects/valhalla/value-objects">feature doocumentation</a> to get a better sense of what kind of optimizations are possible, and use profiling tools like <a href="https://docs.oracle.com/en/java/java-components/jdk-mission-control/">JDK Mission Control</a> and <a href="https://github.com/openjdk/jmh">JMH</a> to see how value objects affect their program’s performance.</p>]]></content><author><name>[&quot;DanSmith&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[The Valhalla team recently published an early-access JDK build that fully implements JEP 401: Value Classes and Objects (Preview). Now is a great time for anyone who is interested to try out this transformative new feature!]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 517: HTTP/3 for the HTTP Client API</title><link href="https://inside.java/2025/10/26/jep517-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 517: HTTP/3 for the HTTP Client API" /><published>2025-10-26T00:00:00+00:00</published><updated>2025-10-26T00:00:00+00:00</updated><id>https://inside.java/2025/10/26/JEP517-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/10/26/jep517-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 517: HTTP/3 for the HTTP Client API</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?702868059" /></p>]]></content><author><name>[&quot;DanielFuchs&quot;]</name></author><category term="JDK 26" /><category term="Client" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 517: HTTP/3 for the HTTP Client API]]></summary></entry></feed>