<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2026-02-09T09:44:22+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Quality Outreach Heads-up - JDK 26: DecimalFormat Uses the Double.toString(double) Algorithm</title><link href="https://inside.java/2026/02/09/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 26: DecimalFormat Uses the Double.toString(double) Algorithm" /><published>2026-02-09T00:00:00+00:00</published><updated>2026-02-09T00:00:00+00:00</updated><id>https://inside.java/2026/02/09/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2026/02/09/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of the <a href="https://mail.openjdk.org/pipermail/quality-discuss/">quality outreach</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="decimalformat-formats-floating-point-values-with-the-doubletostringdouble-algorithm">DecimalFormat Formats Floating-Point Values with the Double.toString(double) Algorithm</h2>

<p>Since JDK 21, <code class="language-plaintext highlighter-rouge">java.text.DecimalFormat::format</code> and <code class="language-plaintext highlighter-rouge">java.util.Formatter::toString</code> produce slightly different outcomes on some double values, like the one from the snippet bellow.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="mf">7.3879E20</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">minFractionDigits</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="nc">DecimalFormat</span> <span class="n">df</span> <span class="o">=</span> <span class="o">(</span><span class="nc">DecimalFormat</span><span class="o">)</span> <span class="nc">NumberFormat</span><span class="o">.</span><span class="na">getNumberInstance</span><span class="o">(</span><span class="nc">Locale</span><span class="o">.</span><span class="na">ROOT</span><span class="o">);</span>
<span class="n">df</span><span class="o">.</span><span class="na">setGroupingUsed</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="n">df</span><span class="o">.</span><span class="na">setMinimumFractionDigits</span><span class="o">(</span><span class="n">minFractionDigits</span><span class="o">);</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">df</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="c1">// prints 738790000000000100000</span>

<span class="nc">Formatter</span> <span class="n">fmt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Formatter</span><span class="o">(</span><span class="nc">Locale</span><span class="o">.</span><span class="na">ROOT</span><span class="o">);</span>
<span class="n">fmt</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%."</span> <span class="o">+</span> <span class="n">minFractionDigits</span> <span class="o">+</span> <span class="s">"f"</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fmt</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> <span class="c1">// prints 738790000000000000000</span>
</code></pre></div></div>

<p>This rare situation occurs because <code class="language-plaintext highlighter-rouge">java.util.Formatter</code> and <code class="language-plaintext highlighter-rouge">Double.toString()</code> use an algorithm enhanced in JDK 21.
A fix was introduced in JDK 26 for the <code class="language-plaintext highlighter-rouge">java.text.DecimalFormat</code> implementation to use the same algorithm as <code class="language-plaintext highlighter-rouge">java.util.Formatter</code> and <code class="language-plaintext highlighter-rouge">Double.toString()</code>, thus producing the same outcome.</p>

<p>For a few releases, <code class="language-plaintext highlighter-rouge">java.text.DecimalFormat</code> will still offer the old algorithm to help migrate applications affected by this change. You can enable the old algorithm by appending <code class="language-plaintext highlighter-rouge">-Djdk.compat.DecimalFormat=true</code> to your <code class="language-plaintext highlighter-rouge">java</code> command; otherwise, the new algorithm runs.</p>

<h2 id="call-to-action">Call to Action</h2>

<p>We encourage you to download the <a href="https://jdk.java.net/26/">JDK 26 Early Access builds</a>, evaluate the behavior of your application and prepare to migrate if you see any impact. 
Feedback is also welcomed through the <a href="https://mail.openjdk.org/mailman/listinfo/jdk-dev">jdk-dev mailing list</a> (registration required).
For more details on this change, check the JBS issue <a href="https://bugs.openjdk.org/browse/JDK-8362448">JDK-8362448</a> and the <a href="https://jdk.java.net/26/release-notes">release notes</a>.</p>

<center>~</center>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers that java.text.DecimalFormat formats floating-point values with the Double.toString(double) algorithm.]]></summary></entry><entry><title type="html">Optimizing Java Class Metadata in Project Valhalla</title><link href="https://inside.java/2026/02/07/valhalla-class-metadata-optimization/" rel="alternate" type="text/html" title="Optimizing Java Class Metadata in Project Valhalla" /><published>2026-02-07T00:00:00+00:00</published><updated>2026-02-07T00:00:00+00:00</updated><id>https://inside.java/2026/02/07/valhalla-class-metadata-optimization</id><content type="html" xml:base="https://inside.java/2026/02/07/valhalla-class-metadata-optimization/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;JoelSikstrom&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[In this post, I’ll walk through some of the behind-the-scenes details of one of Project Valhalla’s core features: value classes, and the concept of flattening (or inlining, the term I will use here). Whether you’re a JVM developer or just deeply curious about how Java works under the hood, this technical deep dive is for you.]]></summary></entry><entry><title type="html">The Inside Java Newsletter: JavaOne 2026: $100 Discount Now!</title><link href="https://inside.java/2026/02/06/inside-java-newsletter/" rel="alternate" type="text/html" title="The Inside Java Newsletter: JavaOne 2026: $100 Discount Now!" /><published>2026-02-06T00:00:00+00:00</published><updated>2026-02-06T00:00:00+00:00</updated><id>https://inside.java/2026/02/06/Inside-Java-Newsletter</id><content type="html" xml:base="https://inside.java/2026/02/06/inside-java-newsletter/"><![CDATA[<p><img class="webfeedsFeaturedVisual" src="/images/thumbnail/code.jpg" style="display: none;" /></p>]]></content><author><name>[&quot;JimGrisanzio&quot;]</name></author><category term="Oracle" /><category term="Community" /><summary type="html"><![CDATA[The Inside Java Newsletter for January 2026 includes a special limited-time discount code for JavaOne 2026 registration. Register now and save $100! The JavaOne 2026 keynotes and technical sessions have already been announced, and we’re now completing our final preparations for the conference in March. This issue also highlights the sponsors that will be at JavaOne, technical content from videos and podcasts, learning and community updates, and more from the Java Platform Group. Visit learn.java, dev.java, and inside.java for videos, articles, and other resources for developers, learners, educators, and customers. You can view the newsletter archives, subscribe, and share it with a friend!]]></summary></entry><entry><title type="html">LazyConstants in JDK 26 - Inside Java Newscast #106</title><link href="https://inside.java/2026/02/05/newscast-106/" rel="alternate" type="text/html" title="LazyConstants in JDK 26 - Inside Java Newscast #106" /><published>2026-02-05T00:00:00+00:00</published><updated>2026-02-05T00:00:00+00:00</updated><id>https://inside.java/2026/02/05/Newscast-106</id><content type="html" xml:base="https://inside.java/2026/02/05/newscast-106/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/BZlXZyXA4jY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Lazily initializing fields in Java is error-prone and undermines constant-folding. JDK 26 comes with JEP 526, which previews <code class="language-plaintext highlighter-rouge">LazyConstant</code>, a type that lazily initializes a value through a given <code class="language-plaintext highlighter-rouge">Supplier</code>. It executes that supplier at most once successfully and then assigns the value to a field annotated with <code class="language-plaintext highlighter-rouge">@Stable</code>, which allows constant folding. This API is also a poster child for how OpenJDK develops and evolves features.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=BZlXZyXA4jY">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><summary type="html"><![CDATA[Lazily initializing fields in Java is error-prone and undermines constant-folding. JDK 26 comes with JEP 526, which previews LazyConstant, a type that lazily initializes a value through a given Supplier. It executes that supplier at most once successfully and then assigns the value to a field annotated with @Stable, which allows constant folding. This API is also a poster child for how OpenJDK develops and evolves features.]]></summary></entry><entry><title type="html">Level Up Your LangChain4j Apps for Production</title><link href="https://inside.java/2026/02/01/devoxxbelgium-production-langchain4j/" rel="alternate" type="text/html" title="Level Up Your LangChain4j Apps for Production" /><published>2026-02-01T00:00:00+00:00</published><updated>2026-02-01T00:00:00+00:00</updated><id>https://inside.java/2026/02/01/DevoxxBelgium-Production-Langchain4j</id><content type="html" xml:base="https://inside.java/2026/02/01/devoxxbelgium-production-langchain4j/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/yXuKLPpleBg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This session demonstrates how LangChain4j can help, showcasing a set of often overlooked techniques that keep AI systems on track and unlock more advanced use cases. We explore LangChain4j’s advanced RAG methods for finding all relevant information across documents, databases, APIs, and more, and share practical tips for effective tool calls and responsible MCP usage. You will also see how LangChain4j’s agentic approach lets you decompose complex workflows for greater clarity and control. The presentation wraps up with a guided build of a production-ready agentic system, including the operational and legal considerations that matter once you move beyond PoC.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;LizeRaes&quot;]</name></author><category term="AI" /><summary type="html"><![CDATA[This session demonstrates how LangChain4j can help, showcasing a set of often overlooked techniques that keep AI systems on track and unlock more advanced use cases. We explore LangChain4j’s advanced RAG methods for finding all relevant information across documents, databases, APIs, and more, and share practical tips for effective tool calls and responsible MCP usage. You will also see how LangChain4j’s agentic approach lets you decompose complex workflows for greater clarity and control. The presentation wraps up with a guided build of a production-ready agentic system, including the operational and legal considerations that matter once you move beyond PoC.]]></summary></entry><entry><title type="html">Episode 44 “Java, Collections &amp;amp; Generics, BeJUG”</title><link href="https://inside.java/2026/01/29/podcast-044/" rel="alternate" type="text/html" title="Episode 44 “Java, Collections &amp;amp; Generics, BeJUG”" /><published>2026-01-29T00:00:00+00:00</published><updated>2026-01-29T00:00:00+00:00</updated><id>https://inside.java/2026/01/29/Podcast-044</id><content type="html" xml:base="https://inside.java/2026/01/29/podcast-044/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/ChadMic.jpg?298234975" /></p>

<p><br /></p>

<iframe title="Libsyn Player" style="border: none" src="//html5-player.libsyn.com/embed/episode/id/39908260/height/90/theme/custom/thumbnail/yes/direction/forward/render-playlist/no/custom-color/000000/" height="90" width="100%" scrolling="no"></iframe>

<div class="youtube-embed">
<iframe src="https://www.youtube.com/embed/P4f0FHizUCg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</div>

<p><br /></p>

<p>In this special episode of the Inside Java Podcast, Nicolai Parlog talks to Adam Bien about scripting with Java, to Maurice Naftalin about the history and tradeoffs of the collections framework and erasure, and to Tom Cools about the innovative way the Belgian Java User Group organizes itself.</p>

<p><br />
Make sure to also check the <strong>Duke’s Corner podcast</strong> on <a href="https://dev.java/duke/corner/">dev.java</a>.</p>

<p><br /></p>

<h3 id="additional-resources">Additional resources</h3>

<ul>
  <li><a href="https://inside.java">Inside.java</a> : News and views from members of the Java team at Oracle</li>
  <li><a href="https://dev.java">Dev.java</a> : The Destination for Java Developers</li>
  <li><a href="https://openjdk.java.net/">OpenJDK</a></li>
  <li><a href="https://www.oracle.com/java/">Oracle Java</a></li>
</ul>

<p>For more episodes, check out <a href="https://inside.java/podcast">Inside Java</a>, our <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzV_hXbRevwzrXSMcGNzhxiZ">YouTube playlist</a>, and follow <a href="https://twitter.com/java">@Java</a> on Twitter.</p>

<p>Contact us <a href="https://inside.java/about/">here</a>.</p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="Java Language" /><category term="Community" /><summary type="html"><![CDATA[In this special episode of the Inside Java Podcast, Nicolai Parlog talks to Adam Bien about scripting with Java, to Maurice Naftalin about the history and tradeoffs of the collections framework and erasure, and to Tom Cools about the innovative way the Belgian Java User Group organizes itself.]]></summary></entry><entry><title type="html">Data-Oriented Programming for Java: Beyond Records</title><link href="https://inside.java/2026/01/27/beyond-records/" rel="alternate" type="text/html" title="Data-Oriented Programming for Java: Beyond Records" /><published>2026-01-27T00:00:00+00:00</published><updated>2026-01-27T00:00:00+00:00</updated><id>https://inside.java/2026/01/27/beyond-records</id><content type="html" xml:base="https://inside.java/2026/01/27/beyond-records/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;BrianGoetz&quot;]</name></author><category term="Amber" /><summary type="html"><![CDATA[Records, sealed classes, and destructuring with record patterns constitute the first feature arc of “data-oriented programming” for Java. After considering numerous design ideas, we’re now ready to move forward with the next “data oriented programming” feature arc: carrier classes (and interfaces.)]]></summary></entry><entry><title type="html">Oracle Java Extension for Visual Studio Code Version 25.0.1 Is Now Available!</title><link href="https://inside.java/2026/01/23/java-vscode-extension-update/" rel="alternate" type="text/html" title="Oracle Java Extension for Visual Studio Code Version 25.0.1 Is Now Available!" /><published>2026-01-23T00:00:00+00:00</published><updated>2026-01-23T00:00:00+00:00</updated><id>https://inside.java/2026/01/23/java-vscode-extension-update</id><content type="html" xml:base="https://inside.java/2026/01/23/java-vscode-extension-update/"><![CDATA[<p>New release of Java Platform Extension for VS Code</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/duke-vscode.jpg?292614817" /></p>]]></content><author><name>[&quot;ArvindAprameya&quot;]</name></author><category term="Oracle" /><summary type="html"><![CDATA[New release of Java Platform Extension for VS Code]]></summary></entry><entry><title type="html">Carrier Classes; Beyond Records - Inside Java Newscast #105</title><link href="https://inside.java/2026/01/22/newscast-105/" rel="alternate" type="text/html" title="Carrier Classes; Beyond Records - Inside Java Newscast #105" /><published>2026-01-22T00:00:00+00:00</published><updated>2026-01-22T00:00:00+00:00</updated><id>https://inside.java/2026/01/22/Newscast-105</id><content type="html" xml:base="https://inside.java/2026/01/22/newscast-105/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/cpGceyn7DBE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This episode presents Project Amber lead Brian Goetz’s recent email “Data Oriented Programming, Beyond Records”, wherein he describes plans to improve Java’s data handling capabilities by introducing carrier classes, a generalization of records.</em> 
<em>Like them, carrier classes describe their state through a component list that defines the type’s external API: accessors, a constructor, and matching deconstructor - this allows carrier classes to participate in pattern matching and reconstruction. Unlike records, the implementation of this API remains the developer’s task although component fields offer a shortcut for the common case where the API does map to a field. Carrier classes don’t have to be final (and can hence participate in inheritance) and neither do their fields (so they can be mutable data carriers).</em></p>

<p><em>The email also mentions carrier interfaces, allowing records to be abstract as well as a relaxation of deconstruction patterns that make them more amenable to evolution of the matched type. This episode also briefly touches on Gavin Bierman’s mail to the Project Amber mailing list that announces pattern assignments and constant patterns.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=cpGceyn7DBE">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="Amber" /><summary type="html"><![CDATA[This episode presents Project Amber lead Brian Goetz’s recent email “Data Oriented Programming, Beyond Records”, wherein he describes plans to improve Java’s data handling capabilities by introducing carrier classes, a generalization of records.]]></summary></entry><entry><title type="html">Optimizing GPU Programs from Java using Babylon and HAT</title><link href="https://inside.java/2026/01/19/hat-matmul-gpu/" rel="alternate" type="text/html" title="Optimizing GPU Programs from Java using Babylon and HAT" /><published>2026-01-19T00:00:00+00:00</published><updated>2026-01-19T00:00:00+00:00</updated><id>https://inside.java/2026/01/19/hat-matmul-gpu</id><content type="html" xml:base="https://inside.java/2026/01/19/hat-matmul-gpu/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;JuanFumero&quot;]</name></author><category term="Babylon" /><summary type="html"><![CDATA[The Heterogeneous Accelerator Toolkit (HAT) is a parallel programming framework that allows Java developers to offload Java code and dispatch the generated code on modern hardware accelerators, such as Graphics Processing Units (GPUs). This article provides an overview of the HAT programming model: using matrix-multiplication as an example, we demonstrate how Java developers can tune GPU workloads from the Java side to achieve performance close to native cuBLAS, scaling from 7 GFLOP/s on CPUs to 14 TFLOP/s on an NVIDIA A10 GPU.]]></summary></entry></feed>