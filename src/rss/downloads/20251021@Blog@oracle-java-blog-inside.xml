<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-10-21T07:27:53+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Assembling Project Leyden #JVMLS</title><link href="https://inside.java/2025/10/21/jvmls-assembling-project-leyden/" rel="alternate" type="text/html" title="Assembling Project Leyden #JVMLS" /><published>2025-10-21T00:00:00+00:00</published><updated>2025-10-21T00:00:00+00:00</updated><id>https://inside.java/2025/10/21/JVMLS-Assembling-Project-Leyden</id><content type="html" xml:base="https://inside.java/2025/10/21/jvmls-assembling-project-leyden/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/fiBNDT9r_4I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Two years ago John Rose stood here at JVMLS and unveiled the Project Leyden prototype efforts the team had been developing.</em> 
<em>Since then, Leyden has delivered JEPs in both JDK 24 and JDK 25.</em> 
<em>These early building blocks provide a foundation to continue assembling new AOT features.</em> 
<em>And speaking of assembly, let’s deep dive into how and when the AOTCache gets created.</em> 
<em>We’ll also touch on what’s next in the Leyden pipeline and look at some of the areas of future exploration as well as discuss some of the surprising learnings from the team along the way.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;DanHeidinga&quot;]</name></author><category term="Leyden" /><category term="Performance" /><summary type="html"><![CDATA[Two years ago John Rose stood here at JVMLS and unveiled the Project Leyden prototype efforts the team had been developing. Since then, Leyden has delivered JEPs in both JDK 24 and JDK 25. These early building blocks provide a foundation to continue assembling new AOT features. And speaking of assembly, let's deep dive into how and when the AOTCache gets created. We'll also touch on what's next in the Leyden pipeline and look at some of the areas of future exploration as well as discuss some of the surprising learnings from the team along the way.]]></summary></entry><entry><title type="html">Performance Improvements in JDK 25</title><link href="https://inside.java/2025/10/20/jdk-25-performance-improvements/" rel="alternate" type="text/html" title="Performance Improvements in JDK 25" /><published>2025-10-20T00:00:00+00:00</published><updated>2025-10-20T00:00:00+00:00</updated><id>https://inside.java/2025/10/20/JDK-25-Performance-Improvements</id><content type="html" xml:base="https://inside.java/2025/10/20/jdk-25-performance-improvements/"><![CDATA[<p>In this article, we’ll take a walk through some of the many notable 
performance improvements and features in JDK 25. This is by no means exhaustive: JDK 25 comes with more than 3.200 issues fixed, 
of which almost a thousand were enhancements. About a hundred of these have been explicitly labeled as performance-related. 
We group the improvements into JDK Libraries, Garbage Collectors, Compiler, and Runtime, and list improvements in no particular order.</p>

<h2 id="enhancements-in-jdk-libraries">Enhancements in JDK Libraries</h2>

<h3 id="jep-506-scoped-values"><a href="https://openjdk.org/jeps/506">JEP 506</a>: Scoped Values</h3>

<p>The scoped values API was added as a preview feature in JDK 21 and has 
now been finalized in JDK 25.</p>

<p>Scoped values provide a novel mean to 
pass implicit parameters to any method transitively called via a 
<code class="language-plaintext highlighter-rouge">ScopedValue</code>. This may be used to improve performance and flexibility in 
applications that use <code class="language-plaintext highlighter-rouge">ThreadLocal</code> to similar effects today, as it allows robust 
and performant sharing of data across a large number of threads.
Instead of duplicating state per thread in an error-prone way, the new mechanism 
allows shared access across any number of threads. This scales better because it has less memory overhead 
(no per-thread copies) and lower synchronization cost. ScopedValues can be
especially beneficial when used in conjunction with virtual threads 
and structured concurrency.</p>

<p>Structured concurrency was first previewed in JDK 21 and is still a preview API in
JDK 25 (see <a href="https://openjdk.org/jeps/505">JEP 505</a>). Among the updates for JDK 25 is that the API 
now neatly handles scoped values such that child tasks inherit scoped values:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ScopedValue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">NAME</span> <span class="o">=</span> <span class="nc">ScopedValue</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

    <span class="nc">ScopedValue</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="no">NAME</span><span class="o">,</span> <span class="s">"duke"</span><span class="o">).</span><span class="na">run</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">open</span><span class="o">())</span> <span class="o">{</span>

            <span class="c1">// each child task can retrieve "duke" from NAME</span>
            <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">childTask1</span><span class="o">());</span>
            <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">childTask2</span><span class="o">());</span>
            <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">childTask3</span><span class="o">());</span>

            <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
             <span class="o">..</span>
        <span class="o">}</span>
    <span class="o">});</span>
</code></pre></div></div>

<p>Nicolai Parlog recently covered this feature and much more in his talk at Devoxx Belgium 2025, <a href="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/">Structured Concurrency in Action</a></p>

<h3 id="jdk-8354300-mark-stringhash-field-stable"><a href="https://bugs.openjdk.org/browse/JDK-8354300">JDK-8354300</a> Mark String.hash field @Stable</h3>

<p>In JDK 25, <code class="language-plaintext highlighter-rouge">String</code> <a href="https://github.com/openjdk/jdk/pull/24625">was improved</a> to make the <code class="language-plaintext highlighter-rouge">String::hashCode</code> function
<a href="https://en.wikipedia.org/wiki/Constant_folding">constant foldable</a>. This might lead to significant performance improvements in some common scenarios,
such as using <code class="language-plaintext highlighter-rouge">String</code> constants as keys in a constant, unmodifiable <code class="language-plaintext highlighter-rouge">Map</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Foo</span><span class="o">&gt;</span> <span class="no">MAP</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"constant"</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="o">...);</span>
        
<span class="no">MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"constant"</span><span class="o">).</span><span class="na">foo</span><span class="o">();</span>
</code></pre></div></div>

<p>In this scenario, constant folding means the JIT can skip the map lookup entirely, replacing the lookup with a direct call to <code class="language-plaintext highlighter-rouge">value.foo()</code> or better. In a targeted microbenchmark such as <a href="https://github.com/openjdk/jdk/blob/072b827/test/micro/org/openjdk/bench/java/lang/StringHashCodeStatic.java#L67">StringHashCodeStatic.nonZero</a>
this brings us about an <strong>8x speed-up</strong>.</p>

<p>In <a href="https://inside.java/2025/05/01/strings-just-got-faster/">this article</a> you can 
read more about the benchmark and additional implementation details. In short, 
the hash code for the string is now stored in a field that is marked with the 
internal <code class="language-plaintext highlighter-rouge">@Stable</code> annotation. This allows the JIT compiler to trust and constant 
fold the value if it is no longer the default zero value. While <code class="language-plaintext highlighter-rouge">@Stable</code> annotation is JDK-internal,
a general-purpose approach is on the way through the next feature of our article.</p>

<h3 id="jep-502-stable-values-preview"><a href="https://openjdk.org/jeps/502">JEP 502</a>: Stable Values (Preview)</h3>

<p>Using the <code class="language-plaintext highlighter-rouge">StableValue</code> API (previewed in JDK 25), anyone can declare a lazy constant that is implicitly
<em>stable</em>, which means the JVM will treat it as a constant once a value has been lazily
computed. Computation is done using a computing function provided  at declaration time, and the constant is
cached in a <code class="language-plaintext highlighter-rouge">Supplier</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Logger</span><span class="o">&gt;</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">StableValue</span><span class="o">.</span><span class="na">supplier</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="nc">OrderController</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>

    <span class="kt">void</span> <span class="nf">submitOrder</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order started"</span><span class="o">);</span>
        <span class="o">...</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order submitted"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In the example above, the field <code class="language-plaintext highlighter-rouge">logger</code> is of type <code class="language-plaintext highlighter-rouge">Supplier&lt;Logger&gt;</code>, but, 
at construction, no constant is yet initialized. 
When we invoke <code class="language-plaintext highlighter-rouge">logger.get()</code> the first time, the underlying computing 
function, <code class="language-plaintext highlighter-rouge">() -&gt; Logger.create(OrderController.class)</code>, is evaluated, 
causing the constant to be initialized.</p>

<p>Once the constant is initialized, the JIT compiler can trust that the 
constant will never change and is thus free to omit further 
reads of the constant, i.e., constant folding. This technique can 
provide significant performance improvements, including eliminating 
code. Effectively, this has the same impact as the <code class="language-plaintext highlighter-rouge">@Stable</code> annotation
available in internal JDK code, but made available to library and application 
developers in a safe and enforced manner.</p>

<p>It’s prudent to note that preview APIs are subject to change. At the time of 
writing <code class="language-plaintext highlighter-rouge">StableValue</code> is set to be renamed to <code class="language-plaintext highlighter-rouge">LazyConstant</code> in JDK 26.</p>

<h3 id="jdk-8345687-improve-the-implementation-of-segmentfactoriesallocatesegment"><a href="https://bugs.openjdk.org/browse/JDK-8345687">JDK-8345687</a> Improve the Implementation of SegmentFactories::allocateSegment</h3>

<p>This Panama Foreign Function and Memory (FFM) enhancement speeds up allocating
native memory segments by up to 2x. This is achieved by explicitly aligning
memory, avoiding unnecessary merges and object allocation, improving zeroing, 
and a few other tricks.
Better handling of shared memory in the <code class="language-plaintext highlighter-rouge">java.lang.foreign</code> component means 
better performance when interoperating with native libraries. FFM was finalized 
in JDK 22 with the delivery of <a href="https://openjdk.org/jeps/454">JEP 454</a> and brings a promise of simplifying 
native integration while outperforming JNI. Per has blogged about this in more 
depth <a href="https://minborgsjavapot.blogspot.com/2023/08/java-22-panama-ffm-provides-massive.html">here</a>.</p>

<h3 id="jdk-8354674-aarch64-intrinsify-unsafesetmemory"><a href="https://bugs.openjdk.org/browse/JDK-8354674">JDK-8354674</a> AArch64: Intrinsify Unsafe::setMemory</h3>

<p>This enhancement added an intrinsic to speed up <code class="language-plaintext highlighter-rouge">Unsafe::setMemory</code>, which is an API commonly used in I/O, 
desktop and Foreign Function and Memory(FFM) APIs. The supplied microbenchmark showcases a ~2.5x speed-up when writing chunks of 
data using <code class="language-plaintext highlighter-rouge">java.lang.foreign.MemorySegment::fill</code>.</p>

<h3 id="added-intrinsics-for-ml-kem-and-ml-dsa-api">Added Intrinsics for ML-KEM and ML-DSA API</h3>

<p>JDK 24 added Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism, or ML-KEM (<a href="https://openjdk.org/jeps/496">JEP 496</a>),
and Quantum-Resistant Module-Lattice-Based Digital Signature Algorithm, or ML-DSA (<a href="https://openjdk.org/jeps/497">JEP 497</a>).</p>

<p>In JDK 25, the performance of many of these new APIs has doubled on AArch64 and Intel AVX-512 platforms thanks to specialized intrinsics. This puts the OpenJDK roughly on par with OpenSSL for many of these security operations on modern hardware.</p>

<ul>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8349721">JDK-8349721</a> Add aarch64 intrinsics for ML-KEM</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8351412">JDK-8351412</a> Add AVX-512 intrinsics for ML-KEM</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8348561">JDK-8348561</a> Add aarch64 intrinsics for ML-DSA</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8351034">JDK-8351034</a> Add AVX-512 intrinsics for ML-DSA</li>
</ul>

<h3 id="jdk-8350748-vectorapi-method-checkmaskfromindexsize-should-be-force-inlined"><a href="https://bugs.openjdk.org/browse/JDK-8350748">JDK-8350748</a> VectorAPI: Method “checkMaskFromIndexSize” Should Be Force Inlined</h3>

<p>In low-level libraries, fine-tuning how the JIT inlines can help ensure that some critical optimizations occur as expected. 
This enhancement addresses such an issue in the Vector API by forcing inlining to happen at a critical place, leading to a
<strong>14x speed-up</strong> on targeted benchmarks.</p>

<h3 id="jdk-8350493-improve-performance-of-delayed-task-handling"><a href="https://bugs.openjdk.org/browse/JDK-8350493">JDK-8350493</a> Improve Performance of Delayed Task Handling</h3>

<p>The <code class="language-plaintext highlighter-rouge">java.util.concurrent.ForkJoinPool</code> was updated to implement <code class="language-plaintext highlighter-rouge">ScheduledExecutorService</code> to better deal with delayed tasks.</p>

<p>This major overhaul removes some locking-related bottlenecks and notably improves the performance of canceling delayed tasks (such 
as timeout handlers). Added some convenient methods such as <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ForkJoinPool.html#submitWithTimeout(java.util.concurrent.Callable,long,java.util.concurrent.TimeUnit,java.util.function.Consumer)">submitWithTimeout</a> too!</p>

<h3 id="other-jdk-library-performance-enhancements-and-bug-fixes">Other JDK Library Performance Enhancements and Bug Fixes</h3>

<ul>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8356709">JDK-8356709</a> Avoid redundant <code class="language-plaintext highlighter-rouge">String</code> formatting in <code class="language-plaintext highlighter-rouge">BigDecimal.valueOf(double)</code></p>

    <p>Gives a <strong>6-9x speed-up</strong> of <code class="language-plaintext highlighter-rouge">BigDecimal.valueOf</code> for typical inputs.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8353686">JDK-8353686</a> Optimize <code class="language-plaintext highlighter-rouge">Math.cbrt</code> for x86 64 bit platforms</p>

    <p>Together with a follow-up fix (<a href="https://bugs.openjdk.org/browse/JDK-8358179">JDK-8358179</a>) this x86 enhancement brings a <strong>3x speed-up</strong> to <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#cbrt(double)">Math.cbrt</a> (cubic root).
A similar change was attempted on AArch64 but failed to show any benefit there.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8357690">JDK-8357690</a> Add <code class="language-plaintext highlighter-rouge">@Stable</code> and <code class="language-plaintext highlighter-rouge">final</code> to <code class="language-plaintext highlighter-rouge">java.lang.CharacterDataLatin1</code> and other <code class="language-plaintext highlighter-rouge">CharacterData</code> classes</p>

    <p>While currently unclear if this has any effects in the wild this could conceivably make some code constant foldable.</p>
  </li>
</ul>

<h2 id="garbage-collection-improvements">Garbage Collection Improvements</h2>

<h3 id="jep-521-generational-shenandoah"><a href="https://openjdk.org/jeps/521">JEP 521</a> Generational Shenandoah</h3>

<p>The generational mode of the Shenandoah garbage collector, introduced in JDK 24, has transitioned to a product feature in JDK 25.</p>

<h3 id="jdk-8350441-zgc-overhaul-page-allocation"><a href="https://bugs.openjdk.org/browse/JDK-8350441">JDK-8350441</a> ZGC: Overhaul Page Allocation</h3>

<p>This major ZGC enhancement replaces the Page Cache in ZGC with a Mapped Cache, which improves how ZGC manages unused
allocated memory. Implemented as a self-balancing binary search tree of contiguous memory ranges, the Mapped Cache
merges memory ranges on insertion. Among other things, this reduces heap memory fragmentation.
Another consequence of the overhaul is that ZGC no longer uses multi-mapped memory, which means that reported RSS usage 
will no longer look artificially inflated.</p>

<p>Joel Sikström has authored a comprehensive deep-dive about how ZGC allocates and manages memory with this large overhaul in focus here: <a href="https://joelsiks.com/posts/zgc-heap-memory-allocation/">How ZGC allocates memory for the Java heap</a>.</p>

<h3 id="jdk-8343782-g1-use-one-g1cardset-instance-for-multiple-old-gen-regions"><a href="https://bugs.openjdk.org/browse/JDK-8343782">JDK-8343782</a> G1: Use One G1CardSet Instance for Multiple Old Gen Regions</h3>

<p>This one allows G1 to merge any old generation region’s <a href="https://docs.oracle.com/en/java/javase/24/gctuning/garbage-first-g1-garbage-collector1.html#GUID-1CDEB6B6-9463-4998-815D-05E095BFBD0F">remembered set</a> 
with others, unlocking memory savings. On one GC stress test referenced in the <a href="https://git.openjdk.org/jdk/pull/22015">PR</a>, this reduces the peak memory used by 
remembered sets from 2Gb to 0.75Gb on a JVM with a 64GB heap. Or roughly 2% of the process total:</p>

<p><img alt="Plot of memory reserved by G1 remembered sets before and after the change, showing a roughly 60% decrease at peak." src="/images/performance/g1-groupcardsets.png" size="70%" /></p>

<h3 id="jdk-8351405-g1-collection-set-early-pruning-causes-suboptimal-region-selection"><a href="https://bugs.openjdk.org/browse/JDK-8351405">JDK-8351405</a> G1: Collection Set Early Pruning Causes Suboptimal Region Selection</h3>

<p>G1 will now better estimate the cost of collecting regions during Mixed GCs and skip those that would significantly impact pause times. The result is reduced pause time spikes, particularly toward the end of a Mixed GC cycle, improving overall application performance.
Thomas Schatzl has written in-depth about these and other GC changes on his blog: JDK 25 G1/Parallel/Serial GC changes.</p>

<h3 id="jdk-8357443-zgc-optimize-old-page-iteration-in-remap-remembered-phase"><a href="https://bugs.openjdk.org/browse/JDK-8357443">JDK-8357443</a> ZGC: Optimize Old Page Iteration in Remap Remembered Phase</h3>

<p>This enhancement leverages a pre-existing optimization to find all old pages without scanning the entire page table, 
speeding up significant collections when many pages don’t need to be considered for collection.</p>

<p>While likely a modest improvement on typical usage, this can lead to significant speed-ups in some corner cases, 
such as when you manually trigger significant collections (e.g., using <code class="language-plaintext highlighter-rouge">System.gc()</code>) on large but relatively empty heaps. 
The <a href="https://github.com/openjdk/jdk/pull/25345">PR</a> shows speed-ups of up to <strong>20x</strong> on a 4GB heap, and up to <strong>900x</strong> 
on a 16TB heap for the worst-case setup.</p>

<h2 id="compiler-improvements">Compiler Improvements</h2>

<h3 id="jdk-8343685-c2-superword-refactor-vpointer-with-mempointer"><a href="https://bugs.openjdk.org/browse/JDK-8343685">JDK-8343685</a> C2 SuperWord: Refactor VPointer with MemPointer</h3>

<p>Part of a larger effort to improve auto-vectorization in C2. This is a technique where plain Java code is transformed 
by the JIT to use SIMD instructions, which can allow for large speed-ups.</p>

<p>This enhancement makes more patterns eligible for such optimization to great effect. 
In a <a href="https://www.youtube.com/watch?v=UVsevEdYSwI">recent talk</a> at JVMLS, Emanuel Peter casually mentions how 
this snippet of code runs <strong>33 times faster</strong> after this enhancement:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">a</span><span class="o">.</span><span class="na">byteSize</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">byte</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">ValueLayout</span><span class="o">.</span><span class="na">JAVA_BYTE</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">invarL</span><span class="o">);</span>
    <span class="n">a</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="nc">ValueLayout</span><span class="o">.</span><span class="na">JAVA_BYTE</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">invarL</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Emanuel has blogged extensively on auto-vectorization in the C2 compiler and 
<a href="https://eme64.github.io/blog/2023/02/23/SuperWord-Introduction.html">this introduction</a> might be a good starting point 
for a deep dive.</p>

<h3 id="jdk-8307513-c2-intrinsify-mathmaxlonglong-and-mathminlonglong"><a href="https://bugs.openjdk.org/browse/JDK-8307513">JDK-8307513</a> C2: Intrinsify <code class="language-plaintext highlighter-rouge">Math.max(long,long)</code> and <code class="language-plaintext highlighter-rouge">Math.min(long,long)</code></h3>

<p>This is another auto-vectorization improvement referenced in Emanuel’s Peter JVMLS talk. By giving some special treatment 
to <code class="language-plaintext highlighter-rouge">Math.max</code> and <code class="language-plaintext highlighter-rouge">Math.min</code>, those operations can be considered for auto-vectorization by C2.</p>

<p>In a clipping variant (which combines both <code class="language-plaintext highlighter-rouge">Math.min</code> and <code class="language-plaintext highlighter-rouge">Math.max</code>) in the provided <a href="https://github.com/openjdk/jdk/blob/4e51a8c9ad4e5345d05cf32ce1e82b7158f80e93/test/micro/org/openjdk/bench/java/lang/MinMaxVector.java">MinMaxVector</a> 
microbenchmark, we see <strong>3-5x</strong> speed-ups on a range of platforms:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Benchmark</span>
<span class="kd">public</span> <span class="kt">long</span><span class="o">[]</span> <span class="nf">longClippingRange</span><span class="o">(</span><span class="nc">RangeState</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">.</span><span class="na">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">state</span><span class="o">.</span><span class="na">resultLongs</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">longs</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">state</span><span class="o">.</span><span class="na">lowestLong</span><span class="o">),</span> <span class="n">state</span><span class="o">.</span><span class="na">highestLong</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">resultLongs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Improving auto-vectorization allows clearly written, plain Java code to take advantage 
of SIMD capabilities on modern CPUs.</p>

<h3 id="jdk-8347405-mergestores-with-reverse-bytes-order-value"><a href="https://bugs.openjdk.org/browse/JDK-8347405">JDK-8347405</a> MergeStores with Reverse Bytes Order Value</h3>

<p>In JDK 23, C2 was enhanced with a merge store optimization, which allows merging byte-by-byte stores into wider primitives in an efficient way. In JDK 25, this is further enhanced to enable such merges to happen also when bytes are stored in the reversed order. For example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">patchInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">elems</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">elems</span><span class="o">;</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="o">);</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="o">);</span>
    <span class="n">elems</span><span class="o">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Focused microbenchmarks have seen up to a <em>4x</em> speed-up on such code.</p>

<p>On typical <a href="https://en.wikipedia.org/wiki/Endianness">little-endian systems</a>, such as Intel x64 or Aarch64, this means Java may emit data in network order (big-endian) at significantly greater speed than before.</p>

<h3 id="jdk-8346664-c2-optimize-mask-check-with-constant-offset"><a href="https://bugs.openjdk.org/browse/JDK-8346664">JDK-8346664</a> C2: Optimize Mask Check with Constant Offset</h3>

<p>This enhancement improves mask checks such as <code class="language-plaintext highlighter-rouge">((index + offset) &amp; mask) == 0</code> when <code class="language-plaintext highlighter-rouge">offset</code> is constant. This enables more constant folding of some relatively common low-level expressions.
While this was found and implemented to help specific Panama workloads, the optimization is generic and low-level.</p>

<p>Here’s a microbenchmark adapted from the one in the <a href="https://github.com/openjdk/jdk/pull/22856#issuecomment-2601757857">PR</a> to avoid use of <code class="language-plaintext highlighter-rouge">java.lang.foreign</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">4711</span> <span class="o">&lt;&lt;</span> <span class="mi">3L</span><span class="o">;</span>

    <span class="nd">@Benchmark</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">itsOver9000</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(((</span><span class="n">address</span> <span class="o">+</span> <span class="o">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3L</span><span class="o">))</span> <span class="o">&amp;</span> <span class="mi">7L</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>Since these expressions can now properly constant fold, the JIT goes above and beyond. It sees that the check will always be true and ends up optimizing away the entire loop. 
Result: <strong>10,000x faster</strong>.</p>

<p>The fastest code will always be the code we don’t have to run at all!</p>

<h3 id="other-compiler-performance-enhancements-and-bug-fixes">Other Compiler Performance Enhancements and Bug Fixes</h3>

<ul>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8353359">JDK-8353359</a> C2: <code class="language-plaintext highlighter-rouge">Or(I|L)Node::Ideal</code> is missing <code class="language-plaintext highlighter-rouge">AddNode::Ideal</code> call</p>

    <p>This fixes a regression introduced in JDK 21 where expressions such as <code class="language-plaintext highlighter-rouge">(a | 3) | 6</code> no longer constant folded as expected.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8353041">JDK-8353041</a> NeverBranchNode causes incorrect block frequency calculation</p>

    <p>Fixes an issue where performance of infinite loops could be adversely affected.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8317976">JDK-8317976</a> Optimize SIMD sort for AMD Zen 4</p>

    <p>Makes sure AMD Zen 4 and later processors use appropriate optimized array sort routines.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8351414">JDK-8351414</a> C2: MergeStores must happen after RangeCheck smearing</p>

    <p>Improves some cases where the aforementioned merge store optimization interacted poorly with another optimization by separating the optimization to a separate pass.</p>
  </li>
</ul>

<h2 id="runtime-improvements">Runtime Improvements</h2>

<h3 id="jep-515-ahead-of-time-method-profiling"><a href="https://openjdk.org/jeps/515">JEP 515</a> Ahead-of-Time Method Profiling</h3>

<p><a href="https://openjdk.org/projects/leyden/">Project Leyden</a> aims to improve startup and warmup of Java applications while imposing as few limitations as possible. 
This is achieved by recording what an application is doing during a training run and saving that to an 
Ahead-of-Time cache for subsequent runs.</p>

<p>The AOT cache, introduced via <a href="https://openjdk.org/jeps/483">JEP 483</a> in JDK 24, was extended in JDK 25 by 
<a href="https://openjdk.org/jeps/515">JEP 515</a> to be able to collect method profiles during training runs. This enables the 
JVM to generate optimized native code immediately upon application startup, rather than having to wait for profiles to 
be collected. Hence, the warmup time is improved.</p>

<p>Some example programs start up 15-25% faster with this feature, compared to JDK 24 running a similarly trained application.</p>

<p>With this enhancement and <a href="https://openjdk.org/jeps/514">JEP 514: Ahead-of-Time Command-Line Ergonomics</a> delivered in JDK 25, 
Project Leyden is coming along nicely.</p>

<h3 id="jep-519-compact-object-headers"><a href="https://openjdk.org/jeps/519">JEP 519</a>: Compact Object Headers</h3>

<p>Compact object headers were added as an experimental feature in JDK 24 and have now been promoted to a product feature.</p>

<p>When enabled with <code class="language-plaintext highlighter-rouge">-XX:+UseCompactObjectHeaders</code>, all objects on the heap shrink by 4 bytes, typically. This adds up to 
substantial heap savings, and many benchmarks and real-world applications see significant speed-ups as a result due to 
improved cache locality and reduced GC activity.</p>

<p>Users are strongly encouraged to try this out and provide feedback. We are considering turning it on by default in a
future release.</p>

<h3 id="various-interpreter-improvements">Various Interpreter Improvements</h3>

<ul>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8356946">JDK-8356946</a> x86: Optimize Interpreter Profile Updates</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8357223">JDK-8357223</a> AAarch64: Optimize Interpreter Profile Updates</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8357434">JDK-8357434</a> x86: Simplify Interpreter::profile_taken_branch</li>
</ul>

<p>Together, these improvements significantly enhance how the interpreter updates profile counters. During startup and warmup, 
the bytecode interpreter profiles which methods and branches are used, which informs the JVM on what to compile and how. 
The act of updating these counters can be noticeable during application startup and warmup.</p>

<p>In isolation, such optimizations are often lost in the noise, but over a release, they can and do add up. 
Going from JDK 24 to 25, the time to run a simple “Hello World!” has dropped from ~28.7ms to ~25.5ms in JDK 25. A neat 12% speed-up right off the bat.</p>

<p>While users of Project Leyden may unlock greater wins at scale, we think it’s great to see measurable improvements for free.</p>

<h3 id="other-runtime-performance-enhancements-and-bug-fixes">Other Runtime Performance Enhancements and Bug Fixes</h3>

<ul>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8355646">JDK-8355646</a>: Optimize ObjectMonitor::exit</p>

    <p>This synchronization improvement allows us to immediately unpark waiting threads without releasing and reacquiring a
lock. This reduces latency on some lightly contended locks.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8348402">JDK-8348402</a> PerfDataManager stalls shutdown for 1ms</p>

    <p>Getting rid of a small sleep during JVM shutdown, for one. Good for all the short-running command line tools, build systems, etc.</p>
  </li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8241678">JDK-8241678</a> Remove PerfData sampling via StatSampler</p>

    <p>A nice cleanup removing a periodically running task</p>
  </li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8353273">JDK-8353273</a> Reduce number of oop map entries in instances</li>
  <li><a href="https://bugs.openjdk.org/browse/JDK-8354560">JDK-8354560</a> Exponentially delay subsequent native thread creation in case of EAGAIN</li>
  <li>
    <p><a href="https://bugs.openjdk.org/browse/JDK-8352075">JDK-8352075</a> Perf regression accessing fields</p>

    <p>Fixes an issue from JDK 21 which could cause significant interpreter slowdowns on classes with many fields.</p>
  </li>
</ul>

<h2 id="thats-all-folks">That’s All, Folks!</h2>

<p>JDK 25 has been generally available for a while now, so don’t hesitate to try it out. If you would like to learn how JDK 25 compares to JDK 21 in terms of performance, we also recommend the session <a href="https://inside.java/2025/10/18/devoxxbelgium-java-performance-update/">From JDK 21 to JDK 25 - Java Performance Update 2025</a> presented at Devoxx Belgium 2025.</p>

<p>As you test and migrate your applications, measure how your application performs on JDK 25 versus your current JDK.
Did you notice anything that might have regressed? Get involved in the community and let us know! Join and raise an issue on the relevant <a href="https://mail.openjdk.org/">mailing list</a>.</p>

<p>We are already looking at a healthy set of improvements in the upcoming JDK 26 release and look forward to writing about those in some detail in spring 2026.</p>

<p>Until then… Stay on the fast path!</p>]]></content><author><name>[&quot;ClaesRedestad&quot;, &quot;Per-AkeMinborg&quot;]</name></author><category term="JDK 25" /><category term="Performance" /><summary type="html"><![CDATA[Java is constantly evolving with ever increasing performance. JDK 25 comes with significant performance improvements compared to previous versions including scoped values, improved GCs, lots of compiler improvements, and much more.]]></summary></entry><entry><title type="html">From JDK 21 to JDK 25 - Java Performance Update 2025</title><link href="https://inside.java/2025/10/18/devoxxbelgium-java-performance-update/" rel="alternate" type="text/html" title="From JDK 21 to JDK 25 - Java Performance Update 2025" /><published>2025-10-18T00:00:00+00:00</published><updated>2025-10-18T00:00:00+00:00</updated><id>https://inside.java/2025/10/18/DevoxxBelgium-Java-Performance-Update</id><content type="html" xml:base="https://inside.java/2025/10/18/devoxxbelgium-java-performance-update/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/223_7r0H6OE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>JDK 25 has just been released and is packed with performance improvements compared to JDK 21, allowing your unchanged application code to run even faster.</em></p>

<p><em>In this talk, we will take a closer look at 13 concrete performance improvements made between JDK 21 and JDK 25 involving both the standard Java libraries, the JIT compiler, and the garbage collectors.</em> 
<em>Among these improvements is the newly introduced <code class="language-plaintext highlighter-rouge">Stable Value</code> preview feature, which allows a field to share the benefits of both mutable and immutable fields simultaneously.</em> 
<em>We will learn how this new feature works, how much performance can be improved, and how your code can take advantage of it already today.</em>
<em>We will also explore some of the design considerations made, the importance of developer feedback, and how the JDK engineers evaluate performance in a world of conflicting optimization criteria and varying platform properties.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;Per-AkeMinborg&quot;]</name></author><category term="JDK 25" /><category term="Performance" /><summary type="html"><![CDATA[JDK 25 has just been released and is packed with performance improvements compared to JDK 21, allowing your unchanged application code to run even faster.In this talk, we will take a closer look at 13 concrete performance improvements made between JDK 21 and JDK 25 involving both the standard Java libraries, the JIT compiler, and the garbage collectors. Among these improvements is the newly introduced 'Stable Value' preview feature, which allows a field to share the benefits of both mutable and immutable fields simultaneously. We will learn how this new feature works, how much performance can be improved, and how your code can take advantage of it already today.We will also explore some of the design considerations made, the importance of developer feedback, and how the JDK engineers evaluate performance in a world of conflicting optimization criteria and varying platform properties.]]></summary></entry><entry><title type="html">What’s New in Java 25 in 2 Minutes - Sip of Java</title><link href="https://inside.java/2025/10/17/new-in-jdk-25-2-mins/" rel="alternate" type="text/html" title="What’s New in Java 25 in 2 Minutes - Sip of Java" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>https://inside.java/2025/10/17/new-in-jdk-25-2-mins</id><content type="html" xml:base="https://inside.java/2025/10/17/new-in-jdk-25-2-mins/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/lCNNA1erCfk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p>JDK 25 was released on September 16th, and with it came 18 JEPs (JDK Enhancement Proposals), many of them being final features. Let’s quickly review the major changes that came in JDK 25!</p>

<h2 id="new-features">New Features</h2>

<p>11 JEPs introduced or finalized new features in JDK 25.</p>

<h3 id="jep-506---scoped-values">JEP 506 - Scoped Values</h3>

<p>The second major feature from <a href="https://openjdk.org/projects/loom/">Project Loom</a>, <a href="https://openjdk.org/jeps/506">Scoped Values</a> are an immutable value that is available within a specific scope of an application. They can be useful for providing contextual information, similar to <code class="language-plaintext highlighter-rouge">ThreadLocal</code>, though aren’t a direct replacement for them.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Framework</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ScopedValue</span><span class="o">&lt;</span><span class="nc">FrameworkContext</span><span class="o">&gt;</span> <span class="no">CONTEXT</span>
                        <span class="o">=</span> <span class="nc">ScopedValue</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>    

    <span class="kt">void</span> <span class="nf">serve</span><span class="o">(</span><span class="nc">Request</span> <span class="n">request</span><span class="o">,</span> <span class="nc">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="o">=</span> <span class="n">createContext</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="n">where</span><span class="o">(</span><span class="no">CONTEXT</span><span class="o">,</span> <span class="n">context</span><span class="o">)</span>                         
                   <span class="o">.</span><span class="na">run</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Application</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">PersistedObject</span> <span class="nf">readKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="o">=</span> <span class="no">CONTEXT</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>                    
        <span class="kt">var</span> <span class="n">db</span> <span class="o">=</span> <span class="n">getDBConnection</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">db</span><span class="o">.</span><span class="na">readKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-510---key-derivation-function-api">JEP 510 - Key Derivation Function API</h3>

<p>The <a href="https://openjdk.org/jeps/510">Key Derivation Function (KDF) API</a> is a final feature in JDK 25, after previewing in JDK 24. The KDF API allows for the creation of additional keys from a secret key and other data. The sample code below demonstrates how to use the KDF API.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a KDF object for the specified algorithm</span>
<span class="no">KDF</span> <span class="n">hkdf</span> <span class="o">=</span> <span class="no">KDF</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HKDF-SHA256"</span><span class="o">);</span> 

<span class="c1">// Create an ExtractExpand parameter specification</span>
<span class="nc">AlgorithmParameterSpec</span> <span class="n">params</span> <span class="o">=</span>
    <span class="nc">HKDFParameterSpec</span><span class="o">.</span><span class="na">ofExtract</span><span class="o">()</span>
                     <span class="o">.</span><span class="na">addIKM</span><span class="o">(</span><span class="n">initialKeyMaterial</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">addSalt</span><span class="o">(</span><span class="n">salt</span><span class="o">).</span><span class="na">thenExpand</span><span class="o">(</span><span class="n">info</span><span class="o">,</span> <span class="mi">32</span><span class="o">);</span>

<span class="c1">// Derive a 32-byte AES key</span>
<span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">hkdf</span><span class="o">.</span><span class="na">deriveKey</span><span class="o">(</span><span class="s">"AES"</span><span class="o">,</span> <span class="n">params</span><span class="o">);</span>

<span class="c1">// Additional deriveKey calls can be made with the same KDF object</span>
</code></pre></div></div>

<h3 id="jep-511---module-import-declarations">JEP 511 - Module Import Declarations</h3>

<p><a href="https://openjdk.org/jeps/511">Module Import Declarations</a> allow for the importing of all the exported API of a module in a single line with <code class="language-plaintext highlighter-rouge">import module [module name]</code> like in the example above.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>

<span class="nc">String</span><span class="o">[]</span> <span class="n">fruits</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"berry"</span><span class="o">,</span> <span class="s">"citrus"</span> <span class="o">};</span>

<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span>
    <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">fruits</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> 		<span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">().</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">()));</span>
</code></pre></div></div>

<p>If you are importing multiple modules that contain the same class name, like <code class="language-plaintext highlighter-rouge">Date</code> in the above example, you can resolve the conflict by explicitly importing the class <code class="language-plaintext highlighter-rouge">java.sql.Date</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>      <span class="c1">// exports java.util, which has a public Date class</span>
<span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">;</span>       <span class="c1">// exports java.sql, which has a public Date class</span>

<span class="kn">import</span> <span class="nn">java.sql.Date</span><span class="o">;</span>         <span class="c1">// resolve the ambiguity of the simple name Date!</span>

<span class="o">...</span>
<span class="nc">Date</span> <span class="n">d</span> <span class="o">=</span> <span class="o">...</span>                  <span class="c1">// Ok!  Date is resolved to java.sql.Date</span>
<span class="o">...</span>
</code></pre></div></div>

<h3 id="jep-512---compact-source-files-and-instance-main-methods">JEP 512 - Compact Source Files and Instance Main Methods</h3>

<p>The highlight of the <a href="https://openjdk.org/projects/amber/design-notes/on-ramp">“Paving the On-Ramp”</a> feature set, <a href="https://openjdk.org/jeps/512">Compact Source Files and Instance Main Methods</a> is finalized in JDK 25. Compact source files and instance main methods simplify the requirements for writing very simple applications, including reducing “Hello World” to three lines, like in the example above. Helpful for educational purposes, and when writing “scripts” in Java.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
	<span class="no">IO</span><span class="o">.</span><span class="na">printin</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
<span class="err">｝</span>
</code></pre></div></div>

<h3 id="jep-513---fleixble-constructor-bodies">JEP 513 - Fleixble Constructor Bodies</h3>

<p><a href="https://openjdk.org/jeps/513">Flexible Constructor Bodies</a> is finalized in JDK 25. This feature enables adding statements before the call to <code class="language-plaintext highlighter-rouge">super</code> in a constructor, which can be helpful for performing data validation or setting default values.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="o">...</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Person</span><span class="o">(...,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(...);</span>
        <span class="o">...</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="n">show</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="nc">String</span> <span class="n">officeID</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Office: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">officeID</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Employee</span><span class="o">(...,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">officeID</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(...,</span> <span class="n">age</span><span class="o">);</span>        <span class="c1">// Potentially unnecessary work</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">18</span>  <span class="o">||</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">67</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(...);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">officeID</span> <span class="o">=</span> <span class="n">officeID</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-514---ahead-of-time-command-line-ergonomics">JEP 514 - Ahead-of-Time Command-Line Ergonomics</h3>

<p><a href="https://openjdk.org/jeps/514">Ahead-of-Time Command-Line Ergonomics</a> simplifies the process for creating an AOT cache by allowing it to be done in a single step. <a href="https://openjdk.org/jeps/483#Description">The two-step process</a> of recording the JVM and creating the cache is still valid and supported. With JEP 514, a user can pass the command <code class="language-plaintext highlighter-rouge">-XX:AOTCacheOutput=[cache name]</code> to have a cache created on shut down of the JVM.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Create the AOT cache
$ java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App ...

# Use the AOT cache
$ java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
</code></pre></div></div>

<h3 id="jep-515---ahead-of-time-method-profiling">JEP 515 - Ahead-of-Time Method Profiling</h3>

<p><a href="https://openjdk.org/jeps/515">Ahead-of-Time Method Profiling</a> allows method profiles to be added to an AOT cache. This improves application warmup by allowing the JIT to immediately start generating native code on application startup.</p>

<h3 id="jep-518---jfr-cooperative-sampling">JEP 518 - JFR Cooperative Sampling</h3>

<p><a href="https://openjdk.org/jeps/518">JFR Cooperative Sampling</a> improves JFR’s stability by redesigning its thread stack sampling mechanism. This is an implementation change which shouldn’t have any behavior impacts, outside of improved stability.</p>

<h3 id="jep-519---compact-object-headers">JEP 519 - Compact Object Headers</h3>

<p><a href="https://openjdk.org/jeps/519">Compact Object Headers</a> is now a final feature after being added as an experimental feature in JDK 24. Compact Object Headers reduces the minimum size an object header can be, which reduces heap sizes by 10-20% and also reduces GC pressure reducing latency.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:+UseCompactObjectHeaders ...
</code></pre></div></div>

<h3 id="jep-520---jfr-method-timing--tracing">JEP 520 - JFR Method Timing &amp; Tracing</h3>

<p><a href="https://openjdk.org/jeps/520">JFR Method Timing &amp; Tracing</a> allows JFR to be configured to time and trace methods. This works via JFR events, and can be configured via the command line like in the respective examples below demonstrating method trace and timing and their output.</p>

<h4 id="method-tracing">Method Tracing</h4>

<p>To enable method tracing, you will configure the JFR event <code class="language-plaintext highlighter-rouge">jdk.MethodTrace</code> like in the example below. You can use the <code class="language-plaintext highlighter-rouge">jfr view</code> command to review the results of the recording.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording:
jdk.MethodTrace#filter=
org.springframework.data.jpa.repository.support.SimpleJpaRepository::findAll, \
filename=recording.jfr ...

$jfr view --cell-height 30 --width 200 jdk.MethodTrace recording.jfr
                                                                                              Method Trace

Start Time Duration Event Thread         Stack Trace                                                                     Method                                                                         
---------- -------- -------------------- ------------------------------------------------------------------------------- -------------------------------------------------------------------------------
15:49:48    43.3 ms http-nio-8080-exec-1 java.lang.invoke.LambdaForm$DMH.0x000040000115c000.invokeVirtual(...)           org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Pag
                                         java.lang.invoke.LambdaForm$MH.0x00004000010a8c00.invoke(...)                   eable)                                                                         
                                         java.lang.invoke.Invokers$Holder.invokeExact_MT(Object, Object, Object, Object)                                                                                
                                         jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(Object, Object[])                                                                                   
                                         jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Object, Object[])                                                                                       
                                         java.lang.reflect.Method.invoke(Object, Object[])                                                                                                              
                                         org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(...)                                                                                   
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker$Rep...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker$Rep...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker.doI...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker.inv...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryComposition$Repos...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryComposition.invok...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryFactorySupport$Im...                                                                                
                                         org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()                                                                                         
                                         org.springframework.data.repository.core.support.QueryExecutorMethodIntercep...                                                                                
                                         org.springframework.data.repository.core.support.QueryExecutorMethodIntercep...                                                                                
                                         org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()                                                                                         
                                         org.springframework.transaction.interceptor.TransactionInterceptor$$Lambda.0...                                                                                                                                                                       
...
</code></pre></div></div>

<h4 id="method-timing">Method Timing</h4>

<p>To enable method timing, you will configure the JFR option <code class="language-plaintext highlighter-rouge">method-timing</code> like in the example below. You can use the <code class="language-plaintext highlighter-rouge">jfr view</code> command to review the results of the recording.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording=method-timing='org.springframework.data.jpa.repository.support.SimpleJpaRepository::findAll',dumponexit=true,filename=recording.jfr -jar target/spring-petclinic-3.5.0-SNAPSHOT.jar

$ jfr view method-timing recording.jfr


                                                                                             Method Timing

Timed Method                                                                                                                                         Invocations Minimum Time Average Time Maximum Time
---------------------------------------------------------------------------------------------------------------------------------------------------- ----------- ------------ ------------ ------------
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Pageable)                                                                          2  3.440000 ms 25.700000 ms 47.900000 ms
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Specification, Pageable)                                                           2  3.440000 ms 25.700000 ms 47.900000 ms
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Specification, Specification, Pageable)                                            2  3.420000 ms 25.600000 ms 47.900000 ms
...
</code></pre></div></div>

<h3 id="jep-521---generational-shenandoah">JEP 521 - Generational Shenandoah</h3>

<p><a href="https://openjdk.org/jeps/521">Generational Shenandoah</a> has been made a final feature in JDK 25. If available on your JDK it can be enabled with the above JVM args.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational ...
</code></pre></div></div>

<h2 id="preview-and-incubator-features">Preview and Incubator Features</h2>

<p>There are six JEPs that covered experimental, preview, or incubator features in JDK 25.</p>

<h3 id="jep-470---pem-encodings-of-cryptographic-objects-preview">JEP 470 - PEM Encodings of Cryptographic Objects (Preview)</h3>

<p><a href="https://openjdk.org/jeps/470">PEM Encodings of Cryptographic Objects</a> introduces an API for encoding objects that represent cryptographic keys, and certificate revocation lists into the widely-used Privacy-Enhanced Mail (PEM) transport format.</p>

<h3 id="jep-502---stable-values-preview">JEP 502 - Stable Values (Preview)</h3>

<p><a href="https://openjdk.org/jeps/502">Stable Values</a> is an API for holding immutable data that can be treated as a constant by the JVM. A <code class="language-plaintext highlighter-rouge">StableValue</code> can only be set once, put provides more fleixiblity than what the <code class="language-plaintext highlighter-rouge">final</code> keyword allows, which requires a variable to be set at either class or instance initialization.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>

    <span class="c1">// OLD:</span>
    <span class="c1">// private Logger logger = null;</span>

    <span class="c1">// NEW:</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StableValue</span><span class="o">&lt;</span><span class="nc">Logger</span><span class="o">&gt;</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">StableValue</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>

    <span class="nc">Logger</span> <span class="nf">getLogger</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">logger</span><span class="o">.</span><span class="na">orElseSet</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="nc">OrderController</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">submitOrder</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">getLogger</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order started"</span><span class="o">);</span>
        <span class="o">...</span>
        <span class="n">getLogger</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order submitted"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-505---structured-concurrency-fifth-preview">JEP 505 - Structured Concurrency (Fifth Preview)</h3>

<p><a href="https://openjdk.org/jeps/505">Structured Concurrency</a> treats groups of related tasks running in different threads as single units of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. The fifth preview introduces a major update to the API from previous versions of it.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Response</span> <span class="nf">handle</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>

    <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">open</span><span class="o">())</span> <span class="o">{</span>

        <span class="nc">Subtask</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">findUser</span><span class="o">());</span>
        <span class="nc">Subtask</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">order</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchOrder</span><span class="o">());</span>

        <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>   <span class="c1">// Join subtasks, propagating exceptions</span>

        <span class="c1">// Both subtasks have succeeded, so compose their results</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Response</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">order</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>

    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-507---primitive-types-in-patterns-instanceof-and-switch-third-preview">JEP 507 - Primitive Types in Patterns, instanceof, and switch (Third Preview)</h3>

<p><a href="https://openjdk.org/jeps/507">Primitive Types in Patterns, instanceof, and switch</a> enhances pattern matching allowing primitives to be used in all contexts.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getYearlyFlights</span><span class="o">())</span> <span class="o">{</span>
	<span class="k">case</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">standardRate</span><span class="o">();</span>
	<span class="k">case</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">standardRate</span><span class="o">();</span>
	<span class="k">case</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">issueDiscount</span><span class="o">();</span>
	<span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">-&gt;</span> <span class="n">issueGoldCard</span><span class="o">();</span>
	<span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span> <span class="n">i</span> <span class="err">›</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">-&gt;</span> <span class="n">issueSilverDiscount</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-508---vector-api-tenth-incubator">JEP 508 - Vector API (Tenth Incubator)</h3>

<p><a href="https://openjdk.org/jeps/508">Vector API</a> enables the expressing vector computations that reliably compile at runtime to optimal vector instructions on supported CPUs, thereby achieving performance superior to equivalent scalar computations. The Vector API will remain in incubator status until the promotion of <a href="https://openjdk.org/projects/valhalla/">Project Valhalla</a> features into the mainline JDK.</p>

<h3 id="jep-509---jfr-cpu-time-profiling-experimental">JEP 509 - JFR CPU-Time Profiling (Experimental)</h3>

<p><a href="https://openjdk.org/jeps/509">JFR CPU-Time Profiling</a> allows JFR to capture more accurate CPU-time profiling information. Note this feature only works on Linux.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true, filename=profile.jfr ...
</code></pre></div></div>

<h2 id="removed-features">Removed Features</h2>

<p>Only a single JEP covers a feature that was removed in JDK 25.</p>

<h3 id="jep-503---remove-the-32-bit-x86-port">JEP 503 - Remove the 32-bit x86 Port</h3>

<p><a href="https://openjdk.org/jeps/509">Remove the 32-bit x86 Port</a> removes all code and build support for 32-bit x86 ports. Subsequently 32-bit OpenJDK binaries will no longer be available starting with the JDK 25 release.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Java 25 represents yet another successful release of Java, following the six-month release cadence. Because this release will come with long-term support offerings (colloquially, an “LTS Release”), many Java developers will take a particular interest in it, as well as in 22, 23, and 24. To that end, I would highly suggest watching out <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzXJ2_0FIGleUisXuUm4AESE">Road to Java 25 video series</a>, and checking out our <a href="https://www.youtube.com/watch?v=duIceCXObrA">Java 25 Launch Livestream</a> where we covered all the important changes between Java 21 and 25.</p>]]></content><author><name>[&quot;BillyKorando&quot;]</name></author><category term="JDK 25" /><summary type="html"><![CDATA[JDK 25 has been released! Let’s quickly review the 18 JEPs (JDK Enhancement Proposals) that were included in the JDK 25 release, in 2 minutes, or maybe just a bit more! And if you have more than a few minutes, you can check out the playlist , but fair warning: your coffee might get cold before you’re done!]]></summary></entry><entry><title type="html">Structured Concurrency in Action</title><link href="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/" rel="alternate" type="text/html" title="Structured Concurrency in Action" /><published>2025-10-16T00:00:00+00:00</published><updated>2025-10-16T00:00:00+00:00</updated><id>https://inside.java/2025/10/16/DevoxxBelgium-Structured-Concurrency-Action</id><content type="html" xml:base="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/IosvCU9qM5M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>In Java 25, the structured concurrency API sees its fifth preview with considerable changes over previous iterations. With chances being good that it will finalize without a further overhaul, let’s put it into action and explore how to:</em></p>

<ul>
  <li><em>structure concurrent code</em></li>
  <li><em>process and propagate errors and cancellation</em></li>
  <li><em>observe thread relationships</em></li>
  <li><em>refactor from a reactive approach</em></li>
</ul>

<p><em>After this presentation you’ll be ready to put the structured concurrency API into action in your project.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 25" /><category term="Loom" /><summary type="html"><![CDATA[In Java 25, the structured concurrency API sees its fifth preview with considerable changes over previous iterations. With chances being good that it will finalize without a further overhaul, let's put it into action and explore how to: structure concurrent code, process and propagate errors and cancellation, observe thread relationships, and refactor from a reactive approach. After this presentation you'll be ready to put the structured concurrency API into action in your project.]]></summary></entry><entry><title type="html">Java for AI</title><link href="https://inside.java/2025/10/14/devoxxbelgium-java-for-ai/" rel="alternate" type="text/html" title="Java for AI" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T00:00:00+00:00</updated><id>https://inside.java/2025/10/14/DevoxxBelgium-Java-For-AI</id><content type="html" xml:base="https://inside.java/2025/10/14/devoxxbelgium-java-for-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/hBffN0xW784" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Many Java features, existing and future, can meet the demands of AI. Existing features include the Foreign Function and Memory API and the Vector API.</em> 
<em>Future features include those proposed by Project Valhalla and Project Babylon.</em></p>

<p><em>This presentation will discuss these features and how they might be used by Java libraries and applications to build competitive AI solutions.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;PaulSandoz&quot;]</name></author><category term="AI" /><category term="Babylon" /><category term="Panama" /><category term="Valhalla" /><summary type="html"><![CDATA[Many Java features, existing and future, can meet the demands of AI. Existing features include the Foreign Function and Memory API and the Vector API. Future features include those proposed by Project Valhalla and Project Babylon. This presentation will discuss these features and how they might be used by Java libraries and applications to build competitive AI solutions.]]></summary></entry><entry><title type="html">Pattern Matching, Under the Microscope</title><link href="https://inside.java/2025/10/13/devoxxbelgium-pattern-matching/" rel="alternate" type="text/html" title="Pattern Matching, Under the Microscope" /><published>2025-10-13T00:00:00+00:00</published><updated>2025-10-13T00:00:00+00:00</updated><id>https://inside.java/2025/10/13/DevoxxBelgium-Pattern-Matching</id><content type="html" xml:base="https://inside.java/2025/10/13/devoxxbelgium-pattern-matching/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/hcWKRfRR-7Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Project Amber has introduced pattern matching into the Java language, improving both safety and expressiveness of our programs.</em>
<em>With JEP 507 set to lift restrictions on primitive types in instanceof and switch, pattern matching is positioned as the foundation of safe cast conversions across all Java types.</em> 
<em>But what does this mean for the language, its safety guarantees, and how we test runtime conditions?</em></p>

<p><em>This session takes an in-depth look at the fundamental concepts of exhaustiveness, unconditionality, applicability, remainder, and examine the distinction between exact and inexact conversions as introduced by JEP 507. With practical code comparisons and visual explanations, we will see how these patterns drive safer code and enable innovative language features on the horizon.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;AngelosBimpoudis&quot;]</name></author><category term="Amber" /><category term="Java Language" /><summary type="html"><![CDATA[Project Amber has introduced pattern matching into the Java language, improving both safety and expressiveness of our programs. With JEP 507 set to lift restrictions on primitive types in instanceof and switch, pattern matching is positioned as the foundation of safe cast conversions across all Java types. But what does this mean for the language, its safety guarantees, and how we test runtime conditions? This session takes an in-depth look at the fundamental concepts of exhaustiveness, unconditionality, applicability, remainder, and examine the distinction between exact and inexact conversions as introduced by JEP 507. With practical code comparisons and visual explanations, we will see how these patterns drive safer code and enable innovative language features on the horizon.]]></summary></entry><entry><title type="html">“Just Make All Exceptions Unchecked” - Live Q&amp;amp;A from Devoxx</title><link href="https://inside.java/2025/10/09/devoxxstream/" rel="alternate" type="text/html" title="“Just Make All Exceptions Unchecked” - Live Q&amp;amp;A from Devoxx" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>https://inside.java/2025/10/09/DevoxxStream</id><content type="html" xml:base="https://inside.java/2025/10/09/devoxxstream/"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/lnfnF7otEnk?si=W4LFfi3oOSkfiU_3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p><em>Java’s error handling is driven by exceptions, a big part of which is the distinction between checked and unchecked exceptions. This comes with hurdles that lead many Java developers to prefer unchecked exceptions and wondering whether checked exceptions where a mistake. In this conversation, Stuart Marks and Nicolai Parlog discuss exactly that.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUvHkalk8nmJ-VtXg_ML_qE">Devoxx 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;StuartMarks&quot;, &quot;NicolaiParlog&quot;]</name></author><category term="Java Language" /><summary type="html"><![CDATA[Java's error handling is driven by exceptions, a big part of which is the distinction between checked and unchecked exceptions. This comes with hurdles that lead many Java developers to prefer unchecked exceptions and wondering whether checked exceptions where a mistake. In this conversation, Stuart Marks and Nicolai Parlog discuss exactly that.]]></summary></entry><entry><title type="html">Unlock Powerful Insights with Java Management Service: Introducing Analyze Applications and Major Management Enhancements</title><link href="https://inside.java/2025/10/08/jms-analyze-applications/" rel="alternate" type="text/html" title="Unlock Powerful Insights with Java Management Service: Introducing Analyze Applications and Major Management Enhancements" /><published>2025-10-08T00:00:00+00:00</published><updated>2025-10-08T00:00:00+00:00</updated><id>https://inside.java/2025/10/08/jms-analyze-applications</id><content type="html" xml:base="https://inside.java/2025/10/08/jms-analyze-applications/"><![CDATA[<p><img class="webfeedsFeaturedVisual" src="/images/thumbnail/code.jpg" style="display: none;" /></p>]]></content><author><name>[&quot;AurelioGarciaRibeyro&quot;]</name></author><category term="Oracle" /><category term="Cloud" /><summary type="html"><![CDATA[We’re excited to announce a significant new release of Oracle Java Management Service (JMS), led by the breakthrough Analyze Applications capability and complemented by major enhancements for managing modern Java fleets—including advanced task scheduling, and expanded support for Java workloads in Kubernetes and with Oracle’s Enterprise Performance Pack.]]></summary></entry><entry><title type="html">Java and AI: Powering Scalable, Enterprise-Grade Intelligence</title><link href="https://inside.java/2025/10/07/java-and-ai-powering-enterprise-intelligence/" rel="alternate" type="text/html" title="Java and AI: Powering Scalable, Enterprise-Grade Intelligence" /><published>2025-10-07T00:00:00+00:00</published><updated>2025-10-07T00:00:00+00:00</updated><id>https://inside.java/2025/10/07/java-and-ai-powering-enterprise-intelligence</id><content type="html" xml:base="https://inside.java/2025/10/07/java-and-ai-powering-enterprise-intelligence/"><![CDATA[<p align="center">
<img alt="Oracle AI World" src="/images/oracle-ai-world-2025.webp" width="75%" />
</p>

<p><a href="https://www.oracle.com/ai-world/"><strong>Register Now for Oracle AI World</strong></a></p>

<p>Oracle continues to thoughtfully invest in flagship conferences that help decision makers adopt value-added solutions and technologies enabling long-lasting enterprise value. This year, Oracle expands its flagship event portfolio with Oracle AI World, THE can’t-miss opportunity where business leaders can learn why organizations worldwide are flocking to embrace Oracle’s latest AI innovations, as well as gain practical tips and insights to drive immediate impact by unlocking the full potential of artificial intelligence.</p>

<p>Oracle’s AI initiatives and solutions are complemented by ongoing investments in Java. AI is transforming industries, driving new revenue opportunities, and redefining customer experiences. But as enterprises move beyond experimentation into large-scale deployment, the technology foundations that power AI become critically important. This is where Java plays a central role. Trusted by millions of developers and embedded deeply in enterprise systems worldwide, Java provides a proven programming language and platform for delivering AI solutions that are not only innovative, but also scalable, secure, and sustainable in production.</p>

<h2 id="enterprise-ready-scalability">Enterprise-Ready Scalability</h2>

<p>AI initiatives succeed or fail based on their ability to scale. Training a model in a lab is very different from deploying it across a global business ecosystem. Modern features give organizations the ability to handle the massive data volumes and real-time processing demands of AI workloads. Whether it’s running predictive analytics across millions of customer interactions or enabling intelligent fraud detection in financial transactions, Java enables organizations to build mission-critical applications that offer consistent performance running at scale.</p>

<h2 id="seamless-integration-with-existing-systems">Seamless Integration with Existing Systems</h2>

<p>For most organizations, AI cannot exist in isolation—it must be woven into core business systems already built on Java. From banking platforms to retail supply chains and telecommunications networks, Java powers mission-critical applications worldwide. Leveraging AI within these environments becomes significantly more efficient when the same programming language and runtime platform are used. This reduces integration complexity, accelerates time-to-value, and ensures AI solutions work harmoniously with existing infrastructure.</p>

<h2 id="a-broad-ecosystem-for-ai-innovation">A Broad Ecosystem for AI Innovation</h2>

<p>The Java ecosystem extends beyond just platform, supporting other languages like Scala and Clojure. This polyglot flexibility allows enterprises to choose the right tools for their AI initiatives while retaining the reliability of the Java platform. Emerging solutions such as Deeplearning4j, Tribuo, and Langchain4J provide production-ready frameworks and libraries for machine learning, while also integrating seamlessly with enterprise data pipelines. These tools empower organizations to move quickly from AI experimentation to operational deployment without having to reinvent their technology stack.</p>

<h2 id="real-world-use-cases-across-industries">Real-World Use Cases Across Industries</h2>

<p>Java-driven AI is already delivering measurable business outcomes across industries:</p>

<ul>
  <li><strong>Financial services</strong>: Real-time fraud detection and risk management systems built on Java leverage AI to protect billions in transactions every day.</li>
  <li><strong>Healthcare</strong>: Java-based solutions enable AI-powered diagnostics and patient monitoring at scale, ensuring reliability in mission-critical scenarios.</li>
  <li><strong>Retail and e-commerce</strong>: AI models integrated into Java-driven supply chain systems optimize inventory, improve logistics, and enhance customer personalization.</li>
  <li><strong>Telecommunications</strong>: AI-enhanced Java systems manage massive data streams from IoT and 5G networks, ensuring quality of service and predictive maintenance.</li>
</ul>

<h2 id="javas-ai-roadmap">Java’s AI Roadmap</h2>

<p>With 30 years of battle-tested reliability and compatibility and a thriving ecosystem of AI libraries to choose from, the Java Platform is a great choice for building AI workloads, but the recent and future roadmap is making it even better. <a href="/tag/Panama">Project Panama</a> has introduced features to better interface with native AI libraries like Tensorflow and perform vector computations, <a href="/tag/Loom">Project Loom</a> is making concurrency easy again, <a href="/tag/Babylon">Project Babylon</a> aims to make Java development on GPUs easier, and <a href="/tag/Amber">Project Amber</a> makes the language concise, expressive, and data-oriented. The future has never been brighter for Java!</p>

<h2 id="experience-java-at-oracle-ai-world">Experience Java at Oracle AI World</h2>

<p>To immerse yourself into the endless possibilities Java offers in the ever-expanding AI ecosystem, stop by the Java booth on the expo floor and attend a curated collection of value-added sessions delivered by recognized Java executives at Oracle:</p>

<h3 id="wednesday-oct-15">Wednesday, Oct 15</h3>

<p><strong><a href="https://www.oracle.com/ai-world/">Everything You Need to Know About Artificial Intelligence and the Java Platform</a></strong><br />
Session ID: LRN2991<br />
Speaker: Donald Smith (VP, Product Management, Java Platform Group, Oracle)<br />
Time: 9:45 AM - 10:30 AM PDT<br />
Room: Marco Polo 803, Level 1</p>

<p><strong><a href="https://www.oracle.com/ai-world/">Industry Perspectives of AI Innovation with Java</a></strong><br />
Session ID: PAN2990<br />
Speaker: Chad Arimura (VP, Developer Relations, Java Platform Group, Oracle)<br />
Time: 2:15 PM - 3:00 PM PDT<br />
Room: Titian 2205, Level 2</p>

<p><strong><a href="https://www.oracle.com/ai-world/">AI and Security: The Present and Future of the Java Platform</a></strong><br />
Session ID: LRN3057<br />
Speaker: Bernard Traversat (VP, Software Development, Java Platform Group, Oracle)<br />
Time: 4:45 PM - 5:30 PM PDT<br />
Room: Marco Polo 802, Level 1</p>

<h3 id="thursday-oct-16">Thursday, Oct 16</h3>

<p><strong><a href="https://www.oracle.com/ai-world/">Elevate Your Emerging AI Solutions with Java</a></strong><br />
Session ID: LRN3058<br />
Speaker: Chad Arimura (VP, Developer Relations, Java Platform Group, Oracle)<br />
Time: 11:30 AM - 12:15 PM PDT<br />
Room: Marco Polo 802, Level 1</p>

<p><a href="https://www.oracle.com/ai-world/"><strong>Register Now for Oracle AI World</strong></a></p>]]></content><author><name>[&quot;SharatChander&quot;]</name></author><category term="Oracle" /><summary type="html"><![CDATA[Oracle's AI initiatives and solutions are complemented by ongoing investments in Java. AI is transforming industries, driving new revenue opportunities, and redefining customer experiences. But as enterprises move beyond experimentation into large-scale deployment, the technology foundations that power AI become critically important. This is where Java plays a central role.]]></summary></entry></feed>