<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-11-22T15:24:42+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Symbolic Modeling and Transformation of Java Code #JVMLS</title><link href="https://inside.java/2025/11/22/jvmls-symbolic-modelling-java-transformation/" rel="alternate" type="text/html" title="Symbolic Modeling and Transformation of Java Code #JVMLS" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://inside.java/2025/11/22/JVMLS-Symbolic-Modelling-Java-Transformation</id><content type="html" xml:base="https://inside.java/2025/11/22/jvmls-symbolic-modelling-java-transformation/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/jbXobiQN8Fw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This session explores code reflection in Project Babylon, demonstrating how Java code can be symbolically modeled as Java code models. It covers the underlying approach, highlights key advantages, and discusses potential limitations.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;PaulSandoz&quot;]</name></author><category term="Babylon" /><summary type="html"><![CDATA[This session explores code reflection in Project Babylon, demonstrating how Java code can be symbolically modeled as Java code models. It covers the underlying approach, highlights key advantages, and discusses potential limitations.]]></summary></entry><entry><title type="html">Java 26 Warns of Deep Reflection - Inside Java Newscast #101</title><link href="https://inside.java/2025/11/20/newscast-101/" rel="alternate" type="text/html" title="Java 26 Warns of Deep Reflection - Inside Java Newscast #101" /><published>2025-11-20T00:00:00+00:00</published><updated>2025-11-20T00:00:00+00:00</updated><id>https://inside.java/2025/11/20/Newscast-101</id><content type="html" xml:base="https://inside.java/2025/11/20/newscast-101/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/bdHkbEIdBAs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Java 26 will issue run-time warnings when a final field is mutated through reflection. This prepares for a future change that will make such final field mutations illegal by default to improve Java’s integrity, specifically the keyword <code class="language-plaintext highlighter-rouge">final</code>. 
This will have beneficial effects on maintainability, security, and performance. While the recommendation is to move away from final field mutation, the new permanent command-line option <code class="language-plaintext highlighter-rouge">--enable-final-field-mutation</code> allows it for selected modules. To ease migration, the more general but temporary option <code class="language-plaintext highlighter-rouge">--illegal-final-field-mutation</code> was also introduced.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=bdHkbEIdBAs">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="Integrity by Default" /><summary type="html"><![CDATA[Java 26 will issue run-time warnings when a final field is mutated through reflection. This prepares for a future change that will make such final field mutations illegal by default to improve Java's integrity, specifically the keyword final. This will have beneficial effects on maintainability, security, and performance. While the recommendation is to move away from final field mutation, the new permanent command-line option --enable-final-field-mutation allows it for selected modules. To ease migration, the more general but temporary option --illegal-final-field-mutation was also introduced.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)</title><link href="https://inside.java/2025/11/17/jep524-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)" /><published>2025-11-17T00:00:00+00:00</published><updated>2025-11-17T00:00:00+00:00</updated><id>https://inside.java/2025/11/17/JEP524-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/17/jep524-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?175032247" /></p>]]></content><author><name>[&quot;AnthonyScarpino&quot;]</name></author><category term="JDK 26" /><category term="Security" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)]]></summary></entry><entry><title type="html">Beyond the Vector API - A Quest for a Lower Level API #JVMLS</title><link href="https://inside.java/2025/11/16/jvmls-vector-api/" rel="alternate" type="text/html" title="Beyond the Vector API - A Quest for a Lower Level API #JVMLS" /><published>2025-11-16T00:00:00+00:00</published><updated>2025-11-16T00:00:00+00:00</updated><id>https://inside.java/2025/11/16/JVMLS-Vector-API</id><content type="html" xml:base="https://inside.java/2025/11/16/jvmls-vector-api/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/YZLVj4UVSj0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Throughout the project, the Vector API balanced providing a cross-platform API with staying close to the metal, performance-wise.</em></p>

<p><em>While the project succeeded in that goal, the Vector API had to give up some important functionality when it didn’t fit the design. As a result, the API became unsuitable for implementing an important class of vectorized algorithms that depend on access to particular hardware functionality. With recent progress in Project Panama (on the Foreign Function &amp; Memory API and <code class="language-plaintext highlighter-rouge">jextract</code>), new opportunities have emerged to bring Java even closer to hardware.</em></p>

<p><em>The talk covers how the Vector API evolved (from machine code snippets to JVM intrinsics), and then focus on a novel approach to providing access to individual machine code instructions from Java code in a performant manner. Such a “hardware intrinsics” API complements the Vector API by providing access to low-level platform-specific primitives. It opens up new opportunities for the Java Platform and enables simplifications in the Vector API, JDK, and JVM implementations.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;VladimirIvanov&quot;]</name></author><category term="Panama" /><summary type="html"><![CDATA[Throughout the project, the Vector API balanced providing a cross-platform API with staying close to the metal, performance-wise. While the project succeeded in that goal, the Vector API had to give up some important functionality when it didn't fit the design. As a result, the API became unsuitable for implementing an important class of vectorized algorithms that depend on access to particular hardware functionality. With recent progress in Project Panama (on the Foreign Function & Memory API and jextract), new opportunities have emerged to bring Java even closer to hardware. The talk covers how the Vector API evolved (from machine code snippets to JVM intrinsics), and then focus on a novel approach to providing access to individual machine code instructions from Java code in a performant manner. Such a "hardware intrinsics" API complements the Vector API by providing access to low-level platform-specific primitives. It opens up new opportunities for the Java Platform and enables simplifications in the Vector API, JDK, and JVM implementations.]]></summary></entry><entry><title type="html">Deep Dive into Gatherers - JEP Cafe #24</title><link href="https://inside.java/2025/11/14/jepcafe24/" rel="alternate" type="text/html" title="Deep Dive into Gatherers - JEP Cafe #24" /><published>2025-11-14T00:00:00+00:00</published><updated>2025-11-14T00:00:00+00:00</updated><id>https://inside.java/2025/11/14/JEPCafe24</id><content type="html" xml:base="https://inside.java/2025/11/14/jepcafe24/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/fgQQIV3B-uo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This JEP Café takes you through everything you can do with Gatherers, added to JDK 24 and available in JDK 25, the version you are going to use for your business applications.</em> 
<em>Along with many examples, it shows you the basics of mapping and filtering, how you can create and manage an internal mutable state to limit your stream, and sort them.</em> 
<em>It shows you how you can properly interrupt a stream when you need, and how you can avoid resource leaking and race conditions in the use of the API. It also shows you how you can leverage some available optimizations by declaring your integrators greedy when you can.</em> 
<em>One of the greatest features of the Stream API is that you can decide to go parallel. So parallel Gatherers are covered, along with the use of non-parallel Gatherers in parallel streams. At the end of this video you will know eveything you need to write efficient and correct Gatherers, but also when you should use them, and when you should stay away from them.</em></p>

<p>Make sure to check the <a href="https://www.youtube.com/watch?v=fgQQIV3B-uo">show-notes</a>!</p>]]></content><author><name>[&quot;JosePaumard&quot;]</name></author><category term="JDK 25" /><category term="Core Libraries" /><summary type="html"><![CDATA[This JEP Café takes you through everything you can do with Gatherers, added to JDK 24 and available in JDK 25, the version you are going to use for your business applications. Along with many examples, it shows you the basics of mapping and filtering, how you can create and manage an internal mutable state to limit your stream, and sort them. It shows you how you can properly interrupt a stream when you need, and how you can avoid resource leaking and race conditions in the use of the API. It also shows you how you can leverage some available optimizations by declaring your integrators greedy when you can. One of the greatest features of the Stream API is that you can decide to go parallel. So parallel Gatherers are covered, along with the use of non-parallel Gatherers in parallel streams. At the end of this video you will know eveything you need to write efficient and correct Gatherers, but also when you should use them, and when you should stay away from them.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC</title><link href="https://inside.java/2025/11/13/jep516-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC" /><published>2025-11-13T00:00:00+00:00</published><updated>2025-11-13T00:00:00+00:00</updated><id>https://inside.java/2025/11/13/JEP516-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/13/jep516-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?162563970" /></p>]]></content><author><name>[&quot;ErikOsterlund&quot;]</name></author><category term="JDK 26" /><category term="Leyden" /><category term="GC" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC]]></summary></entry><entry><title type="html">The Inside Java Newsletter: The Latest on JavaOne 2026</title><link href="https://inside.java/2025/11/12/inside-java-newsletter/" rel="alternate" type="text/html" title="The Inside Java Newsletter: The Latest on JavaOne 2026" /><published>2025-11-12T00:00:00+00:00</published><updated>2025-11-12T00:00:00+00:00</updated><id>https://inside.java/2025/11/12/Inside-Java-Newsletter</id><content type="html" xml:base="https://inside.java/2025/11/12/inside-java-newsletter/"><![CDATA[<p><img class="webfeedsFeaturedVisual" src="/images/thumbnail/code.jpg" style="display: none;" /></p>]]></content><author><name>[&quot;JimGrisanzio&quot;]</name></author><category term="Oracle" /><category term="Community" /><summary type="html"><![CDATA[The Inside Java Newsletter for October 2025 focuses exclusively on planning for JavaOne 2026. Subscribe for updates via the links in the newsletter and we’ll see you in March 2026! Visit learn.java, dev.java, and inside.java for multimedia content for developers, learners, educators, and customers. See the newsletter archives, subscribe, and send to a friend!]]></summary></entry><entry><title type="html">Serialization 2 0: A Marshalling Update!</title><link href="https://inside.java/2025/11/10/devoxxbelgium-serialization2-0-marshalling-update/" rel="alternate" type="text/html" title="Serialization 2 0: A Marshalling Update!" /><published>2025-11-10T00:00:00+00:00</published><updated>2025-11-10T00:00:00+00:00</updated><id>https://inside.java/2025/11/10/DevoxxBelgium-Serialization2.0-Marshalling-Update</id><content type="html" xml:base="https://inside.java/2025/11/10/devoxxbelgium-serialization2-0-marshalling-update/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/F89sNgG9dRY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Almost three decades have passed since the creation of Java Serialization—a feature which is widely frowned upon—and application requirements for externalization of objects have changed significantly.This presentation explains in which way requirements and constraints have changed, and how recent enhancements of the Java Language together with a simpler and clearer division of responsibilities can lead to a dramatically simpler, and safer, model for programmatically reasoning about the structure of Objects; offer greater flexibility in state extraction, versioning, encoding, and reconstruction; and, support a wide selection of wire formats.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;ViktorKlang&quot;]</name></author><category term="Core Libraries" /><summary type="html"><![CDATA[Almost three decades have passed since the creation of Java Serialization—a feature which is widely frowned upon—and application requirements for externalization of objects have changed significantly.This presentation explains in which way requirements and constraints have changed, and how recent enhancements of the Java Language together with a simpler and clearer division of responsibilities can lead to a dramatically simpler, and safer, model for programmatically reasoning about the structure of Objects; offer greater flexibility in state extraction, versioning, encoding, and reconstruction; and, support a wide selection of wire formats.]]></summary></entry><entry><title type="html">Pulling the (Foreign) String</title><link href="https://inside.java/2025/11/08/ffm-string/" rel="alternate" type="text/html" title="Pulling the (Foreign) String" /><published>2025-11-08T00:00:00+00:00</published><updated>2025-11-08T00:00:00+00:00</updated><id>https://inside.java/2025/11/08/FFM-String</id><content type="html" xml:base="https://inside.java/2025/11/08/ffm-string/"><![CDATA[<p>The Foreign Function &amp; Memory (FFM) API comes equipped with methods to read, writes strings from/to memory segments, as well as to allocate memory segments from existing Java strings. In this document we’ll explore ways in which we can enhance the FFM API to support more efficient interoperability between strings and memory segments…</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg?151790213" /></p>]]></content><author><name>[&quot;MaurizioCimadamore&quot;]</name></author><category term="Panama" /><summary type="html"><![CDATA[The Foreign Function & Memory (FFM) API comes equipped with methods to read, writes strings from/to memory segments, as well as to allocate memory segments from existing Java strings. In this document we'll explore ways in which we can enhance the FFM API to support more efficient interoperability between strings and memory segments...]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 500: Prepare to Make Final Mean Final</title><link href="https://inside.java/2025/11/07/jep500-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 500: Prepare to Make Final Mean Final" /><published>2025-11-07T00:00:00+00:00</published><updated>2025-11-07T00:00:00+00:00</updated><id>https://inside.java/2025/11/07/JEP500-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/07/jep500-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 500: Prepare to Make Final Mean Final</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?148650982" /></p>]]></content><author><name>[&quot;RonPressler&quot;, &quot;AlexBuckley&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><category term="Integrity by Default" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 500: Prepare to Make Final Mean Final]]></summary></entry></feed>