<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-10-17T11:29:59+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">What’s New in Java 25 in 25 Minutes - Sip of Java</title><link href="https://inside.java/2025/10/17/new-in-jdk-25-2-mins/" rel="alternate" type="text/html" title="What’s New in Java 25 in 25 Minutes - Sip of Java" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T00:00:00+00:00</updated><id>https://inside.java/2025/10/17/new-in-jdk-25-2-mins</id><content type="html" xml:base="https://inside.java/2025/10/17/new-in-jdk-25-2-mins/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/lCNNA1erCfk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p>JDK 25 was released on September 16th, and with it came 18 JEPs (JDK Enhancement Proposals), many of them being final features. Let’s quickly review the major changes that came in JDK 25!</p>

<h2 id="new-features">New Features</h2>

<p>11 JEPs introduced or finalized new features in JDK 25.</p>

<h3 id="jep-506---scoped-values">JEP 506 - Scoped Values</h3>

<p>The second major feature from <a href="https://openjdk.org/projects/loom/">Project Loom</a>, <a href="https://openjdk.org/jeps/506">Scoped Values</a> are an immutable value that is available within a specific scope of an application. They can be useful for providing contextual information, similar to <code class="language-plaintext highlighter-rouge">ThreadLocal</code>, though aren’t a direct replacement for them.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Framework</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ScopedValue</span><span class="o">&lt;</span><span class="nc">FrameworkContext</span><span class="o">&gt;</span> <span class="no">CONTEXT</span>
                        <span class="o">=</span> <span class="nc">ScopedValue</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>    

    <span class="kt">void</span> <span class="nf">serve</span><span class="o">(</span><span class="nc">Request</span> <span class="n">request</span><span class="o">,</span> <span class="nc">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="o">=</span> <span class="n">createContext</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="n">where</span><span class="o">(</span><span class="no">CONTEXT</span><span class="o">,</span> <span class="n">context</span><span class="o">)</span>                         
                   <span class="o">.</span><span class="na">run</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Application</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">PersistedObject</span> <span class="nf">readKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="o">=</span> <span class="no">CONTEXT</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>                    
        <span class="kt">var</span> <span class="n">db</span> <span class="o">=</span> <span class="n">getDBConnection</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
        <span class="n">db</span><span class="o">.</span><span class="na">readKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-510---key-derivation-function-api">JEP 510 - Key Derivation Function API</h3>

<p>The <a href="https://openjdk.org/jeps/510">Key Derivation Function (KDF) API</a> is a final feature in JDK 25, after previewing in JDK 24. The KDF API allows for the creation of additional keys from a secret key and other data. The sample code below demonstrates how to use the KDF API.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a KDF object for the specified algorithm</span>
<span class="no">KDF</span> <span class="n">hkdf</span> <span class="o">=</span> <span class="no">KDF</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HKDF-SHA256"</span><span class="o">);</span> 

<span class="c1">// Create an ExtractExpand parameter specification</span>
<span class="nc">AlgorithmParameterSpec</span> <span class="n">params</span> <span class="o">=</span>
    <span class="nc">HKDFParameterSpec</span><span class="o">.</span><span class="na">ofExtract</span><span class="o">()</span>
                     <span class="o">.</span><span class="na">addIKM</span><span class="o">(</span><span class="n">initialKeyMaterial</span><span class="o">)</span>
                     <span class="o">.</span><span class="na">addSalt</span><span class="o">(</span><span class="n">salt</span><span class="o">).</span><span class="na">thenExpand</span><span class="o">(</span><span class="n">info</span><span class="o">,</span> <span class="mi">32</span><span class="o">);</span>

<span class="c1">// Derive a 32-byte AES key</span>
<span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">hkdf</span><span class="o">.</span><span class="na">deriveKey</span><span class="o">(</span><span class="s">"AES"</span><span class="o">,</span> <span class="n">params</span><span class="o">);</span>

<span class="c1">// Additional deriveKey calls can be made with the same KDF object</span>
</code></pre></div></div>

<h3 id="jep-511---module-import-declarations">JEP 511 - Module Import Declarations</h3>

<p><a href="https://openjdk.org/jeps/511">Module Import Declarations</a> allow for the importing of all the exported API of a module in a single line with <code class="language-plaintext highlighter-rouge">import module [module name]</code> like in the example above.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>

<span class="nc">String</span><span class="o">[]</span> <span class="n">fruits</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"berry"</span><span class="o">,</span> <span class="s">"citrus"</span> <span class="o">};</span>

<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span>
    <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">fruits</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> 		<span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">().</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">()));</span>
</code></pre></div></div>

<p>If you are importing multiple modules that contain the same class name, like <code class="language-plaintext highlighter-rouge">Date</code> in the above example, you can resolve the conflict by explicitly importing the class <code class="language-plaintext highlighter-rouge">java.sql.Date</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>      <span class="c1">// exports java.util, which has a public Date class</span>
<span class="kn">import</span> <span class="nn">module</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">;</span>       <span class="c1">// exports java.sql, which has a public Date class</span>

<span class="kn">import</span> <span class="nn">java.sql.Date</span><span class="o">;</span>         <span class="c1">// resolve the ambiguity of the simple name Date!</span>

<span class="o">...</span>
<span class="nc">Date</span> <span class="n">d</span> <span class="o">=</span> <span class="o">...</span>                  <span class="c1">// Ok!  Date is resolved to java.sql.Date</span>
<span class="o">...</span>
</code></pre></div></div>

<h3 id="jep-512---compact-source-files-and-instance-main-methods">JEP 512 - Compact Source Files and Instance Main Methods</h3>

<p>The highlight of the <a href="https://openjdk.org/projects/amber/design-notes/on-ramp">“Paving the On-Ramp”</a> feature set, <a href="https://openjdk.org/jeps/512">Compact Source Files and Instance Main Methods</a> is finalized in JDK 25. Compact source files and instance main methods simplify the requirements for writing very simple applications, including reducing “Hello World” to three lines, like in the example above. Helpful for educational purposes, and when writing “scripts” in Java.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">()</span> <span class="o">{</span>
	<span class="no">IO</span><span class="o">.</span><span class="na">printin</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
<span class="err">｝</span>
</code></pre></div></div>

<h3 id="jep-513---fleixble-constructor-bodies">JEP 513 - Fleixble Constructor Bodies</h3>

<p><a href="https://openjdk.org/jeps/513">Flexible Constructor Bodies</a> is finalized in JDK 25. This feature enables adding statements before the call to <code class="language-plaintext highlighter-rouge">super</code> in a constructor, which can be helpful for performing data validation or setting default values.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="o">...</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Person</span><span class="o">(...,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(...);</span>
        <span class="o">...</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="n">show</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="nc">String</span> <span class="n">officeID</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">show</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Age: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Office: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">officeID</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">Employee</span><span class="o">(...,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">officeID</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(...,</span> <span class="n">age</span><span class="o">);</span>        <span class="c1">// Potentially unnecessary work</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="mi">18</span>  <span class="o">||</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">67</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(...);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">officeID</span> <span class="o">=</span> <span class="n">officeID</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-514---ahead-of-time-command-line-ergonomics">JEP 514 - Ahead-of-Time Command-Line Ergonomics</h3>

<p><a href="https://openjdk.org/jeps/514">Ahead-of-Time Command-Line Ergonomics</a> simplifies the process for creating an AOT cache by allowing it to be done in a single step. <a href="https://openjdk.org/jeps/483#Description">The two-step process</a> of recording the JVM and creating the cache is still valid and supported. With JEP 514, a user can pass the command <code class="language-plaintext highlighter-rouge">-XX:AOTCacheOutput=[cache name]</code> to have a cache created on shut down of the JVM.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Create the AOT cache
$ java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App ...

# Use the AOT cache
$ java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
</code></pre></div></div>

<h3 id="jep-515---ahead-of-time-method-profiling">JEP 515 - Ahead-of-Time Method Profiling</h3>

<p><a href="https://openjdk.org/jeps/515">Ahead-of-Time Method Profiling</a> allows method profiles to be added to an AOT cache. This improves application warmup by allowing the JIT to immediately start generating native code on application startup.</p>

<h3 id="jep-518---jfr-cooperative-sampling">JEP 518 - JFR Cooperative Sampling</h3>

<p><a href="https://openjdk.org/jeps/518">JFR Cooperative Sampling</a> improves JFR’s stability by redesigning its thread stack sampling mechanism. This is an implementation change which shouldn’t have any behavior impacts, outside of improved stability.</p>

<h3 id="jep-519---compact-object-headers">JEP 519 - Compact Object Headers</h3>

<p><a href="https://openjdk.org/jeps/519">Compact Object Headers</a> is now a final feature after being added as an experimental feature in JDK 24. Compact Object Headers reduces the minimum size an object header can be, which reduces heap sizes by 10-20% and also reduces GC pressure reducing latency.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:+UseCompactObjectHeaders ...
</code></pre></div></div>

<h3 id="jep-520---jfr-method-timing--tracing">JEP 520 - JFR Method Timing &amp; Tracing</h3>

<p><a href="https://openjdk.org/jeps/520">JFR Method Timing &amp; Tracing</a> allows JFR to be configured to time and trace methods. This works via JFR events, and can be configured via the command line like in the respective examples below demonstrating method trace and timing and their output.</p>

<h4 id="method-tracing">Method Tracing</h4>

<p>To enable method tracing, you will configure the JFR event <code class="language-plaintext highlighter-rouge">jdk.MethodTrace</code> like in the example below. You can use the <code class="language-plaintext highlighter-rouge">jfr view</code> command to review the results of the recording.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording:
jdk.MethodTrace#filter=
org.springframework.data.jpa.repository.support.SimpleJpaRepository::findAll, \
filename=recording.jfr ...

$jfr view --cell-height 30 --width 200 jdk.MethodTrace recording.jfr
                                                                                              Method Trace

Start Time Duration Event Thread         Stack Trace                                                                     Method                                                                         
---------- -------- -------------------- ------------------------------------------------------------------------------- -------------------------------------------------------------------------------
15:49:48    43.3 ms http-nio-8080-exec-1 java.lang.invoke.LambdaForm$DMH.0x000040000115c000.invokeVirtual(...)           org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Pag
                                         java.lang.invoke.LambdaForm$MH.0x00004000010a8c00.invoke(...)                   eable)                                                                         
                                         java.lang.invoke.Invokers$Holder.invokeExact_MT(Object, Object, Object, Object)                                                                                
                                         jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(Object, Object[])                                                                                   
                                         jdk.internal.reflect.DirectMethodHandleAccessor.invoke(Object, Object[])                                                                                       
                                         java.lang.reflect.Method.invoke(Object, Object[])                                                                                                              
                                         org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(...)                                                                                   
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker$Rep...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker$Rep...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker.doI...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryMethodInvoker.inv...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryComposition$Repos...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryComposition.invok...                                                                                
                                         org.springframework.data.repository.core.support.RepositoryFactorySupport$Im...                                                                                
                                         org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()                                                                                         
                                         org.springframework.data.repository.core.support.QueryExecutorMethodIntercep...                                                                                
                                         org.springframework.data.repository.core.support.QueryExecutorMethodIntercep...                                                                                
                                         org.springframework.aop.framework.ReflectiveMethodInvocation.proceed()                                                                                         
                                         org.springframework.transaction.interceptor.TransactionInterceptor$$Lambda.0...                                                                                                                                                                       
...
</code></pre></div></div>

<h4 id="method-timing">Method Timing</h4>

<p>To enable method timing, you will configure the JFR option <code class="language-plaintext highlighter-rouge">method-timing</code> like in the example below. You can use the <code class="language-plaintext highlighter-rouge">jfr view</code> command to review the results of the recording.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording=method-timing='org.springframework.data.jpa.repository.support.SimpleJpaRepository::findAll',dumponexit=true,filename=recording.jfr -jar target/spring-petclinic-3.5.0-SNAPSHOT.jar

$ jfr view method-timing recording.jfr


                                                                                             Method Timing

Timed Method                                                                                                                                         Invocations Minimum Time Average Time Maximum Time
---------------------------------------------------------------------------------------------------------------------------------------------------- ----------- ------------ ------------ ------------
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Pageable)                                                                          2  3.440000 ms 25.700000 ms 47.900000 ms
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Specification, Pageable)                                                           2  3.440000 ms 25.700000 ms 47.900000 ms
org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(Specification, Specification, Pageable)                                            2  3.420000 ms 25.600000 ms 47.900000 ms
...
</code></pre></div></div>

<h3 id="jep-521---generational-shenandoah">JEP 521 - Generational Shenandoah</h3>

<p><a href="https://openjdk.org/jeps/521">Generational Shenandoah</a> has been made a final feature in JDK 25. If available on your JDK it can be enabled with the above JVM args.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational ...
</code></pre></div></div>

<h2 id="preview-and-incubator-features">Preview and Incubator Features</h2>

<p>There are six JEPs that covered experimental, preview, or incubator features in JDK 25.</p>

<h3 id="jep-470---pem-encodings-of-cryptographic-objects-preview">JEP 470 - PEM Encodings of Cryptographic Objects (Preview)</h3>

<p><a href="https://openjdk.org/jeps/470">PEM Encodings of Cryptographic Objects</a> introduces an API for encoding objects that represent cryptographic keys, and certificate revocation lists into the widely-used Privacy-Enhanced Mail (PEM) transport format.</p>

<h3 id="jep-502---stable-values-preview">JEP 502 - Stable Values (Preview)</h3>

<p><a href="https://openjdk.org/jeps/502">Stable Values</a> is an API for holding immutable data that can be treated as a constant by the JVM. A <code class="language-plaintext highlighter-rouge">StableValue</code> can only be set once, put provides more fleixiblity than what the <code class="language-plaintext highlighter-rouge">final</code> keyword allows, which requires a variable to be set at either class or instance initialization.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>

    <span class="c1">// OLD:</span>
    <span class="c1">// private Logger logger = null;</span>

    <span class="c1">// NEW:</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StableValue</span><span class="o">&lt;</span><span class="nc">Logger</span><span class="o">&gt;</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">StableValue</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>

    <span class="nc">Logger</span> <span class="nf">getLogger</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">logger</span><span class="o">.</span><span class="na">orElseSet</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="nc">OrderController</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">submitOrder</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">getLogger</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order started"</span><span class="o">);</span>
        <span class="o">...</span>
        <span class="n">getLogger</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">"order submitted"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-505---structured-concurrency-fifth-preview">JEP 505 - Structured Concurrency (Fifth Preview)</h3>

<p><a href="https://openjdk.org/jeps/505">Structured Concurrency</a> treats groups of related tasks running in different threads as single units of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. The fifth preview introduces a major update to the API from previous versions of it.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Response</span> <span class="nf">handle</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>

    <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">open</span><span class="o">())</span> <span class="o">{</span>

        <span class="nc">Subtask</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">findUser</span><span class="o">());</span>
        <span class="nc">Subtask</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">order</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">fetchOrder</span><span class="o">());</span>

        <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>   <span class="c1">// Join subtasks, propagating exceptions</span>

        <span class="c1">// Both subtasks have succeeded, so compose their results</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Response</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="n">order</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>

    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-507---primitive-types-in-patterns-instanceof-and-switch-third-preview">JEP 507 - Primitive Types in Patterns, instanceof, and switch (Third Preview)</h3>

<p><a href="https://openjdk.org/jeps/507">Primitive Types in Patterns, instanceof, and switch</a> enhances pattern matching allowing primitives to be used in all contexts.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getYearlyFlights</span><span class="o">())</span> <span class="o">{</span>
	<span class="k">case</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">standardRate</span><span class="o">();</span>
	<span class="k">case</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">standardRate</span><span class="o">();</span>
	<span class="k">case</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">issueDiscount</span><span class="o">();</span>
	<span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="o">-&gt;</span> <span class="n">issueGoldCard</span><span class="o">();</span>
	<span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span> <span class="n">i</span> <span class="err">›</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">-&gt;</span> <span class="n">issueSilverDiscount</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="jep-508---vector-api-tenth-incubator">JEP 508 - Vector API (Tenth Incubator)</h3>

<p><a href="https://openjdk.org/jeps/508">Vector API</a> enables the expressing vector computations that reliably compile at runtime to optimal vector instructions on supported CPUs, thereby achieving performance superior to equivalent scalar computations. The Vector API will remain in incubator status until the promotion of <a href="https://openjdk.org/projects/valhalla/">Project Valhalla</a> features into the mainline JDK.</p>

<h3 id="jep-509---jfr-cpu-time-profiling-experimental">JEP 509 - JFR CPU-Time Profiling (Experimental)</h3>

<p><a href="https://openjdk.org/jeps/509">JFR CPU-Time Profiling</a> allows JFR to capture more accurate CPU-time profiling information. Note this feature only works on Linux.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true, filename=profile.jfr ...
</code></pre></div></div>

<h2 id="removed-features">Removed Features</h2>

<p>Only a single JEP covers a feature that was removed in JDK 25.</p>

<h3 id="jep-503---remove-the-32-bit-x86-port">JEP 503 - Remove the 32-bit x86 Port</h3>

<p><a href="https://openjdk.org/jeps/509">Remove the 32-bit x86 Port</a> removes all code and build support for 32-bit x86 ports. Subsequently 32-bit OpenJDK binaries will no longer be available starting with the JDK 25 release.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Java 25 represents yet another successful release of Java, following the six-month release cadence. Because this release will come with long-term support offerings (colloquially, an “LTS Release”), many Java developers will take a particular interest in it, as well as in 22, 23, and 24. To that end, I would highly suggest watching out <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzXJ2_0FIGleUisXuUm4AESE">Road to Java 25 video series</a>, and checking out our <a href="https://www.youtube.com/watch?v=duIceCXObrA">Java 25 Launch Livestream</a> where we covered all the important changes between Java 21 and 25.</p>]]></content><author><name>[&quot;BillyKorando&quot;]</name></author><category term="JDK 25" /><summary type="html"><![CDATA[JDK 25 has been released! Let’s quickly review the 18 JEPs (JDK Enhancement Proposals) that were included in the JDK 25 release, in 2 minutes, or maybe just a bit more! And if you have more than a few minutes, you can check out the playlist , but fair warning: your coffee might get cold before you’re done!]]></summary></entry><entry><title type="html">Structured Concurrency in Action</title><link href="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/" rel="alternate" type="text/html" title="Structured Concurrency in Action" /><published>2025-10-16T00:00:00+00:00</published><updated>2025-10-16T00:00:00+00:00</updated><id>https://inside.java/2025/10/16/DevoxxBelgium-Structured-Concurrency-Action</id><content type="html" xml:base="https://inside.java/2025/10/16/devoxxbelgium-structured-concurrency-action/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/IosvCU9qM5M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>In Java 25, the structured concurrency API sees its fifth preview with considerable changes over previous iterations. With chances being good that it will finalize without a further overhaul, let’s put it into action and explore how to:</em></p>

<ul>
  <li><em>structure concurrent code</em></li>
  <li><em>process and propagate errors and cancellation</em></li>
  <li><em>observe thread relationships</em></li>
  <li><em>refactor from a reactive approach</em></li>
</ul>

<p><em>After this presentation you’ll be ready to put the structured concurrency API into action in your project.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 25" /><category term="Loom" /><summary type="html"><![CDATA[In Java 25, the structured concurrency API sees its fifth preview with considerable changes over previous iterations. With chances being good that it will finalize without a further overhaul, let's put it into action and explore how to: structure concurrent code, process and propagate errors and cancellation, observe thread relationships, and refactor from a reactive approach. After this presentation you'll be ready to put the structured concurrency API into action in your project.]]></summary></entry><entry><title type="html">Java for AI</title><link href="https://inside.java/2025/10/14/devoxxbelgium-java-for-ai/" rel="alternate" type="text/html" title="Java for AI" /><published>2025-10-14T00:00:00+00:00</published><updated>2025-10-14T00:00:00+00:00</updated><id>https://inside.java/2025/10/14/DevoxxBelgium-Java-For-AI</id><content type="html" xml:base="https://inside.java/2025/10/14/devoxxbelgium-java-for-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/hBffN0xW784" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Many Java features, existing and future, can meet the demands of AI. Existing features include the Foreign Function and Memory API and the Vector API.</em> 
<em>Future features include those proposed by Project Valhalla and Project Babylon.</em></p>

<p><em>This presentation will discuss these features and how they might be used by Java libraries and applications to build competitive AI solutions.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;PaulSandoz&quot;]</name></author><category term="AI" /><category term="Babylon" /><category term="Panama" /><category term="Valhalla" /><summary type="html"><![CDATA[Many Java features, existing and future, can meet the demands of AI. Existing features include the Foreign Function and Memory API and the Vector API. Future features include those proposed by Project Valhalla and Project Babylon. This presentation will discuss these features and how they might be used by Java libraries and applications to build competitive AI solutions.]]></summary></entry><entry><title type="html">Pattern Matching, Under the Microscope</title><link href="https://inside.java/2025/10/13/devoxxbelgium-pattern-matching/" rel="alternate" type="text/html" title="Pattern Matching, Under the Microscope" /><published>2025-10-13T00:00:00+00:00</published><updated>2025-10-13T00:00:00+00:00</updated><id>https://inside.java/2025/10/13/DevoxxBelgium-Pattern-Matching</id><content type="html" xml:base="https://inside.java/2025/10/13/devoxxbelgium-pattern-matching/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/hcWKRfRR-7Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Project Amber has introduced pattern matching into the Java language, improving both safety and expressiveness of our programs.</em>
<em>With JEP 507 set to lift restrictions on primitive types in instanceof and switch, pattern matching is positioned as the foundation of safe cast conversions across all Java types.</em> 
<em>But what does this mean for the language, its safety guarantees, and how we test runtime conditions?</em></p>

<p><em>This session takes an in-depth look at the fundamental concepts of exhaustiveness, unconditionality, applicability, remainder, and examine the distinction between exact and inexact conversions as introduced by JEP 507. With practical code comparisons and visual explanations, we will see how these patterns drive safer code and enable innovative language features on the horizon.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;AngelosBimpoudis&quot;]</name></author><category term="Amber" /><category term="Java Language" /><summary type="html"><![CDATA[Project Amber has introduced pattern matching into the Java language, improving both safety and expressiveness of our programs. With JEP 507 set to lift restrictions on primitive types in instanceof and switch, pattern matching is positioned as the foundation of safe cast conversions across all Java types. But what does this mean for the language, its safety guarantees, and how we test runtime conditions? This session takes an in-depth look at the fundamental concepts of exhaustiveness, unconditionality, applicability, remainder, and examine the distinction between exact and inexact conversions as introduced by JEP 507. With practical code comparisons and visual explanations, we will see how these patterns drive safer code and enable innovative language features on the horizon.]]></summary></entry><entry><title type="html">“Just Make All Exceptions Unchecked” - Live Q&amp;amp;A from Devoxx</title><link href="https://inside.java/2025/10/09/devoxxstream/" rel="alternate" type="text/html" title="“Just Make All Exceptions Unchecked” - Live Q&amp;amp;A from Devoxx" /><published>2025-10-09T00:00:00+00:00</published><updated>2025-10-09T00:00:00+00:00</updated><id>https://inside.java/2025/10/09/DevoxxStream</id><content type="html" xml:base="https://inside.java/2025/10/09/devoxxstream/"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/lnfnF7otEnk?si=W4LFfi3oOSkfiU_3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p><em>Java’s error handling is driven by exceptions, a big part of which is the distinction between checked and unchecked exceptions. This comes with hurdles that lead many Java developers to prefer unchecked exceptions and wondering whether checked exceptions where a mistake. In this conversation, Stuart Marks and Nicolai Parlog discuss exactly that.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUvHkalk8nmJ-VtXg_ML_qE">Devoxx 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;StuartMarks&quot;, &quot;NicolaiParlog&quot;]</name></author><category term="Java Language" /><summary type="html"><![CDATA[Java's error handling is driven by exceptions, a big part of which is the distinction between checked and unchecked exceptions. This comes with hurdles that lead many Java developers to prefer unchecked exceptions and wondering whether checked exceptions where a mistake. In this conversation, Stuart Marks and Nicolai Parlog discuss exactly that.]]></summary></entry><entry><title type="html">Unlock Powerful Insights with Java Management Service: Introducing Analyze Applications and Major Management Enhancements</title><link href="https://inside.java/2025/10/08/jms-analyze-applications/" rel="alternate" type="text/html" title="Unlock Powerful Insights with Java Management Service: Introducing Analyze Applications and Major Management Enhancements" /><published>2025-10-08T00:00:00+00:00</published><updated>2025-10-08T00:00:00+00:00</updated><id>https://inside.java/2025/10/08/jms-analyze-applications</id><content type="html" xml:base="https://inside.java/2025/10/08/jms-analyze-applications/"><![CDATA[<p><img class="webfeedsFeaturedVisual" src="/images/thumbnail/code.jpg" style="display: none;" /></p>]]></content><author><name>[&quot;AurelioGarciaRibeyro&quot;]</name></author><category term="Oracle" /><category term="Cloud" /><summary type="html"><![CDATA[We’re excited to announce a significant new release of Oracle Java Management Service (JMS), led by the breakthrough Analyze Applications capability and complemented by major enhancements for managing modern Java fleets—including advanced task scheduling, and expanded support for Java workloads in Kubernetes and with Oracle’s Enterprise Performance Pack.]]></summary></entry><entry><title type="html">Java and AI: Powering Scalable, Enterprise-Grade Intelligence</title><link href="https://inside.java/2025/10/07/java-and-ai-powering-enterprise-intelligence/" rel="alternate" type="text/html" title="Java and AI: Powering Scalable, Enterprise-Grade Intelligence" /><published>2025-10-07T00:00:00+00:00</published><updated>2025-10-07T00:00:00+00:00</updated><id>https://inside.java/2025/10/07/java-and-ai-powering-enterprise-intelligence</id><content type="html" xml:base="https://inside.java/2025/10/07/java-and-ai-powering-enterprise-intelligence/"><![CDATA[<p align="center">
<img alt="Oracle AI World" src="/images/oracle-ai-world-2025.webp" width="75%" />
</p>

<p><a href="https://www.oracle.com/ai-world/"><strong>Register Now for Oracle AI World</strong></a></p>

<p>Oracle continues to thoughtfully invest in flagship conferences that help decision makers adopt value-added solutions and technologies enabling long-lasting enterprise value. This year, Oracle expands its flagship event portfolio with Oracle AI World, THE can’t-miss opportunity where business leaders can learn why organizations worldwide are flocking to embrace Oracle’s latest AI innovations, as well as gain practical tips and insights to drive immediate impact by unlocking the full potential of artificial intelligence.</p>

<p>Oracle’s AI initiatives and solutions are complemented by ongoing investments in Java. AI is transforming industries, driving new revenue opportunities, and redefining customer experiences. But as enterprises move beyond experimentation into large-scale deployment, the technology foundations that power AI become critically important. This is where Java plays a central role. Trusted by millions of developers and embedded deeply in enterprise systems worldwide, Java provides a proven programming language and platform for delivering AI solutions that are not only innovative, but also scalable, secure, and sustainable in production.</p>

<h2 id="enterprise-ready-scalability">Enterprise-Ready Scalability</h2>

<p>AI initiatives succeed or fail based on their ability to scale. Training a model in a lab is very different from deploying it across a global business ecosystem. Modern features give organizations the ability to handle the massive data volumes and real-time processing demands of AI workloads. Whether it’s running predictive analytics across millions of customer interactions or enabling intelligent fraud detection in financial transactions, Java enables organizations to build mission-critical applications that offer consistent performance running at scale.</p>

<h2 id="seamless-integration-with-existing-systems">Seamless Integration with Existing Systems</h2>

<p>For most organizations, AI cannot exist in isolation—it must be woven into core business systems already built on Java. From banking platforms to retail supply chains and telecommunications networks, Java powers mission-critical applications worldwide. Leveraging AI within these environments becomes significantly more efficient when the same programming language and runtime platform are used. This reduces integration complexity, accelerates time-to-value, and ensures AI solutions work harmoniously with existing infrastructure.</p>

<h2 id="a-broad-ecosystem-for-ai-innovation">A Broad Ecosystem for AI Innovation</h2>

<p>The Java ecosystem extends beyond just platform, supporting other languages like Scala and Clojure. This polyglot flexibility allows enterprises to choose the right tools for their AI initiatives while retaining the reliability of the Java platform. Emerging solutions such as Deeplearning4j, Tribuo, and Langchain4J provide production-ready frameworks and libraries for machine learning, while also integrating seamlessly with enterprise data pipelines. These tools empower organizations to move quickly from AI experimentation to operational deployment without having to reinvent their technology stack.</p>

<h2 id="real-world-use-cases-across-industries">Real-World Use Cases Across Industries</h2>

<p>Java-driven AI is already delivering measurable business outcomes across industries:</p>

<ul>
  <li><strong>Financial services</strong>: Real-time fraud detection and risk management systems built on Java leverage AI to protect billions in transactions every day.</li>
  <li><strong>Healthcare</strong>: Java-based solutions enable AI-powered diagnostics and patient monitoring at scale, ensuring reliability in mission-critical scenarios.</li>
  <li><strong>Retail and e-commerce</strong>: AI models integrated into Java-driven supply chain systems optimize inventory, improve logistics, and enhance customer personalization.</li>
  <li><strong>Telecommunications</strong>: AI-enhanced Java systems manage massive data streams from IoT and 5G networks, ensuring quality of service and predictive maintenance.</li>
</ul>

<h2 id="javas-ai-roadmap">Java’s AI Roadmap</h2>

<p>With 30 years of battle-tested reliability and compatibility and a thriving ecosystem of AI libraries to choose from, the Java Platform is a great choice for building AI workloads, but the recent and future roadmap is making it even better. <a href="/tag/Panama">Project Panama</a> has introduced features to better interface with native AI libraries like Tensorflow and perform vector computations, <a href="/tag/Loom">Project Loom</a> is making concurrency easy again, <a href="/tag/Babylon">Project Babylon</a> aims to make Java development on GPUs easier, and <a href="/tag/Amber">Project Amber</a> makes the language concise, expressive, and data-oriented. The future has never been brighter for Java!</p>

<h2 id="experience-java-at-oracle-ai-world">Experience Java at Oracle AI World</h2>

<p>To immerse yourself into the endless possibilities Java offers in the ever-expanding AI ecosystem, stop by the Java booth on the expo floor and attend a curated collection of value-added sessions delivered by recognized Java executives at Oracle:</p>

<h3 id="wednesday-oct-15">Wednesday, Oct 15</h3>

<p><strong><a href="https://www.oracle.com/ai-world/">Everything You Need to Know About Artificial Intelligence and the Java Platform</a></strong><br />
Session ID: LRN2991<br />
Speaker: Donald Smith (VP, Product Management, Java Platform Group, Oracle)<br />
Time: 9:45 AM - 10:30 AM PDT<br />
Room: Marco Polo 803, Level 1</p>

<p><strong><a href="https://www.oracle.com/ai-world/">Industry Perspectives of AI Innovation with Java</a></strong><br />
Session ID: PAN2990<br />
Speaker: Chad Arimura (VP, Developer Relations, Java Platform Group, Oracle)<br />
Time: 2:15 PM - 3:00 PM PDT<br />
Room: Titian 2205, Level 2</p>

<p><strong><a href="https://www.oracle.com/ai-world/">AI and Security: The Present and Future of the Java Platform</a></strong><br />
Session ID: LRN3057<br />
Speaker: Bernard Traversat (VP, Software Development, Java Platform Group, Oracle)<br />
Time: 4:45 PM - 5:30 PM PDT<br />
Room: Marco Polo 802, Level 1</p>

<h3 id="thursday-oct-16">Thursday, Oct 16</h3>

<p><strong><a href="https://www.oracle.com/ai-world/">Elevate Your Emerging AI Solutions with Java</a></strong><br />
Session ID: LRN3058<br />
Speaker: Chad Arimura (VP, Developer Relations, Java Platform Group, Oracle)<br />
Time: 11:30 AM - 12:15 PM PDT<br />
Room: Marco Polo 802, Level 1</p>

<p><a href="https://www.oracle.com/ai-world/"><strong>Register Now for Oracle AI World</strong></a></p>]]></content><author><name>[&quot;SharatChander&quot;]</name></author><category term="Oracle" /><summary type="html"><![CDATA[Oracle's AI initiatives and solutions are complemented by ongoing investments in Java. AI is transforming industries, driving new revenue opportunities, and redefining customer experiences. But as enterprises move beyond experimentation into large-scale deployment, the technology foundations that power AI become critically important. This is where Java plays a central role.]]></summary></entry><entry><title type="html">Evolving ZGC’s Pointer Color Palette #JVMLS</title><link href="https://inside.java/2025/10/06/jvmls-zgc-colored-pointers/" rel="alternate" type="text/html" title="Evolving ZGC’s Pointer Color Palette #JVMLS" /><published>2025-10-06T00:00:00+00:00</published><updated>2025-10-06T00:00:00+00:00</updated><id>https://inside.java/2025/10/06/JVMLS-ZGC-Colored-Pointers</id><content type="html" xml:base="https://inside.java/2025/10/06/jvmls-zgc-colored-pointers/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/y_QeST7Axrw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>The practice of coloring pointers is a core DNA element of ZGC. There are different ways of coloring a pointer and picking an appropriate one is of crucial importance for the algorithm.</em> 
<em>As the complexity of our ZGC art increases, its color palette evolves with it, allowing it to describe more nuanced shades.</em> 
<em>This presentation goes into a little bit more detail how the ZGC choice of paint has evolved from non-generational to generational ZGC, but also how it has evolved further to prepare for the next step in the evolution of ZGC: thread-local GC.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;ErikOsterlund&quot;]</name></author><category term="GC" /><category term="HotSpot" /><summary type="html"><![CDATA[The practice of coloring pointers is a core DNA element of ZGC. There are different ways of coloring a pointer and picking an appropriate one is of crucial importance for the algorithm. As the complexity of our ZGC art increases, its color palette evolves with it, allowing it to describe more nuanced shades. This presentation goes into a little bit more detail how the ZGC choice of paint has evolved from non-generational to generational ZGC, but also how it has evolved further to prepare for the next step in the evolution of ZGC: thread-local GC.]]></summary></entry><entry><title type="html">The Inside Java Newsletter: Java 25 is Live!</title><link href="https://inside.java/2025/10/03/inside-java-newsletter/" rel="alternate" type="text/html" title="The Inside Java Newsletter: Java 25 is Live!" /><published>2025-10-03T00:00:00+00:00</published><updated>2025-10-03T00:00:00+00:00</updated><id>https://inside.java/2025/10/03/Inside-Java-Newsletter</id><content type="html" xml:base="https://inside.java/2025/10/03/inside-java-newsletter/"><![CDATA[<p><img class="webfeedsFeaturedVisual" src="/images/thumbnail/code.jpg" style="display: none;" /></p>]]></content><author><name>[&quot;JimGrisanzio&quot;]</name></author><category term="Oracle" /><category term="Community" /><summary type="html"><![CDATA[The Inside Java Newsletter for September 2025 focuses on a series of technical videos about Java 25. We also have updates on Java User Groups, developer events, learning resources, community podcasts, and content from the Java Platform Group. Visit learn.java, dev.java, and inside.java for multimedia content for developers, learners, educators, and customers. See the archives, subscribe, and send to a friend!]]></summary></entry><entry><title type="html">Oracle Java Extension for Visual Studio Code Version 24.1.2 Is Now Available!</title><link href="https://inside.java/2025/10/01/java-vscode-extension-update/" rel="alternate" type="text/html" title="Oracle Java Extension for Visual Studio Code Version 24.1.2 Is Now Available!" /><published>2025-10-01T00:00:00+00:00</published><updated>2025-10-01T00:00:00+00:00</updated><id>https://inside.java/2025/10/01/java-vscode-extension-update</id><content type="html" xml:base="https://inside.java/2025/10/01/java-vscode-extension-update/"><![CDATA[<p>New Java Platform Extension for VS Code Release</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/duke-vscode.jpg?237829591" /></p>]]></content><author><name>[&quot;ArvindAprameya&quot;]</name></author><category term="Oracle" /><summary type="html"><![CDATA[New Java Platform Extension for VS Code Release]]></summary></entry></feed>