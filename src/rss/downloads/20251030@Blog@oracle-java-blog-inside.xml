<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-10-30T09:18:50+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API</title><link href="https://inside.java/2025/10/30/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API" /><published>2025-10-30T00:00:00+00:00</published><updated>2025-10-30T00:00:00+00:00</updated><id>https://inside.java/2025/10/30/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/10/30/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of the <a href="https://mail.openjdk.org/pipermail/quality-discuss/">quality outreach</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="http3-support-in-httpclient">HTTP/3 Support in HttpClient</h2>

<p>The <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> API allows Java applications to create reusable HTTP client instances, build HTTP requests, and handle responses synchronously or asynchronously. 
Since JDK 11, you can set the preferred HTTP protocol versions like HTTP/1.1 or HTTP/2 at the <code class="language-plaintext highlighter-rouge">HttpClient</code> or <code class="language-plaintext highlighter-rouge">HttpRequest</code> level.</p>

<p><a href="https://openjdk.org/jeps/517">JEP 517</a> introduces support for HTTP/3 (<code class="language-plaintext highlighter-rouge">HttpClient.Version.HTTP_3</code>) in JDK 26, enabling applications to prefer or enforce HTTP/3 for requests.
While HTTP/3 offers similar features to HTTP/2 at the protocol level, its key difference is that it runs over the QUIC protocol using UDP, whereas HTTP/2 operates over TCP.
Below is a code snippet on how you can prefer and/or enforce HTTP/3:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// prefer HTTP/3</span>
<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// if target server support HTTP/3, add this to enforce it</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>
</code></pre></div></div>

<p>If you set HTTP/3 but it is not available, the client will automatically downgrade to HTTP/2 or HTTP/1.1.
If you configure to strictly require HTTP/3, a failed attempt leads to an exception rather than a downgrade.</p>

<p>However, setting HTTP/3 as the preferred version does not guarantee its use, as the client cannot know beforehand if the server supports it. 
For the first request to a server, the client tries both TCP (HTTP/2) and UDP (HTTP/3) connections and uses whichever succeeds first. 
Over time, the <code class="language-plaintext highlighter-rouge">HttpClient</code> can “learn” about the HTTP version(s) that a server supports by using the “Alt-Svc” mechanism (the “HTTP Alternative Services” standard per <a href="https://datatracker.ietf.org/doc/html/rfc7838">RFC 7838</a>). 
Servers supporting “Alt-Svc” advertise alternative supported protocols such as HTTP/3. This allows subsequent requests to that server to use HTTP/3 when supported. For more details on this mechanism, see <a href="https://inside.java/2025/10/22/http3-support/">this article</a>.</p>

<h2 id="call-to-action">Call to Action</h2>

<p>Although the enhancements to the HTTP Client API appear simple to use, supporting HTTP/3 on top of QUIC represents the result of several years of dedicated development effort within the JDK team.
As this implementation is still new, we encourage you to download the <a href="https://jdk.java.net/26/">Java 26 Early Access builds</a>, try this feature, and share your feedback through the <a href="https://mail.openjdk.org/mailman/listinfo/net-dev">net-dev OpenJDK mailing list</a> (registration required).</p>

<center>~</center>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 26" /><category term="Networking" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers the HTTP/3 support in JDK 26.]]></summary></entry><entry><title type="html">AI World: Georges Saab Unveils Java 25 for AI and Cloud</title><link href="https://inside.java/2025/10/29/aiworld-java-for-ai/" rel="alternate" type="text/html" title="AI World: Georges Saab Unveils Java 25 for AI and Cloud" /><published>2025-10-29T00:00:00+00:00</published><updated>2025-10-29T00:00:00+00:00</updated><id>https://inside.java/2025/10/29/AIWorld-java-for-ai</id><content type="html" xml:base="https://inside.java/2025/10/29/aiworld-java-for-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/a1aro8bq30o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.</em></p>

<p><em>Java is trusted by millions of developers worldwide and remains the backbone of enterprise systems and emerging AI-powered workloads. In this special segment from Oracle TV at Oracle AI World 2025, Georges Saab, Senior Vice President of Development of the Java Platform, highlights the latest features in Java 25 and their impact on developers, IT leaders, and businesses at scale.</em></p>

<p><em>Georges explains the major innovations in Java 25, Oracle’s approach to evolving and supporting the Java language, platform, and ecosystem, and the important role of GraalVM’s alternative runtime. Learn how the Java 25 long-term support (LTS) release enables organizations to modernize legacy applications and embrace cloud-first and multi-cloud strategies. Discover how new features in Java 25 make it easier to build, deploy, and run AI-driven and cloud-native solutions—driving agility and business value. Georges also provides a preview of what’s coming in Java 26, reinforcing Java’s ongoing six-month release cadence and its future in the enterprise and beyond.</em></p>]]></content><author><name>[&quot;GeorgesSaab&quot;]</name></author><category term="AI" /><category term="Cloud" /><category term="Oracle" /><summary type="html"><![CDATA[Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 504: Remove the Applet API</title><link href="https://inside.java/2025/10/28/jep504-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 504: Remove the Applet API" /><published>2025-10-28T00:00:00+00:00</published><updated>2025-10-28T00:00:00+00:00</updated><id>https://inside.java/2025/10/28/JEP504-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/10/28/jep504-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 504: Remove the Applet API</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?435161049" /></p>]]></content><author><name>[&quot;PhilRace&quot;]</name></author><category term="JDK 26" /><category term="Client" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 504: Remove the Applet API]]></summary></entry><entry><title type="html">Episode 41 “From Cowboy Mode to Careful Stewardship” with Mark Reinhold</title><link href="https://inside.java/2025/10/27/podcast-041/" rel="alternate" type="text/html" title="Episode 41 “From Cowboy Mode to Careful Stewardship” with Mark Reinhold" /><published>2025-10-27T01:00:00+00:00</published><updated>2025-10-27T01:00:00+00:00</updated><id>https://inside.java/2025/10/27/Podcast-041</id><content type="html" xml:base="https://inside.java/2025/10/27/podcast-041/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/ChadMic.jpg?430953306" /></p>

<p><br /></p>
<iframe title="Libsyn Player" style="border: none" src="//html5-player.libsyn.com/embed/episode/id/38766750/height/90/theme/custom/thumbnail/yes/direction/forward/render-playlist/no/custom-color/000000/" height="90" width="100%" scrolling="no"></iframe>

<div class="youtube-embed">
<iframe src="https://www.youtube.com/embed/ny4CqBX_kaQ?si=YMIp5TbKvjRQaCy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</div>

<p><br /></p>

<p>Java is a 30-year success story, made possible because its development consistently aligned with users’ needs. In its early days, the platform required new features quickly, but over time, minimizing code breakage while carefully evolving the platform became essential. Critical junctures along that path included the introduction of modules and the current strive toward integrity by default.</p>

<p>Nicolai Parlog talks to Mark Reinhold, Chief Architect of the Java Platform, who brings nearly three decades of experience shaping Java’s evolution.</p>

<p><br />
Make sure to also check the <strong>Duke’s Corner podcast</strong> on <a href="https://dev.java/duke/corner/">dev.java</a>.</p>

<p><br /></p>

<h3 id="additional-resources">Additional resources</h3>
<ul>
  <li><a href="https://inside.java">Inside.java</a> : News and views from members of the Java team at Oracle</li>
  <li><a href="https://dev.java">Dev.java</a> : The Destination for Java Developers</li>
  <li><a href="https://openjdk.java.net/">OpenJDK</a></li>
  <li><a href="https://www.oracle.com/java/">Oracle Java</a></li>
</ul>

<p>For more episodes, check out <a href="https://inside.java/podcast">Inside Java</a>, our <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzV_hXbRevwzrXSMcGNzhxiZ">YouTube playlist</a>, and follow <a href="https://twitter.com/java">@Java</a> on Twitter.</p>

<p>Contact us <a href="https://inside.java/about/">here</a>.</p>]]></content><author><name>[&quot;MarkReinhold&quot;, &quot;NicolaiParlog&quot;]</name></author><summary type="html"><![CDATA[Nicolai Parlog talks to Mark Reinhold, Chief Architect of the Java Platform, who has almost 30 years of experience driving Java forward...]]></summary></entry><entry><title type="html">Try Out JEP 401 Value Classes and Objects</title><link href="https://inside.java/2025/10/27/try-jep-401-value-classes/" rel="alternate" type="text/html" title="Try Out JEP 401 Value Classes and Objects" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>https://inside.java/2025/10/27/try-jep-401-value-classes</id><content type="html" xml:base="https://inside.java/2025/10/27/try-jep-401-value-classes/"><![CDATA[<p>The Valhalla team recently published an early-access JDK build that fully implements <a href="https://openjdk.org/jeps/401">JEP 401: Value Classes and Objects (Preview)</a>.
There’s still a lot of work to do to get this code into a future release of the JDK.
Until then, now is a great time for anyone who is interested to try out this transformative new feature!</p>

<h2 id="getting-the-early-access-builds">Getting the Early-Access Builds</h2>

<p>To get started, go to <a href="https://jdk.java.net/valhalla/">jdk.java.net/valhalla</a> and download an early-access JDK build.
You can review the <a href="https://openjdk.org/projects/valhalla/early-access">release notes</a> for a quick summary of what’s included.</p>

<p>Unzip the package, put it somewhere handy, and refer to its <code class="language-plaintext highlighter-rouge">bin</code> directory to run commands like <code class="language-plaintext highlighter-rouge">java</code> and <code class="language-plaintext highlighter-rouge">javac</code>.
On my Mac, I’ll set an environment variable for easy access to these commands in the examples below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; export jdk401="$PWD/jdk-26.jdk/Contents/Home/bin"

% -&gt; "$jdk401"/java --version
openjdk 26-jep401ea2 2026-03-17
OpenJDK Runtime Environment (build 26-jep401ea2+1-1)
OpenJDK 64-Bit Server VM (build 26-jep401ea2+1-1, mixed mode, sharing)
</code></pre></div></div>

<h2 id="experimenting-with-value-objects">Experimenting with Value Objects</h2>

<p>As the JEP explains, <em>value objects</em> are instances of <em>value classes</em>, which have only <code class="language-plaintext highlighter-rouge">final</code> fields and lack object identity.
A handful of JDK classes, including <code class="language-plaintext highlighter-rouge">Integer</code> and <code class="language-plaintext highlighter-rouge">LocalDate</code>, become value classes when we run Java in preview mode.</p>

<p>In JShell, <code class="language-plaintext highlighter-rouge">Objects.hasIdentity</code> makes it easy to tell which objects are value objects and which are regular <em>identity objects</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/jshell --enable-preview
|  Welcome to JShell -- Version 26-jep401ea2
|  For an introduction type: /help intro

jshell&gt; Objects.hasIdentity(Integer.valueOf(123))
$1 ==&gt; false

jshell&gt; Objects.hasIdentity("abc")
$2 ==&gt; true

jshell&gt; Objects.hasIdentity(LocalDate.now())
$3 ==&gt; false

jshell&gt; Objects.hasIdentity(new ArrayList&lt;&gt;())
$4 ==&gt; true
</code></pre></div></div>

<p>Value objects behave just like identity objects in most ways.
But one difference is that <code class="language-plaintext highlighter-rouge">==</code> can’t tell whether two value objects are “the same object” or not—they have no identity to compare.
Instead, <code class="language-plaintext highlighter-rouge">==</code> tests whether two value objects are <em>statewise-equivalent</em>: instances of the same class with the same field values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jshell&gt; LocalDate d1 = LocalDate.now()
d1 ==&gt; 2025-10-23

jshell&gt; LocalDate d2 = d1.plusDays(365)
d2 ==&gt; 2026-10-23

jshell&gt; LocalDate d3 = d2.minusDays(365)
d3 ==&gt; 2025-10-23

jshell&gt; d1 == d3
$8 ==&gt; true
</code></pre></div></div>

<p>Statewise equivalence is no substitute for a meaningful <code class="language-plaintext highlighter-rouge">equals</code> method designed by a class author. In some cases, two instances of a value class with different states should still be considered equal. 
So the best practice, as usual, is to avoid the <code class="language-plaintext highlighter-rouge">==</code> operator and prefer <code class="language-plaintext highlighter-rouge">equals</code> for comparisons.</p>

<p>You can declare your own value classes with the <code class="language-plaintext highlighter-rouge">value</code> keyword.
Many record declarations are good candidates to be value classes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jshell&gt; value record Point(int x, int y) {}
|  created record Point

jshell&gt; Point p = new Point(17, 3)
p ==&gt; Point[x=17, y=3]

jshell&gt; Objects.hasIdentity(p)
$11 ==&gt; false

jshell&gt; new Point(17, 3) == p
$12 ==&gt; true
</code></pre></div></div>

<h3 id="value-object-performance">Value Object Performance</h3>

<p>Why bother to declare a value class instead of regular identity class?</p>

<p>One reason is a semantic one:
If your class represents immutable domain values that are interchangeable when they have the same state, giving these objects all the features of identity just adds unnecessary complexity.
Better to declare a value class and give up identity entirely.</p>

<p>But the most compelling reason is that the JVM can optimize value objects in ways that are impossible for regular objects.
For example, a reference to a value object doesn’t have to point to a canonical memory location for that object.
Instead, the state of the object can be <em>embedded in the reference itself</em>.
This technique is called <em>heap flattening</em>, and can make a huge difference in the cost of loading objects from memory.</p>

<p>As a test, let’s create a very large array of <code class="language-plaintext highlighter-rouge">LocalDate</code> value objects and add up all of their year values.
To simulate a realistic distribution of objects in memory, we’ll populate the array from an unsorted <code class="language-plaintext highlighter-rouge">HashSet</code> of <code class="language-plaintext highlighter-rouge">LocalDate</code> objects.
We can do some rudimentary profiling by tracking the wall-clock time required to iterate through the array.
(Note: For more accurate profiling, <a href="https://github.com/openjdk/jmh">JMH</a> should be used.)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">50_000_000</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">size</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="nc">LocalDate</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">makeArray</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">sumYears</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Attempt "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">/// Expensive task to be timed</span>
<span class="kt">long</span> <span class="nf">sumYears</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">[]</span> <span class="n">dates</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">d</span> <span class="o">:</span> <span class="n">dates</span><span class="o">)</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">d</span><span class="o">.</span><span class="na">getYear</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">/// Make an array of LocalDates, unpredictably ordered</span>
<span class="nc">LocalDate</span><span class="o">[]</span> <span class="nf">makeArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">LocalDate</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">.</span><span class="na">ofEpochDay</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">LocalDate</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
<span class="o">}</span>

<span class="c1">/// Run a task and report the elapsed wall-clock time in ms</span>
<span class="kt">double</span> <span class="nf">time</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="kt">var</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="k">return</span> <span class="nc">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">).</span><span class="na">toNanos</span><span class="o">()</span> <span class="o">/</span> <span class="mf">1_000_000.0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As a baseline, when I put this code in a <code class="language-plaintext highlighter-rouge">DateTest.java</code> file and run it on my MacBook Pro <em>without</em> preview features enabled, I get the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/java DateTest.java
Attempt 1: 82.703
Attempt 2: 77.716
Attempt 3: 74.959
Attempt 4: 71.962
Attempt 5: 71.915
</code></pre></div></div>

<p>When I turn on preview features, <code class="language-plaintext highlighter-rouge">LocalDate</code> becomes a value class, and its instances can be flattened directly in the array.
By avoiding extra memory loads, the JVM can achieve a nearly 3x speedup!:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/java --enable-preview DateTest.java
Attempt 1: 41.959
Attempt 2: 38.992
Attempt 3: 25.466
Attempt 4: 28.404
Attempt 5: 25.027
</code></pre></div></div>

<p>Results will vary on different machines and different array sizes.
But the point is that by using value objects in our performance-critical computation, we’ve enabled the JVM to make significant new optimizations that are impossible for identity objects.</p>

<h2 id="next-steps">Next Steps</h2>

<p>This is beta software, and it’s sure to have some bugs and surprising performance pitfalls.
Now is a great time for interested users to download the early-access build and try it out on their performance-sensitive workloads.
Feedback at <code class="language-plaintext highlighter-rouge">valhalla-dev@openjdk.org</code> is welcome and encouraged!</p>

<p>Of course, sprinkling the <code class="language-plaintext highlighter-rouge">value</code> keyword around a code base is not going to automatically address whatever performance bottlenecks the program faces.
Users are encouraged to review <a href="https://openjdk.org/jeps/401">JEP 401</a> to get a better sense of what kind of optimizations are possible, and use profiling tools like JDK Flight Recorder to see how value objects affect their program’s performance.</p>]]></content><author><name>[&quot;DanSmith&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[The Valhalla team recently published an early-access JDK build that fully implements JEP 401: Value Classes and Objects (Preview). Now is a great time for anyone who is interested to try out this transformative new feature!]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 517: HTTP/3 for the HTTP Client API</title><link href="https://inside.java/2025/10/26/jep517-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 517: HTTP/3 for the HTTP Client API" /><published>2025-10-26T00:00:00+00:00</published><updated>2025-10-26T00:00:00+00:00</updated><id>https://inside.java/2025/10/26/JEP517-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/10/26/jep517-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 517: HTTP/3 for the HTTP Client API</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?419002332" /></p>]]></content><author><name>[&quot;DanielFuchs&quot;]</name></author><category term="JDK 26" /><category term="Client" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 517: HTTP/3 for the HTTP Client API]]></summary></entry><entry><title type="html">Writing GPU-Ready AI Models in Pure Java with Babylon</title><link href="https://inside.java/2025/10/25/devoxxbelgium-writing-gpuready-ai-models-in-java/" rel="alternate" type="text/html" title="Writing GPU-Ready AI Models in Pure Java with Babylon" /><published>2025-10-25T00:00:00+00:00</published><updated>2025-10-25T00:00:00+00:00</updated><id>https://inside.java/2025/10/25/DevoxxBelgium-writing-gpuready-ai-models-in-java</id><content type="html" xml:base="https://inside.java/2025/10/25/devoxxbelgium-writing-gpuready-ai-models-in-java/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/DaMgGyfTSSw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Project Babylon enables developers to build and run AI models - such as LLMs, image classifiers, or object detection algorithms - directly in Java. With Code Reflection, machine learning logic can be defined in plain Java code, eliminating the need for Python or external model files.</em> 
<em>By leveraging the Foreign Function and Memory (FFM) API, Babylon can connect Java code to native runtimes like ONNX for fast, GPU-accelerated inference. Additionally, the Heterogeneous Accelerator Toolkit (HAT) enables developers to write and compose compute kernels in Java, making it easy for Java libraries to tap into GPU power for high-performance computing.</em></p>

<p><em>This session introduces Babylon’s upcoming features and demonstrates how you can integrate AI capabilities into the Java ecosystem, appealing to both library maintainers and developers looking to incorporate AI into their Java applications.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;, &quot;LizeRaes&quot;]</name></author><category term="AI" /><category term="Babylon" /><category term="Panama" /><summary type="html"><![CDATA[Project Babylon enables developers to build and run AI models - such as LLMs, image classifiers, or object detection algorithms - directly in Java. With Code Reflection, machine learning logic can be defined in plain Java code, eliminating the need for Python or external model files. By leveraging the Foreign Function and Memory (FFM) API, Babylon can connect Java code to native runtimes like ONNX for fast, GPU-accelerated inference. Additionally, the Heterogeneous Accelerator Toolkit (HAT) enables developers to write and compose compute kernels in Java, making it easy for Java libraries to tap into GPU power for high-performance computing. This session introduces Babylon’s upcoming features and demonstrates how you can integrate AI capabilities into the Java ecosystem, appealing to both library maintainers and developers looking to incorporate AI into their Java applications.]]></summary></entry><entry><title type="html">NUMA-Aware Relocation in ZGC</title><link href="https://inside.java/2025/10/24/zgc-numa-aware-relocation/" rel="alternate" type="text/html" title="NUMA-Aware Relocation in ZGC" /><published>2025-10-24T00:00:00+00:00</published><updated>2025-10-24T00:00:00+00:00</updated><id>https://inside.java/2025/10/24/zgc-numa-aware-relocation</id><content type="html" xml:base="https://inside.java/2025/10/24/zgc-numa-aware-relocation/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;JoelSikstrom&quot;]</name></author><category term="GC" /><category term="JDK 26" /><summary type="html"><![CDATA[NUMA-aware relocation is a feature recently added to ZGC, one of the garbage collectors in the OpenJDK, and is set to be released in JDK 26 through the introduction of JDK-8359683. Building on the recent memory allocation overhaul, this feature further enhances NUMA support and optimization in ZGC.]]></summary></entry><entry><title type="html">Three Upcoming G1 Improvements - Inside Java Newscast #99</title><link href="https://inside.java/2025/10/23/newscast-99/" rel="alternate" type="text/html" title="Three Upcoming G1 Improvements - Inside Java Newscast #99" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-10-23T00:00:00+00:00</updated><id>https://inside.java/2025/10/23/Newscast-99</id><content type="html" xml:base="https://inside.java/2025/10/23/newscast-99/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/w9mY8c72Ouk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Java’s (almost) default garbage collector G1 is undergoing even more improvements:</em> 
<em>From the already merged JEP 522, which introduces a second card table for improved throughput, and the candidate JEP 523,</em> 
<em>which aims to make G1 the default even where Serial GC used to be, to draft proposals for automatic heap sizing for G1 and ZGC.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=w9mY8c72Ouk">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="GC" /><summary type="html"><![CDATA[Java's (almost) default garbage collector G1 is undergoing even more improvements: From the already merged JEP 522, which introduces a second card table for improved throughput, and the candidate JEP 523, which aims to make G1 the default even where Serial GC used to be, to draft proposals for automatic heap sizing for G1 and ZGC.]]></summary></entry><entry><title type="html">HTTP/3 Support in JDK 26</title><link href="https://inside.java/2025/10/22/http3-support/" rel="alternate" type="text/html" title="HTTP/3 Support in JDK 26" /><published>2025-10-22T00:00:00+00:00</published><updated>2025-10-22T00:00:00+00:00</updated><id>https://inside.java/2025/10/22/HTTP3-Support</id><content type="html" xml:base="https://inside.java/2025/10/22/http3-support/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p>One new JDK 26 feature is that <code class="language-plaintext highlighter-rouge">HttpClient</code>, which has been part of Java SE since JDK 11, now supports HTTP/3.</p>

<p>Before discussing some API details, let’s briefly review what HTTP/3 is. From an HTTP protocol perspective, it is not vastly different from HTTP/2 in terms of features. However, the major difference lies in the underlying transport protocol: whereas HTTP/2 operates over <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>, HTTP/3 uses <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>. HTTP/3 is built on top of the QUIC protocol. For more details, please refer to <a href="https://openjdk.org/jeps/517">JEP 517</a>.</p>

<p><br /></p>
<h2 id="using-the-httpclient-api">Using the HttpClient API</h2>

<p>Let’s now see how to use HTTP/3 support with the <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient API</code>. If you have never used this API before, its <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.net.http/java/net/http/package-summary.html">Javadoc</a> is a good place to start.</p>

<p>In summary, an application creates a <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> instance and typically maintains it for the application’s lifetime. When issuing HTTP requests, the application code then builds a <code class="language-plaintext highlighter-rouge">java.net.http.HttpRequest</code> instance and uses the <code class="language-plaintext highlighter-rouge">HttpClient.send(...)</code> method to send the request and obtain a <code class="language-plaintext highlighter-rouge">java.net.http.HttpResponse</code>. In more advanced use cases where the application does not want to wait for the response, the <code class="language-plaintext highlighter-rouge">HttpClient.sendAsync(...)</code> method can be used to send the request asynchronously. This method returns a <code class="language-plaintext highlighter-rouge">java.util.concurrent.CompletableFuture</code>, which the application can use later to obtain the related <code class="language-plaintext highlighter-rouge">HttpResponse</code>.</p>

<p><code class="language-plaintext highlighter-rouge">HttpResponse</code> provides methods to retrieve the response body, the HTTP response code, the protocol version used, etc. A typical usage example is shown below:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a HttpClient instance</span>
<span class="o">...</span>
<span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">).</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a request instance</span>

<span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span> <span class="c1">// send the request and obtain the response as a String content</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span> <span class="c1">// print the response status code and the HTTP protocol version used</span>
</code></pre></div></div>

<p>None of this is new as this API has been around since JDK 11. So, let’s now see what’s new in JDK 26 and how to enable HTTP/3 support in <code class="language-plaintext highlighter-rouge">HttpClient</code>.</p>

<p>By default, the <code class="language-plaintext highlighter-rouge">HttpClient</code> (even in JDK 26) uses HTTP/2 as the preferred HTTP version when issuing requests. You can override the default per <code class="language-plaintext highlighter-rouge">HttpClient</code>-instance behavior by setting a preferred version. For example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_1_1</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>will construct a client that uses HTTP/1.1 as the preferred version for all requests it issues.
The HTTP protocol version set at the client level can also be overridden at the <code class="language-plaintext highlighter-rouge">HttpRequest</code> level as the following example.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>In this example, the <code class="language-plaintext highlighter-rouge">HttpClient</code> will use the preferred version specified by the <code class="language-plaintext highlighter-rouge">HttpRequest</code>, i.e., HTTP/2 in this case, when issuing the request.
If the server doesn’t support HTTP/2, the internal <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation will automatically downgrade the request to the HTTP/1.1 protocol, establish an HTTP/1.1 request/response exchange with the server, and provide the application with the related HTTP/1.1 response.</p>

<p>This behavior has been present in previous <code class="language-plaintext highlighter-rouge">HttpClient</code> implementations. What is new in JDK 26 is the introduction of a new protocol version value: <code class="language-plaintext highlighter-rouge">HttpClient.Version.HTTP_3</code>.
Applications can opt in to use the HTTP/3 protocol version by either setting it as a preferred version at the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance level:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>or on specific <code class="language-plaintext highlighter-rouge">HttpRequest</code> instance:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>In either case, when <code class="language-plaintext highlighter-rouge">HTTP_3</code> is set as the preferred version, the <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation will attempt to establish a UDP-based connection (since HTTP/3 operates over UDP) to the target server.
If that UDP-based QUIC connection attempt fails, either because the server does not support HTTP/3 or if the connection does not complete in a timely manner, 
the <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation will automatically downgrade the protocol version to HTTP/2 (over TCP) and attempt to complete the request using HTTP/2. 
If the server does not support HTTP/2, the request will be further downgraded to HTTP/1.1, as before.</p>

<p>So, the application code would look similar to what we saw previously with just one change, where the preferred version is set as HTTP/3 either when building the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance or when building the <code class="language-plaintext highlighter-rouge">HttpRequest</code> instance:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a HttpClient instance with HTTP/3 as the preferred version</span>
<span class="o">...</span>
<span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span> <span class="c1">// create a request instance</span>

<span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span> <span class="c1">// send the request and obtain the response as a String content</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> 
        <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span> <span class="c1">// print the response status code and the HTTP protocol version used</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="http-version-discovery">HTTP Version Discovery</h2>
<p>Please note that setting HTTP/3 as the preferred version does not guarantee that the request will use HTTP/3 as the protocol version.
This is why it is referred to as the “preferred” version. The <code class="language-plaintext highlighter-rouge">HttpClient</code> cannot determine in advance whether the server to which the request is sent actually supports HTTP/3.</p>

<p>Therefore for the first request, the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance will use an internal implementation specific algorithm which involves an attempt to establish a TCP based communication (HTTP/2) or a UDP based communication (HTTP/3) against that server. 
Whichever succeeds first will be used as the communication mode and thus decides which HTTP protocol version is used for that request.</p>

<p>For more information on HTTP/3 version discovery, please refer to the <a href="https://download.java.net/java/early_access/jdk26/docs/api/java.net.http/java/net/http/HttpOption.Http3DiscoveryMode.html">Http3DiscoveryMode</a> Javadoc.</p>

<p>With that background, let’s now look into a few specific cases and some code examples demonstrating the usage.</p>

<p>Let’s consider the case where the application wants to force the use of HTTP/3 - i.e. try and communicate with the server only through QUIC (i.e. over UDP) and then issue the HTTP/3 request. And if that fails, the connection should not be downgraded to HTTP/2. Applications would typically do this only when they are absolutely certain that the target server (represented by the host and port used in the request URI) supports HTTP/3 over that host/port combination.</p>

<p>For example, consider google.com as the server against which we will issue that request. Based on prior experiments, we know that google.com supports HTTP/3 at the same host/port where it supports HTTP/2 (or HTTP/1.1). Here’s what the code would look like in this case:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.net.http.HttpClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption.Http3DiscoveryMode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpClient.Version</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse.BodyHandlers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.URI</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="o">...</span>

<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                     <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span> <span class="c1">// configure HTTP/3 as the preferred version of the client</span>
                     <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                   <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
                   <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span> <span class="c1">// enforce that only HTTP/3 is used</span>
                   <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span> <span class="c1">// send the request and obtain the response as a String content</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span> <span class="c1">// print the response status code and the HTTP protocol version used</span>
</code></pre></div></div>

<p>Apart from configuring the HttpClient instance with version(<code class="language-plaintext highlighter-rouge">Version.HTTP_3</code>) as the preferred version, the other important detail in this code is the line where we configure the <code class="language-plaintext highlighter-rouge">HttpRequest</code> with:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span> <span class="c1">// enforce that only HTTP/3 is used</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">H3_DISCOVERY</code> option with a value of <code class="language-plaintext highlighter-rouge">Http3DiscoveryMode.HTTP_3_URI_ONLY</code> instructs the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance that this request must only use HTTP/3, and if it’s not possible, then the request should fail (with an exception).</p>

<p>At this point, we know for certain (and even demonstrated) that requests to www.google.com support HTTP/3, so the <code class="language-plaintext highlighter-rouge">HttpRequest</code> can enforce the use of HTTP/3 as shown below.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.net.http.HttpClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption.Http3DiscoveryMode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpClient.Version</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse.BodyHandlers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.URI</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Http3Usage</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">printRespHeaders</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"--print-response-headers"</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                         <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
                                         <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

            <span class="kd">final</span> <span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                       <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
                                       <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span>
                                       <span class="o">.</span><span class="na">build</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"issuing first request: "</span> <span class="o">+</span> <span class="n">req</span><span class="o">);</span>

            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstResp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"received response, status code: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> 
                    <span class="s">" HTTP protocol version used: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">printRespHeaders</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"response headers: "</span><span class="o">);</span>
                <span class="n">firstResp</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">().</span><span class="na">entrySet</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>When you use JDK 26 early access build and run this as:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">java Http3Usage.java
</span></code></pre></div></div>

<p>you should see the following output:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">issuing first request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_3
</span></code></pre></div></div>

<p>Notice that the response’s protocol version is HTTP_3, so it did indeed use HTTP/3 as the protocol version for that request.</p>

<p>Let’s now check what would have happened if we had not instructed the <code class="language-plaintext highlighter-rouge">HttpClient</code> to enforce the HTTP/3 usage. So, let’s remove (or comment out)  <code class="language-plaintext highlighter-rouge">.setOption(HttpOption.H3_DISCOVERY, Http3DiscoveryMode.HTTP_3_URI_ONLY)</code> from the above code and keep the rest of the code as-is.
When you do that and run that program again using <code class="language-plaintext highlighter-rouge">java Http3Usage.java</code> you should see the following output:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">issuing first request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_2
</span></code></pre></div></div>

<p>Notice the difference in the response’s protocol version: even though HTTP/3 was set as the preferred version, the request/response exchange used HTTP/2. As mentioned earlier, this is expected behavior because the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance cannot guarantee that the server at the given host and port supports the “preferred” HTTP/3 version. Therefore, the <code class="language-plaintext highlighter-rouge">HttpClient</code> implementation used used an internal algorithm which ended up establishing a TCP based connection first and thus using it to issue the HTTP/2 request.</p>

<p>Taking this example a step further, some of you might wonder whether, over time, the <code class="language-plaintext highlighter-rouge">HttpClient</code> can learn that a server at a particular host and port supports HTTP/3.</p>

<p>The answer is yes, there are several mechanisms for this. In fact, the “HTTP Alternative Services” standard (<a href="https://datatracker.ietf.org/doc/html/rfc7838">RFC 7838 </a>) defines one such approach.  HTTP Alternative Services (referred to as “Alt-Services” from now on) is a standard mechanism that allows servers to advertise alternative services they support. The RFC outlines several methods for advertising alternative services. One common approach is for the server to include an HTTP response header named “alt-svc” in response to some HTTP requests. The response header value should contain details about the Alt-Services the server supports and the host/port combination where each is supported.</p>

<p>For example, an “alt-svc” header of the following form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alt-svc=h3=":443"
</code></pre></div></div>

<p>indicates that the server on the host, which was used for the HTTP request, at port 443 supports HTTP/3 protocol (h3 represents an ALPN for HTTP/3 support).
When such a response header is advertised by the server, the <code class="language-plaintext highlighter-rouge">HttpClient</code> recognizes this as a standard header and makes note of this detail.
So, the next time a request is issued to the same server and port, <code class="language-plaintext highlighter-rouge">HttpClient</code> will check its internal registry to determine if an “h3” Alt-Service was previously advertised for that server. If so, it will attempt to establish the HTTP/3 connection using the alternate host and port.</p>

<p>Let’s see this behavior in action. As before, we’ll configure the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance with HTTP/3 as the preferred version, but this time we will not enforce HTTP/3 on the <code class="language-plaintext highlighter-rouge">HttpRequest</code>. We will then send 2 requests to the same Google URI using the same <code class="language-plaintext highlighter-rouge">HttpClient</code> instance and observe how it behaves.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.net.http.HttpClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpOption.Http3DiscoveryMode</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpClient.Version</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse.BodyHandlers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.http.HttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.URI</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Http3Usage</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">printRespHeaders</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"--print-response-headers"</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">(</span><span class="kd">final</span> <span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                         <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
                                         <span class="o">.</span><span class="na">build</span><span class="o">())</span> <span class="o">{</span>

            <span class="kd">final</span> <span class="no">URI</span> <span class="n">reqURI</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
                                       <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">reqURI</span><span class="o">)</span>
                                       <span class="o">.</span><span class="na">build</span><span class="o">();</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"issuing first request: "</span> <span class="o">+</span> <span class="n">req</span><span class="o">);</span>

            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandler</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">bodyHandler</span> <span class="o">=</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstResp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"received response, status code: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> 
                    <span class="s">" HTTP protocol version used: "</span> <span class="o">+</span> <span class="n">firstResp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">printRespHeaders</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"response headers: "</span><span class="o">);</span>
                <span class="n">firstResp</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">().</span><span class="na">entrySet</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"issuing second request: "</span> <span class="o">+</span> <span class="n">req</span><span class="o">);</span>

            <span class="kd">final</span> <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">secondResp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">bodyHandler</span><span class="o">);</span>

            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"received response, status code: "</span> <span class="o">+</span> <span class="n">secondResp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> 
                    <span class="o">+</span> <span class="s">" HTTP protocol version used: "</span> <span class="o">+</span> <span class="n">secondResp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">printRespHeaders</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"response headers: "</span><span class="o">);</span>
                <span class="n">secondResp</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">().</span><span class="na">entrySet</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s run it again with a JDK 26 EA build.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">java Http3Usage.java
</span></code></pre></div></div>

<p>This command should output the following:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">issuing first request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_2
issuing second request: https://www.google.com/ GET
received response, status code: 200 HTTP protocol version used: HTTP_3
</span></code></pre></div></div>

<p>Notice that the first request used HTTP/2, and the second request against the same request URI, using the same <code class="language-plaintext highlighter-rouge">HttpClient</code> instance, used the preferred HTTP/3 version. That demonstrates that the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance can determine whether a server at a particular host/port supports HTTP/3 and then use that knowledge to issue HTTP/3 requests against that server, if the application prefers that protocol version.</p>

<p>Earlier, we discussed how servers advertise Alt-Services through response headers. Since our code has access to the <code class="language-plaintext highlighter-rouge">HttpResponse</code>, let’s check whether www.google.com actually advertised the “h3” Alt-Service in its response headers.</p>

<p>The code above will output response headers when it is launched with the <code class="language-plaintext highlighter-rouge">--print-response-headers</code> program argument.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">java Http3Usage.java --print-response-headers
</span></code></pre></div></div>

<p>You can see that the first request/response exchange ended up using HTTP/2, while the second request/response exchange used HTTP/3.
You will see many more lines in the output, as all the response headers from the <code class="language-plaintext highlighter-rouge">HttpResponse</code> are printed. Among these lines, if you search for “alt-svc,” you should find:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alt-svc=[h3=":443"; ma=2592000,h3-29=":443"; ma=2592000]
</code></pre></div></div>

<p>So www.google.com responded to the request and included this additional response header advertising the Alt-Service representing HTTP/3 support.</p>

<p>There are more ways the <code class="language-plaintext highlighter-rouge">HttpClient</code> instance can discover HTTP/3 support, but those are beyond the scope of this article.</p>

<p><br /></p>
<h2 id="conclusion">Conclusion</h2>

<p>Support for HTTP/3 in Java’s <code class="language-plaintext highlighter-rouge">HttpClient</code> has been integrated into the mainline JDK repository and is available in the <a href="https://jdk.java.net/26/">JDK 26 early access builds</a>.</p>

<p>Although the API enhancement appears trivial from a usage perspective (by design), supporting QUIC and subsequently HTTP/3 on top of QUIC represents the result of several years of development effort within the JDK.</p>

<p>New tests have been added, and extensive manual testing has been conducted. However, this implementation is still new and has not seen much usage outside of the JDK development team. If the HTTP/3 support in JDK’s <code class="language-plaintext highlighter-rouge">HttpClient</code> is of interest to you, it will be very valuable if you run your applications/experiments using an <a href="https://jdk.java.net/26/">early access build of JDK 26</a> and provide any feedback/bug reports on the <a href="https://mail.openjdk.org/mailman/listinfo/net-dev">net-dev</a> OpenJDK mailing list.</p>

<p><br />~<br /></p>

<p><i>This article was originally published <a href="https://jaitechwriteups.blogspot.com/2025/10/http3-support-now-available-in-java-httpclient.html">here</a>.</i></p>]]></content><author><name>[&quot;JaikiranPai&quot;]</name></author><category term="JDK 26" /><category term="Networking" /><summary type="html"><![CDATA[One new JDK 26 feature is that `HttpClient`, which has been part of Java SE since JDK 11, now supports HTTP/3...]]></summary></entry></feed>