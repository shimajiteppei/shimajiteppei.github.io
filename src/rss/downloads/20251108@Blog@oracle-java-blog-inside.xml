<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-11-08T09:05:35+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Pulling the (Foreign) String</title><link href="https://inside.java/2025/11/08/ffm-string/" rel="alternate" type="text/html" title="Pulling the (Foreign) String" /><published>2025-11-08T00:00:00+00:00</published><updated>2025-11-08T00:00:00+00:00</updated><id>https://inside.java/2025/11/08/FFM-String</id><content type="html" xml:base="https://inside.java/2025/11/08/ffm-string/"><![CDATA[<p>The Foreign Function &amp; Memory (FFM) API comes equipped with methods to read, writes strings from/to memory segments, as well as to allocate memory segments from existing Java strings. In this document we’ll explore ways in which we can enhance the FFM API to support more efficient interoperability between strings and memory segments…</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg?524354282" /></p>]]></content><author><name>[&quot;MaurizioCimadamore&quot;]</name></author><category term="Panama" /><summary type="html"><![CDATA[The Foreign Function & Memory (FFM) API comes equipped with methods to read, writes strings from/to memory segments, as well as to allocate memory segments from existing Java strings. In this document we'll explore ways in which we can enhance the FFM API to support more efficient interoperability between strings and memory segments...]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 500: Prepare to Make Final Mean Final</title><link href="https://inside.java/2025/11/07/jep500-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 500: Prepare to Make Final Mean Final" /><published>2025-11-07T00:00:00+00:00</published><updated>2025-11-07T00:00:00+00:00</updated><id>https://inside.java/2025/11/07/JEP500-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/07/jep500-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 500: Prepare to Make Final Mean Final</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?521160719" /></p>]]></content><author><name>[&quot;RonPressler&quot;, &quot;AlexBuckley&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><category term="Java Language" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 500: Prepare to Make Final Mean Final]]></summary></entry><entry><title type="html">Try the New Valhalla EA Build - Inside Java Newscast #100</title><link href="https://inside.java/2025/11/06/newscast-100/" rel="alternate" type="text/html" title="Try the New Valhalla EA Build - Inside Java Newscast #100" /><published>2025-11-06T00:00:00+00:00</published><updated>2025-11-06T00:00:00+00:00</updated><id>https://inside.java/2025/11/06/Newscast-100</id><content type="html" xml:base="https://inside.java/2025/11/06/newscast-100/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/Eua3nTkye2Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>JEP 401, Value Classes and Objects, has recently re-entered “candidate” status and is getting ready to target a release.</em> 
<em>In preparation, Project Valhalla published a new early-access build that allows you to experiment with identity-less value classes in Java.</em> 
<em>A value class’ lack of identity not only comes with readability and maintenance benefits for developers (where their limitations apply) but also gives the Java runtime the space it needs for more optimizations - scalarization and some heap flattening for now, although more is planned for the future.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=Eua3nTkye2Y">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[JEP 401, Value Classes and Objects, has recently re-entered "candidate" status and is getting ready to target a release. In preparation, Project Valhalla published a new early-access build that allows you to experiment with identity-less value classes in Java. A value class' lack of identity not only comes with readability and maintenance benefits for developers (where their limitations apply) but also gives the Java runtime the space it needs for more optimizations - scalarization and some heap flattening for now, although more is planned for the future.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization</title><link href="https://inside.java/2025/11/05/jep522-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization" /><published>2025-11-05T00:00:00+00:00</published><updated>2025-11-05T00:00:00+00:00</updated><id>https://inside.java/2025/11/05/JEP522-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/05/jep522-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?512998386" /></p>]]></content><author><name>[&quot;IvanWalulya&quot;, &quot;ThomasSchatzl&quot;]</name></author><category term="JDK 26" /><category term="GC" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 522: G1 GC: Improve Throughput by Reducing Synchronization]]></summary></entry><entry><title type="html">Integrity by Default</title><link href="https://inside.java/2025/11/04/javaone-integrity-by-default/" rel="alternate" type="text/html" title="Integrity by Default" /><published>2025-11-04T00:00:00+00:00</published><updated>2025-11-04T00:00:00+00:00</updated><id>https://inside.java/2025/11/04/JavaOne-Integrity-By-Default</id><content type="html" xml:base="https://inside.java/2025/11/04/javaone-integrity-by-default/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/uTPRTkny7kQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>To assist performance, portability, and security, the Java Platform is progressing toward a state where its abstractions, as well as programmer-defined abstractions, can be made robust and invariants can be locally guaranteed. Libraries may violate some invariants but only if selectively allowed by the application. This session covers the why and how of the vision of “Integrity by Default”.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzVV1xRJkRbcM2tOgVwytJAi">JavaOne 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;RonPressler&quot;]</name></author><category term="Core Libraries" /><category term="Security" /><summary type="html"><![CDATA[To assist performance, portability, and security, the Java Platform is progressing toward a state where its abstractions, as well as programmer-defined abstractions, can be made robust and invariants can be locally guaranteed. Libraries may violate some invariants but only if selectively allowed by the application. This session covers the why and how of the vision of "Integrity by Default".]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 25: Consistent Behavior of ‘new File(“”)’</title><link href="https://inside.java/2025/11/03/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 25: Consistent Behavior of ‘new File(“”)’" /><published>2025-11-03T00:00:00+00:00</published><updated>2025-11-03T00:00:00+00:00</updated><id>https://inside.java/2025/11/03/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/11/03/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of a <a href="https://mail.openjdk.org/pipermail/quality-discuss/2025-February/001141.html">regular communication</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="inconsistencies-of-new-file">Inconsistencies of ‘new File(“”)’</h2>

<p>On JDK 24 and earlier, the behavior of a <code class="language-plaintext highlighter-rouge">File</code> instance created from the empty string was inconsistent.
Queried for information, it appeared to be non-existent:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "false" on JDK 24</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>Similarly, methods like <code class="language-plaintext highlighter-rouge">canRead</code> returned <code class="language-plaintext highlighter-rouge">false</code> and <code class="language-plaintext highlighter-rouge">length</code>, <code class="language-plaintext highlighter-rouge">lastModified</code>, etc. returned <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>When transformed to an instance representing the absolute path, the behavior changed, though:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">).</span><span class="na">getAbsoluteFile</span><span class="o">();</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>The reason is that <code class="language-plaintext highlighter-rouge">new File("").getAbsoluteFile()</code> maps to the current user directory and the <code class="language-plaintext highlighter-rouge">File</code> API behaves accordingly.
Since <code class="language-plaintext highlighter-rouge">new File("")</code> and <code class="language-plaintext highlighter-rouge">new File("").getAbsoluteFile()</code> should represent the same file system entry, this inconsistency is jarring and can be surprising.</p>

<p>The newer API in <code class="language-plaintext highlighter-rouge">java.nio.file</code> avoids this issue and treats both <code class="language-plaintext highlighter-rouge">Path.of("")</code> and <code class="language-plaintext highlighter-rouge">Path.of("").toAbsolutePath()</code> as the current user directory.
For example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">();</span>
<span class="c1">// print "true"</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">(</span><span class="n">path</span><span class="o">));</span>
</code></pre></div></div>

<h2 id="change-in-jdk-25">Change in JDK 25</h2>

<p>JDK 25 fixed this long-standing inconsistency and <code class="language-plaintext highlighter-rouge">new File("")</code> now properly represents the current user directory:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
<span class="c1">// print "true" on JDK 25</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">());</span>
<span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">());</span>
</code></pre></div></div>

<p>The <a href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/File.html">Javadoc for <code class="language-plaintext highlighter-rouge">File</code></a> was updated to spell out the intended behavior:</p>

<blockquote>
  <p>Accessing a file with the empty abstract pathname is equivalent to accessing the current user directory.</p>
</blockquote>

<p>For more details, check <a href="https://bugs.openjdk.org/browse/JDK-8024695">JDK-8024695</a>.</p>

<h2 id="migration">Migration</h2>

<p>Code that relies on the old behavior is often found in unit tests (e.g. to intentionally create non-existent files with <code class="language-plaintext highlighter-rouge">new File("")</code>) or where user input is mapped to file system entries (e.g. to treat “no user entry” and “invalid user entry” the same: as an absent file).
Here it may show itself through misbehavior around file-related arguments or configuration.</p>

<p>While fixing such code should be straightforward, identifying it may not be - a thorough test suite helps.
For dependencies and tools, the recommendation is to rely on their tests and statements regarding JDK 25 compatibility.
Only they can fix potential issues as there is no way to restore the inconsistent behavior of JDK 24 and earlier.</p>

<center>~</center>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 25" /><category term="Core Libraries" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers the behavioral change of `File` instances that were created from the empty path.]]></summary></entry><entry><title type="html">Supercharge your JVM Performance with Project Leyden and Spring Boot</title><link href="https://inside.java/2025/11/02/devoxxbelgium-leyden-supercharge-jvm-performance/" rel="alternate" type="text/html" title="Supercharge your JVM Performance with Project Leyden and Spring Boot" /><published>2025-11-02T00:00:00+00:00</published><updated>2025-11-02T00:00:00+00:00</updated><id>https://inside.java/2025/11/02/DevoxxBelgium-leyden-supercharge-jvm-performance</id><content type="html" xml:base="https://inside.java/2025/11/02/devoxxbelgium-leyden-supercharge-jvm-performance/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/izLzgnMMjbU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Many modern applications and tools rely on Java. Yet, their startup time and time-to-peak performance remain challenging, especially for microservices and Kubernetes workloads that require fast scaling and responsiveness. Project Leyden, an ambitious OpenJDK initiative, aims to overcome these performance bottlenecks.</em></p>

<p><em>In this session, Ana and Moritz show how you can take advantage of Leyden’s optimizations using Java 25 and Spring Boot. You also get practical techniques you can apply today, along with a peek into the ongoing work inside Leyden and what that means for the performance of your Java application.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 25" /><category term="Leyden" /><category term="Performance" /><summary type="html"><![CDATA[Many modern applications and tools rely on Java. Yet, their startup time and time-to-peak performance remain challenging, especially for microservices and Kubernetes workloads that require fast scaling and responsiveness. Project Leyden, an ambitious OpenJDK initiative, aims to overcome these performance bottlenecks. In this session, Ana and Moritz show how you can take advantage of Leyden’s optimizations using Java 25 and Spring Boot. You also get practical techniques you can apply today, along with a peek into the ongoing work inside Leyden and what that means for the performance of your Java application.]]></summary></entry><entry><title type="html">Value Classes Heap Flattening - What to expect from JEP 401 #JVMLS</title><link href="https://inside.java/2025/10/31/jvmls-jep-401/" rel="alternate" type="text/html" title="Value Classes Heap Flattening - What to expect from JEP 401 #JVMLS" /><published>2025-10-31T00:00:00+00:00</published><updated>2025-10-31T00:00:00+00:00</updated><id>https://inside.java/2025/10/31/JVMLS-JEP-401</id><content type="html" xml:base="https://inside.java/2025/10/31/jvmls-jep-401/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/NF4CpL_EWFI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>The initial flattening in Project Valhalla relied on four property value types had at the time: lack of identity, immutability, null-freeness, and non-atomicity.</em> 
<em>As our understanding of value types improved, we realized that null-freeness was not a property inherently part of value types, and that non-atomicity was too challenging to include in the Java language for a first release. So, <a href="https://openjdk.org/jeps/401">JEP 401</a> defines value class instances as identity-less and (mostly) immutable. The value class model has also been relaxed, allowing field inheritance through abstract value classes. All these modifications, combined with the constraints of the Java Memory Model and the limitations of current hardware, created new challenges for the JVM to be able to flatten values. New flattening schemes had to be developed and are presented in the talk.</em></p>

<p><em>As the Valhalla team explored new flattening solutions, it became obvious that flattening is a multi-faceted problem. Flattening is beneficial to memory density: by removing object headers and the indirection pointer, Java heap space is used more efficiently. The spatial locality of the value and its container can lead to better cache efficiency, but a flat value can also have a higher access cost than a non-flat value, especially if properties such as nullability and atomicity must be guaranteed. Memory density can also be improved by using clever encodings to make the most of every bit of the flat representation. However, complex encodings usually have a higher access cost and have a significant impact on the code complexity in the JVM. The talk will explain the different trade-offs JVM engineers had to make when implementing the flattening policies.</em></p>

<p><em>With an improved prototype, benchmarks helped us understand the kinds of improvements flattening can provide, and which scenarios can be negatively impacted. Flat arrays accessed by C2 compiled code were, and remain, the ideal scenario for achieving a significant boost in application raw performance. Field flattening initially performed poorly in comparison until its impact on GC workload was measured. Finally, if C2 is able to exploit flat values to their maximum, other VM components like the interpreter, the runtime, or even C1 have a much harder time handling flat values, possibly leading to performance regressions—an aspect to consider when maintaining good startup times.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;FredericParain&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[Project Valhalla's approach to flattening value types has evolved significantly, driven by a deeper understanding of value type semantics, challenges in the Java language and the JVM.]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API</title><link href="https://inside.java/2025/10/30/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API" /><published>2025-10-30T00:00:00+00:00</published><updated>2025-10-30T00:00:00+00:00</updated><id>https://inside.java/2025/10/30/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/10/30/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of the <a href="https://mail.openjdk.org/pipermail/quality-discuss/">quality outreach</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="http3-support-in-httpclient">HTTP/3 Support in HttpClient</h2>

<p>The <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> API allows Java applications to create reusable HTTP client instances, build HTTP requests, and handle responses synchronously or asynchronously. 
Since JDK 11, you can set the preferred HTTP protocol versions like HTTP/1.1 or HTTP/2 at the <code class="language-plaintext highlighter-rouge">HttpClient</code> or <code class="language-plaintext highlighter-rouge">HttpRequest</code> level.</p>

<p><a href="https://openjdk.org/jeps/517">JEP 517</a> introduces support for HTTP/3 (<code class="language-plaintext highlighter-rouge">HttpClient.Version.HTTP_3</code>) in JDK 26, enabling applications to prefer or enforce HTTP/3 for requests.
While HTTP/3 offers similar features to HTTP/2 at the protocol level, its key difference is that it runs over the QUIC protocol using UDP, whereas HTTP/2 operates over TCP.
Below is a code snippet on how you can prefer and/or enforce HTTP/3:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// prefer HTTP/3</span>
<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// if target server support HTTP/3, add this to enforce it</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>
</code></pre></div></div>

<p>If you set HTTP/3 but it is not available, the client will automatically downgrade to HTTP/2 or HTTP/1.1.
If you configure to strictly require HTTP/3, a failed attempt leads to an exception rather than a downgrade.</p>

<p>However, setting HTTP/3 as the preferred version does not guarantee its use, as the client cannot know beforehand if the server supports it. 
For the first request to a server, the client tries both TCP (HTTP/2) and UDP (HTTP/3) connections and uses whichever succeeds first. 
Over time, the <code class="language-plaintext highlighter-rouge">HttpClient</code> can “learn” about the HTTP version(s) that a server supports by using the “Alt-Svc” mechanism (the “HTTP Alternative Services” standard per <a href="https://datatracker.ietf.org/doc/html/rfc7838">RFC 7838</a>). 
Servers supporting “Alt-Svc” advertise alternative supported protocols such as HTTP/3. This allows subsequent requests to that server to use HTTP/3 when supported. For more details on this mechanism, see <a href="https://inside.java/2025/10/22/http3-support/">this article</a>.</p>

<h2 id="call-to-action">Call to Action</h2>

<p>Although the enhancements to the HTTP Client API appear simple to use, supporting HTTP/3 on top of QUIC represents the result of several years of dedicated development effort within the JDK team.
As this implementation is still new, we encourage you to download the <a href="https://jdk.java.net/26/">Java 26 Early Access builds</a>, try this feature, and share your feedback through the <a href="https://mail.openjdk.org/mailman/listinfo/net-dev">net-dev OpenJDK mailing list</a> (registration required).</p>

<center>~</center>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 26" /><category term="Networking" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers the HTTP/3 support in JDK 26.]]></summary></entry><entry><title type="html">AI World: Georges Saab Unveils Java 25 for AI and Cloud</title><link href="https://inside.java/2025/10/29/aiworld-java-for-ai/" rel="alternate" type="text/html" title="AI World: Georges Saab Unveils Java 25 for AI and Cloud" /><published>2025-10-29T00:00:00+00:00</published><updated>2025-10-29T00:00:00+00:00</updated><id>https://inside.java/2025/10/29/AIWorld-java-for-ai</id><content type="html" xml:base="https://inside.java/2025/10/29/aiworld-java-for-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/a1aro8bq30o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.</em></p>

<p><em>Java is trusted by millions of developers worldwide and remains the backbone of enterprise systems and emerging AI-powered workloads. In this special segment from Oracle TV at Oracle AI World 2025, Georges Saab, Senior Vice President of Development of the Java Platform, highlights the latest features in Java 25 and their impact on developers, IT leaders, and businesses at scale.</em></p>

<p><em>Georges explains the major innovations in Java 25, Oracle’s approach to evolving and supporting the Java language, platform, and ecosystem, and the important role of GraalVM’s alternative runtime. Learn how the Java 25 long-term support (LTS) release enables organizations to modernize legacy applications and embrace cloud-first and multi-cloud strategies. Discover how new features in Java 25 make it easier to build, deploy, and run AI-driven and cloud-native solutions—driving agility and business value. Georges also provides a preview of what’s coming in Java 26, reinforcing Java’s ongoing six-month release cadence and its future in the enterprise and beyond.</em></p>]]></content><author><name>[&quot;GeorgesSaab&quot;]</name></author><category term="AI" /><category term="Cloud" /><category term="Oracle" /><summary type="html"><![CDATA[Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.]]></summary></entry></feed>