<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-11-27T07:26:29+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">JEP targeted to JDK 26: 526: Lazy Constants (Second Preview)</title><link href="https://inside.java/2025/11/27/jep526-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 526: Lazy Constants (Second Preview)" /><published>2025-11-27T00:00:00+00:00</published><updated>2025-11-27T00:00:00+00:00</updated><id>https://inside.java/2025/11/27/JEP526-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/27/jep526-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 526: Lazy Constants (Second Preview)</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?146676438" /></p>]]></content><author><name>[&quot;Per-AkeMinborg&quot;, &quot;MaurizioCimadamore&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 526: Lazy Constants (Second Preview)]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 26: HttpClient Supports TLS Named Groups &amp;amp; Signature Schemes</title><link href="https://inside.java/2025/11/26/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 26: HttpClient Supports TLS Named Groups &amp;amp; Signature Schemes" /><published>2025-11-26T00:00:00+00:00</published><updated>2025-11-26T00:00:00+00:00</updated><id>https://inside.java/2025/11/26/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/11/26/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of the <a href="https://mail.openjdk.org/pipermail/quality-discuss/">quality outreach</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="tls-named-groups-and-signature-schemes-setup-for-httpclient">TLS Named Groups and Signature Schemes Setup for HttpClient</h2>

<p>Java applications can configure TLS constraints on <code class="language-plaintext highlighter-rouge">javax.net.ssl.SSLParameters</code> during the setup of new connections.
Yet, as of now, <code class="language-plaintext highlighter-rouge">HttpClient</code> ignores named groups and signature schemes set on <code class="language-plaintext highlighter-rouge">SSLParameters</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">restrictedNamedGroups</span> <span class="o">=</span> <span class="o">{</span><span class="s">"x25519"</span><span class="o">,</span><span class="s">"x448"</span><span class="o">};</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">preferredSignatureScheme</span> <span class="o">=</span> <span class="o">{</span><span class="s">"ed25519"</span><span class="o">,</span><span class="s">"ed448"</span><span class="o">};</span>

<span class="kd">final</span> <span class="nc">SSLParameters</span> <span class="n">sslParameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SSLParameters</span><span class="o">();</span>
<span class="n">sslParameters</span><span class="o">.</span><span class="na">setNamedGroups</span><span class="o">(</span><span class="n">restrictedNamedGroups</span><span class="o">);</span>
<span class="n">sslParameters</span><span class="o">.</span><span class="na">setSignatureSchemes</span><span class="o">(</span><span class="n">preferredSignatureScheme</span><span class="o">);</span>

<span class="nc">SSLContext</span> <span class="n">sslContext</span> <span class="o">=</span> <span class="nc">SSLContext</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>

<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">sslContext</span><span class="o">(</span><span class="n">sslContext</span><span class="o">)</span>
    <span class="o">.</span><span class="na">sslParameters</span><span class="o">(</span><span class="n">sslParameters</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>Starting with JDK 26, the <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> preserves the signature schemes and named groups configured via <code class="language-plaintext highlighter-rouge">SSLParameters</code> when negotiating the TLS handshake.</p>

<p>This fix has been incorporated into the 26-ea mainline build available <a href="https://jdk.java.net/26/">here</a>. For more details on this change, check the JBS issue: <a href="https://bugs.openjdk.org/browse/JDK-8367112">JDK-8367112</a>.</p>

<center>~</center>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 26" /><category term="Security" /><category term="Networking" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers how HttpClient supports TLS signature schemes and named groups configured on SSLParameters.]]></summary></entry><entry><title type="html">ONNX Based Generative AI LLMs in Java with Project Babylon</title><link href="https://inside.java/2025/11/25/devoxxbelgium-java-generative-ai/" rel="alternate" type="text/html" title="ONNX Based Generative AI LLMs in Java with Project Babylon" /><published>2025-11-25T00:00:00+00:00</published><updated>2025-11-25T00:00:00+00:00</updated><id>https://inside.java/2025/11/25/DevoxxBelgium-Java-Generative-AI</id><content type="html" xml:base="https://inside.java/2025/11/25/devoxxbelgium-java-generative-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/4grpNophot0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>The Open Neural Network Exchange (ONNX) serves as a universal format for representing machine learning models, facilitating their deployment across diverse platforms. Traditionally, Large Language Models (LLMs) are developed in Python using frameworks like PyTorch, TensorFlow, or scikit-learn, and then exported to ONNX for execution.</em></p>

<p><em>In this presentation, we demonstrate how Java, a language not traditionally associated with AI modeling, can be utilized to produce ONNX models. We also explore the concept of ONNX-based Generative AI LLMs in Java, leveraging Project Babylon’s code reflection capabilities.</em></p>

<p><em>The presentation showcases a practical Java example of an LLM, detailing its transformation into the ONNX format and subsequent execution.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;AdamSotona&quot;]</name></author><category term="AI" /><category term="Babylon" /><summary type="html"><![CDATA[The Open Neural Network Exchange (ONNX) serves as a universal format for representing machine learning models, facilitating their deployment across diverse platforms. Traditionally, Large Language Models (LLMs) are developed in Python using frameworks like PyTorch, TensorFlow, or scikit-learn, and then exported to ONNX for execution. In this presentation, we demonstrate how Java, a language not traditionally associated with AI modeling, can be utilized to produce ONNX models. We also explore the concept of ONNX-based Generative AI LLMs in Java, leveraging Project Babylon's code reflection capabilities. The presentation showcases a practical Java example of an LLM, detailing its transformation into the ONNX format and subsequent execution.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 525: Structured Concurrency (6th Preview)</title><link href="https://inside.java/2025/11/24/jep525-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 525: Structured Concurrency (6th Preview)" /><published>2025-11-24T00:00:00+00:00</published><updated>2025-11-24T00:00:00+00:00</updated><id>https://inside.java/2025/11/24/JEP525-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/24/jep525-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 525: Structured Concurrency (Sixth Preview)</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?134328555" /></p>]]></content><author><name>[&quot;AlanBateman&quot;, &quot;ViktorKlang&quot;, &quot;RonPressler&quot;]</name></author><category term="JDK 26" /><category term="Loom" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 525: Structured Concurrency (Sixth Preview)]]></summary></entry><entry><title type="html">Symbolic Modeling and Transformation of Java Code #JVMLS</title><link href="https://inside.java/2025/11/22/jvmls-symbolic-modelling-java-transformation/" rel="alternate" type="text/html" title="Symbolic Modeling and Transformation of Java Code #JVMLS" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://inside.java/2025/11/22/JVMLS-Symbolic-Modelling-Java-Transformation</id><content type="html" xml:base="https://inside.java/2025/11/22/jvmls-symbolic-modelling-java-transformation/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/jbXobiQN8Fw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This session explores code reflection in Project Babylon, demonstrating how Java code can be symbolically modeled as Java code models. It covers the underlying approach, highlights key advantages, and discusses potential limitations.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;PaulSandoz&quot;]</name></author><category term="Babylon" /><summary type="html"><![CDATA[This session explores code reflection in Project Babylon, demonstrating how Java code can be symbolically modeled as Java code models. It covers the underlying approach, highlights key advantages, and discusses potential limitations.]]></summary></entry><entry><title type="html">Java 26 Warns of Deep Reflection - Inside Java Newscast #101</title><link href="https://inside.java/2025/11/20/newscast-101/" rel="alternate" type="text/html" title="Java 26 Warns of Deep Reflection - Inside Java Newscast #101" /><published>2025-11-20T00:00:00+00:00</published><updated>2025-11-20T00:00:00+00:00</updated><id>https://inside.java/2025/11/20/Newscast-101</id><content type="html" xml:base="https://inside.java/2025/11/20/newscast-101/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/bdHkbEIdBAs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Java 26 will issue run-time warnings when a final field is mutated through reflection. This prepares for a future change that will make such final field mutations illegal by default to improve Java’s integrity, specifically the keyword <code class="language-plaintext highlighter-rouge">final</code>. 
This will have beneficial effects on maintainability, security, and performance. While the recommendation is to move away from final field mutation, the new permanent command-line option <code class="language-plaintext highlighter-rouge">--enable-final-field-mutation</code> allows it for selected modules. To ease migration, the more general but temporary option <code class="language-plaintext highlighter-rouge">--illegal-final-field-mutation</code> was also introduced.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=bdHkbEIdBAs">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="Integrity by Default" /><summary type="html"><![CDATA[Java 26 will issue run-time warnings when a final field is mutated through reflection. This prepares for a future change that will make such final field mutations illegal by default to improve Java's integrity, specifically the keyword final. This will have beneficial effects on maintainability, security, and performance. While the recommendation is to move away from final field mutation, the new permanent command-line option --enable-final-field-mutation allows it for selected modules. To ease migration, the more general but temporary option --illegal-final-field-mutation was also introduced.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)</title><link href="https://inside.java/2025/11/17/jep524-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)" /><published>2025-11-17T00:00:00+00:00</published><updated>2025-11-17T00:00:00+00:00</updated><id>https://inside.java/2025/11/17/JEP524-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/17/jep524-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?123344012" /></p>]]></content><author><name>[&quot;AnthonyScarpino&quot;]</name></author><category term="JDK 26" /><category term="Security" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)]]></summary></entry><entry><title type="html">Beyond the Vector API - A Quest for a Lower Level API #JVMLS</title><link href="https://inside.java/2025/11/16/jvmls-vector-api/" rel="alternate" type="text/html" title="Beyond the Vector API - A Quest for a Lower Level API #JVMLS" /><published>2025-11-16T00:00:00+00:00</published><updated>2025-11-16T00:00:00+00:00</updated><id>https://inside.java/2025/11/16/JVMLS-Vector-API</id><content type="html" xml:base="https://inside.java/2025/11/16/jvmls-vector-api/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/YZLVj4UVSj0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Throughout the project, the Vector API balanced providing a cross-platform API with staying close to the metal, performance-wise.</em></p>

<p><em>While the project succeeded in that goal, the Vector API had to give up some important functionality when it didn’t fit the design. As a result, the API became unsuitable for implementing an important class of vectorized algorithms that depend on access to particular hardware functionality. With recent progress in Project Panama (on the Foreign Function &amp; Memory API and <code class="language-plaintext highlighter-rouge">jextract</code>), new opportunities have emerged to bring Java even closer to hardware.</em></p>

<p><em>The talk covers how the Vector API evolved (from machine code snippets to JVM intrinsics), and then focus on a novel approach to providing access to individual machine code instructions from Java code in a performant manner. Such a “hardware intrinsics” API complements the Vector API by providing access to low-level platform-specific primitives. It opens up new opportunities for the Java Platform and enables simplifications in the Vector API, JDK, and JVM implementations.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;VladimirIvanov&quot;]</name></author><category term="Panama" /><summary type="html"><![CDATA[Throughout the project, the Vector API balanced providing a cross-platform API with staying close to the metal, performance-wise. While the project succeeded in that goal, the Vector API had to give up some important functionality when it didn't fit the design. As a result, the API became unsuitable for implementing an important class of vectorized algorithms that depend on access to particular hardware functionality. With recent progress in Project Panama (on the Foreign Function & Memory API and jextract), new opportunities have emerged to bring Java even closer to hardware. The talk covers how the Vector API evolved (from machine code snippets to JVM intrinsics), and then focus on a novel approach to providing access to individual machine code instructions from Java code in a performant manner. Such a "hardware intrinsics" API complements the Vector API by providing access to low-level platform-specific primitives. It opens up new opportunities for the Java Platform and enables simplifications in the Vector API, JDK, and JVM implementations.]]></summary></entry><entry><title type="html">Deep Dive into Gatherers - JEP Cafe #24</title><link href="https://inside.java/2025/11/14/jepcafe24/" rel="alternate" type="text/html" title="Deep Dive into Gatherers - JEP Cafe #24" /><published>2025-11-14T00:00:00+00:00</published><updated>2025-11-14T00:00:00+00:00</updated><id>https://inside.java/2025/11/14/JEPCafe24</id><content type="html" xml:base="https://inside.java/2025/11/14/jepcafe24/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/fgQQIV3B-uo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This JEP Café takes you through everything you can do with Gatherers, added to JDK 24 and available in JDK 25, the version you are going to use for your business applications.</em> 
<em>Along with many examples, it shows you the basics of mapping and filtering, how you can create and manage an internal mutable state to limit your stream, and sort them.</em> 
<em>It shows you how you can properly interrupt a stream when you need, and how you can avoid resource leaking and race conditions in the use of the API. It also shows you how you can leverage some available optimizations by declaring your integrators greedy when you can.</em> 
<em>One of the greatest features of the Stream API is that you can decide to go parallel. So parallel Gatherers are covered, along with the use of non-parallel Gatherers in parallel streams. At the end of this video you will know eveything you need to write efficient and correct Gatherers, but also when you should use them, and when you should stay away from them.</em></p>

<p>Make sure to check the <a href="https://www.youtube.com/watch?v=fgQQIV3B-uo">show-notes</a>!</p>]]></content><author><name>[&quot;JosePaumard&quot;]</name></author><category term="JDK 25" /><category term="Core Libraries" /><summary type="html"><![CDATA[This JEP Café takes you through everything you can do with Gatherers, added to JDK 24 and available in JDK 25, the version you are going to use for your business applications. Along with many examples, it shows you the basics of mapping and filtering, how you can create and manage an internal mutable state to limit your stream, and sort them. It shows you how you can properly interrupt a stream when you need, and how you can avoid resource leaking and race conditions in the use of the API. It also shows you how you can leverage some available optimizations by declaring your integrators greedy when you can. One of the greatest features of the Stream API is that you can decide to go parallel. So parallel Gatherers are covered, along with the use of non-parallel Gatherers in parallel streams. At the end of this video you will know eveything you need to write efficient and correct Gatherers, but also when you should use them, and when you should stay away from them.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC</title><link href="https://inside.java/2025/11/13/jep516-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC" /><published>2025-11-13T00:00:00+00:00</published><updated>2025-11-13T00:00:00+00:00</updated><id>https://inside.java/2025/11/13/JEP516-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/13/jep516-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?111431730" /></p>]]></content><author><name>[&quot;ErikOsterlund&quot;]</name></author><category term="JDK 26" /><category term="Leyden" /><category term="GC" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 516: Ahead-of-Time Object Caching with Any GC]]></summary></entry></feed>