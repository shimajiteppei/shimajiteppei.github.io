<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	 xmlns:media="http://search.yahoo.com/mrss/" >

<channel>
	<title>Kotlin : A concise multiplatform language developed by JetBrains | The JetBrains Blog</title>
	<atom:link href="https://blog.jetbrains.com/kotlin/feed/" rel="self" type="application/rss+xml" />
	<link>https://blog.jetbrains.com</link>
	<description>Developer Tools for Professionals and Teams</description>
	<lastBuildDate>Tue, 27 Jan 2026 12:33:14 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-32x32.png</url>
	<title>Kotlin : A concise multiplatform language developed by JetBrains | The JetBrains Blog</title>
	<link>https://blog.jetbrains.com</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Building AI Agents in Kotlin ‚Äì Part 5: Teaching Agents to Forget</title>
		<link>https://blog.jetbrains.com/ai/2026/01/building-ai-agents-in-kotlin-part-5-teaching-agents-to-forget/</link>
		
		<dc:creator><![CDATA[Fatimazahra El Akkary]]></dc:creator>
		<pubDate>Mon, 26 Jan 2026 16:09:12 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/KG-social-BlogFeatured-1280x720-1-1.png</featuredImage>		<product ><![CDATA[kotlin]]></product>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[tutorials]]></category>
		<category><![CDATA[ai]]></category>
		<category><![CDATA[ai-agents]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=ai&#038;p=676707</guid>

					<description><![CDATA[Previously in this series: Agents eventually run out of context. When they do, they crash, and you lose everything mid-task. We&#8217;ve been running GPT-5 Codex since Part 1. It scores 0.58 on SWE-bench Verified. We tried Claude Sonnet 4.5 next, which scored 0.6 and ran faster on most tasks. But complex problems hit Claude&#8217;s 200K [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p> Previously in this series:</p>



<ul>
<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/" target="_blank" rel="noreferrer noopener">Building AI Agents in Kotlin ‚Äì Part 1: A Minimal Coding Agent</a></li>



<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-2-a-deeper-dive-into-tools/" target="_blank" rel="noreferrer noopener">Building AI Agents in Kotlin ‚Äì Part 2: A Deeper Dive Into Tools</a></li>



<li><a href="https://blog.jetbrains.com/ai/2025/12/building-ai-agents-in-kotlin-part-3-under-observation/" target="_blank" rel="noreferrer noopener">Building AI Agents in Kotlin ‚Äì Part 3: Under Observation</a></li>



<li><a href="https://blog.jetbrains.com/ai/2026/01/building-ai-agents-in-kotlin-part-4-delegation-and-sub-agents/" target="_blank" rel="noreferrer noopener">Building AI Agents in Kotlin ‚Äì Part 4: Delegation and Sub-Agent</a></li>
</ul>



<p><strong>Agents eventually run out of context. When they do, they crash, and you lose everything mid-task.</strong></p>



<p>We&#8217;ve been running GPT-5 Codex since <a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Part 1</a>. It scores 0.58 on SWE-bench Verified. We tried Claude Sonnet 4.5 next, which scored 0.6 and ran faster on most tasks. But complex problems hit Claude&#8217;s 200K context window faster.&nbsp;</p>



<p>You&#8217;ll probably find yourself switching models too, for better performance, lower cost, or to run locally. Sometimes that means smaller context windows, especially for local models limited by expensive memory. But even the biggest context windows fail on complex and long tasks. You can&#8217;t just keep buying more context.<br><br>The problem is that agents hold onto everything: every file, every command output, every search result, every user message. Eventually, there&#8217;s no room left.</p>



<p>That&#8217;s where compression comes in. But not the lazy kind that just drops old messages when you run out of space. Think about handing off a task to another developer. You don&#8217;t give them a transcript of everything you did. You tell them the goal, what files you changed, what worked, and what didn&#8217;t. That&#8217;s smart compression: Keep the context needed to continue; drop the verbose history.</p>



<p>Let&#8217;s figure out how to implement this in <a href="https://github.com/JetBrains/koog" target="_blank" rel="noopener">Koog</a>. First, we need to understand what <code>strategy = singleRunStrategy()</code> has been doing since <a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Part 1</a>. This is where you see how strategies control your agent&#8217;s loop and how you can modify them to create your own flow. We&#8217;ll examine <code>singleRunStrategy()</code>, and then build a version that compresses automatically.&nbsp;</p>



<h2 class="wp-block-heading">What that strategy line does</h2>



<p>In the previous parts, you built a coding agent. You gave it tools, along with this line:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">strategy = singleRunStrategy()</pre>



<p>Here, a strategy is the code that runs your agent loop. All strategies share the same core elements: call the LLM, execute tools, send results back, repeat. But they differ in <strong>when they stop</strong> and <strong>what they do between iterations</strong>.</p>



<p><code>singleRunStrategy()</code> is the simplest possible version. It keeps iterating as long as the LLM returns tool calls. In other words: call the LLM ‚Üí return tool call? ‚Üí execute ‚Üí call again ‚Üí return text? ‚Üí done.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" fetchpriority="high" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-63.png" alt="" class="wp-image-676937" style="aspect-ratio:0.9209809264305178;width:338px;height:auto; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>It works fine for simple tasks. But on complex problems, the history keeps growing. Every command output, every file read, every search result stays in context. Eventually you hit the limit and crash mid-task.</p>



<p>What we need instead is a strategy that runs the same loop but <strong>also checks the history size and compresses it when it grows too large</strong>.</p>



<h2 class="wp-block-heading"><strong>Adding compression</strong></h2>



<p>We&#8217;re swapping this:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">strategy = singleRunStrategy()</pre>



<p>For this:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">strategy = singleRunStrategyWithHistoryCompression()</pre>



<p>The loop is the same, but there‚Äôs now a checkpoint between <code>Execute Tool</code> and <code>Send Tool</code> Result. After each tool execution, the strategy asks:</p>



<ul>
<li>Check: Is the history greater than the threshold?</li>



<li>If yes? Compress it: Extract the important facts. Drop the rest.</li>



<li>If no? Continue as usual.</li>
</ul>



<figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-64.png" alt="" class="wp-image-676948" style="aspect-ratio:0.5842696629213483;width:351px;height:auto; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>That checkpoint is what lets your agent complete long-running tasks within tighter token budgets to avoid the error &#8220;context window exceeded‚Äù.</p>



<p>But you have to configure it. The strategy can&#8217;t guess when the history is too big or what facts matter for your task. You have to tell it two things: <strong>when</strong> to compress, and <strong>what</strong> to keep.</p>



<h2 class="wp-block-heading"><strong>When to compress&nbsp;</strong></h2>



<p>First, you set thresholds ‚Äì how many messages or characters you allow before compression kicks in:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val CODE_AGENT_HISTORY_TOO_BIG = { prompt ->
   prompt.messages.size > 200 || prompt.messages.sumOf { it.content.length } > 200_000}</pre>



<p>Why these numbers? We experimented with different thresholds after seeing where errors appeared.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-65.png" alt="" class="wp-image-676959"/></figure>



<p>This agent hit 220K tokens and crashed. Claude&#8217;s limit is 200K tokens. We needed to compress before reaching that point.</p>



<p>We set compression at 200 messages or 200,000 characters, whichever comes first. Note that the code measures characters, not tokens. They‚Äôre different, but this threshold keeps us under the token limit ‚Äì high enough to avoid over-compression, low enough to prevent hitting the limit.</p>



<p>These numbers aren&#8217;t fixed. If your agent hits the limit earlier, lower the threshold. Still completing tasks past these thresholds? Raise them. The choice depends on your use case: file sizes, message length, how verbose your tool outputs are, task complexity. Experiment and find what works.</p>



<h2 class="wp-block-heading">What to keep</h2>



<p>You&#8217;ve set when compression triggers. Now choose what to keep.</p>



<p>There are two options: Either <strong>trust the LLM to decide what&#8217;s important</strong>, or <strong>tell it exactly what to extract.</strong></p>



<h3 class="wp-block-heading"><strong>Option 1: Trust the LLM to summarize</strong></h3>



<p>The LLM decides what&#8217;s important using <a href="https://api.koog.ai/agents/agents-core/ai.koog.agents.core.dsl.extension/-history-compression-strategy/-whole-history/index.html" target="_blank" rel="noopener">WholeHistory</a>:</p>



<p>compressionStrategy = WholeHistory</p>



<p>When compression triggers, Koog asks the LLM to create a TL;DR summary of the entire conversation history.</p>



<p><strong>Before compression:</strong></p>



<ul>
<li>All messages up to the threshold: system prompt, user messages, assistant responses, tool calls, tool results.</li>
</ul>



<p><strong>After compression:</strong></p>



<ul>
<li>System prompt (preserved).</li>



<li>First user message (preserved, so the agent remembers the original goal).&nbsp;</li>



<li>One TL;DR summary message (written by the LLM).</li>
</ul>



<p><strong>The tradeoff:</strong> This approach is simple and fast, but you‚Äôre trusting the LLM to decide what matters. Sometimes it keeps exactly the right details. Sometimes it drops something critical.</p>



<h3 class="wp-block-heading"><strong>Option 2: Tell the LLM exactly what to extract</strong></h3>



<p>Instead of telling the model to summarize everything, you specify exactly what facts to extract using<a href="https://api.koog.ai/agents/agents-features/agents-features-memory/ai.koog.agents.memory.feature.history/-retrieve-facts-from-history/index.html" target="_blank" rel="noopener"> <code>RetrieveFactsFromHistory</code></a>:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">compressionStrategy = RetrieveFactsFromHistory(
   Concept(...),
   Concept(...),
   ...
)</pre>



<p><strong>How it works:</strong></p>



<p>You define <code>Concept</code> objects: specific questions about your task that the agent must remember. When compression triggers, Koog makes one LLM call per concept, sending the full conversation history each time and asking just that single question.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-66.png" alt="" class="wp-image-676970" style="aspect-ratio:1.7713498622589532;width:579px;height:auto; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>Why separate calls? LLMs get worse at answering when you ask multiple questions at once. We saw this in testing: Bundle eight concepts into one prompt, and some answers come back vague or incomplete. Ask them one at a time, and each response is more reliable.</p>



<p><strong>D</strong><strong>efining a concept</strong></p>



<p>Each <code>Concept</code> instance has three parts:</p>



<ul>
<li><code>keyword</code>: a label for logs&nbsp;</li>



<li><code>description</code>: the actual question or instruction the LLM should answer&nbsp;</li>



<li><code>factType</code>: the expected format of the answer
<ul>
<li><code>MULTIPLE</code> for lists</li>



<li><code>SINGLE</code> for single value</li>
</ul>
</li>
</ul>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Concept(
    keyword = "project-structure",
    description = "What is the project structure?",
    factType = FactType.MULTIPLE
)</pre>



<h4 class="wp-block-heading"><strong>Choosing the right concepts</strong></h4>



<p>For our coding agent, the key question is: What information, if lost, would force the agent to start over?&nbsp;</p>



<p>Here&#8217;s what happens when compression drops critical information:</p>



<ul>
<li>The agent opens the same file twice as though it&#8217;s never seen it before.</li>



<li>It rewrites tests that already exist.</li>



<li>It drifts away from the task you originally gave it.</li>
</ul>



<p>Each failure shows what must survive compression:</p>



<ul>
<li>Re-exploring files ‚Üí You need a <code>project-structure</code> concept.</li>



<li>Redoing finished work ‚Üí You need an <code>important-achievements</code> concept.</li>



<li>Losing direction ‚Üí You need an <code>agent-goal</code> concept.</li>
</ul>



<h4 class="wp-block-heading"><strong>Our coding agent concepts</strong></h4>



<p>When we tested on SWE-bench-Verified, we ended up with eight concepts. Here are three of them:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val CODE_AGENT_COMPRESSION_STRATEGY = RetrieveFactsFromHistory(
    Concept(
        "project-structure",
        "What is the structure of this project?",
        FactType.MULTIPLE
    ),
    Concept(
        "important-achievements",
        "What has been achieved during the execution of this current agent?",
        FactType.MULTIPLE
    ),
    Concept(
        "agent-goal",
        "What is the primary goal or task the agent is trying to accomplish in this session?",
        FactType.SINGLE
    ),
    ...</pre>



<p>Your agent may need different concepts. The goal isn&#8217;t to copy the list; it&#8217;s to identify what state your agent needs to continue working and define concepts that preserve that information.</p>



<p>You can check out the<a href="https://github.com/JetBrains/koog/blob/ea6cc04a8d989ae3d4656dfea0cbc2a1b89c9bdc/examples/code-agent/step-05-history/src/main/kotlin/CodeAgentHistoryCompressionConfig.kt#L19" target="_blank" rel="noopener"> full implementation of the eight concepts on GitHub</a>.&nbsp;</p>



<h2 class="wp-block-heading">Which model to use&nbsp;</h2>



<p>Just like with sub-agents (<a href="https://blog.jetbrains.com/ai/2026/01/building-ai-agents-in-kotlin-part-4-delegation-and-sub-agents/">Part 4</a>), you can use different models for different parts of the process. The <code>retrievalModel</code> parameters lets you specify which LLM handles the history compression. This parameter is optional ‚Äì if not specified, compression uses your agent&#8217;s main model.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">retrievalModel = OpenAIModels.Chat.GPT4_1Mini</pre>



<p>Here&#8217;s the complete configuration for the coding-agent strategy:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">strategy = singleRunStrategyWithHistoryCompression(
   config = HistoryCompressionConfig(
       isHistoryTooBig = CODE_AGENT_HISTORY_TOO_BIG,
       compressionStrategy = CODE_AGENT_COMPRESSION_STRATEGY,
       retrievalModel = OpenAIModels.Chat.GPT4_1Mini
   )
)</pre>



<p>Three parameters: when to compress (<code>isHistoryTooBig</code>), what to keep (<code>compressionStrategy</code>), and which model does the work (<code>retrievalModel</code>).</p>



<h2 class="wp-block-heading">Conclusion</h2>



<p>At this point, your agent can run longer tasks without hitting context limits. The compression problem is solved. Instead of crashing when it runs out of space, the agent compresses its history, keeping decisions and outcomes while dropping verbose outputs, and continues working within whatever token budget you have.</p>



<p>In this series, we started with a basic coding agent in <a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Part 1</a>. Since then, we&#8217;ve added tools, observability, sub-agents, and history compression. These five pieces give you what you need to build working AI agents in Kotlin that can operate within the constraints of real models.</p>



<p>If you want to keep building and practicing these patterns, planning and reasoning are interesting areas to explore: how agents decide what to do across multiple turns and how they break down complex problems. We didn&#8217;t cover those here, but they&#8217;re good practice once you&#8217;ve got these pieces working.&nbsp;</p>



<p><a href="https://github.com/JetBrains/koog/blob/ea6cc04a8d989ae3d4656dfea0cbc2a1b89c9bdc/examples/code-agent/step-05-history/src/main/kotlin/Main.kt" target="_blank" rel="noopener">The full code&#8217;s on GitHub</a>. If you run into any issues, leave a comment. We&#8217;re happy to help üòä</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Meet the First Speakers Heading to KotlinConf 2026</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/meet-the-first-speakers-heading-to-kotlinconf-2026/</link>
		
		<dc:creator><![CDATA[Daria Voronina]]></dc:creator>
		<pubDate>Mon, 26 Jan 2026 09:58:20 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/JB-social-BlogFeatured-1280x720-1-5.png</featuredImage>		<category><![CDATA[news]]></category>
		<category><![CDATA[kotlinconf]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=676361</guid>

					<description><![CDATA[With each KotlinConf, developers from around the world come together to learn from leading experts, explore the latest industry insights, and engage with the Kotlin community. KotlinConf‚Äô25 alone welcomed attendees from over 50 countries. KotlinConf‚Äô26 is just a few months away, and we‚Äôre excited to introduce the first round of speakers who will be joining [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><strong>With each KotlinConf, developers from around the world come together to learn from leading experts, explore the latest industry insights, and engage with the Kotlin community. KotlinConf‚Äô25 alone welcomed attendees from over 50 countries.</strong></p>



<p>KotlinConf‚Äô26 is just a few months away, and we‚Äôre excited to introduce the <a href="https://kotlinconf.com/?utm_source=blogpost&amp;utm_medium=referral&amp;utm_campaign=firstspeakers" target="_blank" rel="noreferrer noopener">first round of speakers</a> who will be joining us on stage.</p>



<p>They‚Äôre the brilliant minds shaping the future of the language and the wider ecosystem ‚Äì and this is just the beginning. KotlinConf‚Äô26 will be packed with inspiring talks, <a href="https://kotlinconf.com/workshops/?utm_source=blogpost&amp;utm_medium=referral&amp;utm_campaign=firstspeakers" target="_blank" data-type="link" data-id="https://kotlinconf.com/workshops/?utm_source=blogpost&amp;utm_medium=referral&amp;utm_campaign=firstspeakers" rel="noreferrer noopener">in-depth workshops</a>, and plenty of opportunities to learn, share ideas, and connect with fellow Kotlin enthusiasts.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/Blog.png" alt="Meet the first speakers heading to KotlinConf'26" class="wp-image-676408"/></figure>



<p>Want to meet the people defining what‚Äôs next for Kotlin and the industry around it? Secure your ticket and get ready for an unforgettable conference experience.</p>



<div class="buttons">
        <div class="buttons__row">
            <a class="ek-link jb-download-button" title="Save your spot at KotlinConf‚Äô26" href="https://kotlinconf.com/?utm_source=blogpost&#038;utm_medium=button&#038;utm_campaign=firstspeakers" target="_blank" rel="noopener" data-test="blog-article-cta" data-cl="true">Save your spot at KotlinConf‚Äô26</a>
         </div>
</div>



<p>More speakers and the full schedule are coming soon ‚Äì stay tuned!</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Ktor 3.4.0 Is Now Available!</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/ktor-3-4-0-is-now-available/</link>
		
		<dc:creator><![CDATA[Simon Vergauwen]]></dc:creator>
		<pubDate>Fri, 23 Jan 2026 14:05:30 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/Ktor-Release-Blog-Featured-Blog-1280x720-1.png</featuredImage>		<product ><![CDATA[ktor]]></product>
		<category><![CDATA[ktor]]></category>
		<category><![CDATA[news]]></category>
		<category><![CDATA[releases]]></category>
		<category><![CDATA[backend]]></category>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[release]]></category>
		<category><![CDATA[server-side]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=676081</guid>

					<description><![CDATA[Ktor 3.4.0 improves stability and addresses outstanding issues. Highlights include OpenAPI generation, Ztsd support for the compression plugin, duplex streaming for OkHttp, Structured concurrency integrations for the HTTP request lifecycle, and much more. For a detailed list of all the changes, check out the What‚Äôs new page. Stability and performance With its focus on stability [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Ktor 3.4.0 improves stability and addresses outstanding issues. Highlights include OpenAPI generation, <a href="https://github.com/facebook/zstd" target="_blank" rel="noopener">Ztsd</a> support for the compression plugin, duplex streaming for OkHttp, Structured concurrency integrations for the HTTP request lifecycle, and much more. For a detailed list of all the changes, check out the <a href="https://ktor.io/docs/whats-new-340.html" target="_blank" rel="noopener"><em>What‚Äôs new</em></a> page.</p>



<h2 class="wp-block-heading">Stability and performance</h2>



<p>With its focus on stability and fixes for some long-standing issues, this release ensures Ktor is ready for another year of amazing development!&nbsp;</p>



<p>Because stability and performance remain among our top priorities heading into the new year, we want to invite all of you again to join the<a href="https://ktor.io/eap/" target="_blank" rel="noopener"> Ktor Early Access Program</a> and help us test new versions and features. Start building your next project at<a href="https://kotl.in/3l8e5x" target="_blank" rel="noreferrer noopener"> start.ktor.io</a>. Your suggestions and contributions are always welcome!</p>



<div class="buttons">
        <div class="buttons__row">
            <a class="ek-link jb-download-button" title="Get Started With Ktor 3.4.0" href="https://kotl.in/ktor-3-4-blog" target="_blank" rel="noopener" data-test="blog-article-cta" data-cl="true">Get Started With Ktor 3.4.0</a>
         </div>
</div>



<h2 class="wp-block-heading">OpenAPI generation from code</h2>



<p>In 3.4.0, we completed the story for OpenAPI document generation by introducing a new API for dynamically documenting endpoints that works in tandem with a new compiler plugin. Now, instead of building your Swagger frontend from a static file, the model is built at runtime from details embedded in the routing tree.</p>



<p>To generate your documentation, you can enable it through the Ktor Gradle plugin, then it will automatically provide details in your code via the new <code>describe</code> API:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">/**
 * Our existing plugins work with the information found in the routes.
 */
swaggerUI("/docs") {
    // Customize the result with general details
    info = OpenApiInfo("KChat API", "1.0.0")
}

/**
 * Get a list of messages.
 * 
 * Query parameters: 
 *  - search [String] a search query
 */
get("/messages") {
    val query = call.parameters["search"]?.parseQueryOrNull()
    call.respond(messageTable.listMessages(query))
}.describe {
    // This code is generated from the code above
    summary = "Get a list of messages"
    parameters {
        query("q") {
            description = "a search query"
        }
    }
    responses {
        HttpStatusCode.OK {
            schema = jsonSchema&lt;Message>()
        }
    }
}</pre>



<h2 class="wp-block-heading">Duplex streaming for OkHttp</h2>



<p>The OkHttp client engine now supports duplex streaming, enabling clients to send request body data and receive response data simultaneously, in contrast to regular HTTP calls, where the request body must be fully sent before the response begins.</p>



<p>Duplex streaming is available for HTTP/2 connections and can be enabled using the new <code>duplexStreamingEnabled</code> property in <code>OkHttpConfig</code>:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val client = HttpClient(OkHttp) {
    engine {
        duplexStreamingEnabled = true
        config {
            protocols(listOf(Protocol.H2_PRIOR_KNOWLEDGE))
        }
    }
}</pre>



<h2 class="wp-block-heading">Zstd compression support</h2>



<p>The <a href="https://ktor.io/docs/server-compression.html" target="_blank" rel="noopener">Compression</a> plugin now supports Ztsd via the new <code>ktor-server-compression-zstd</code> module. Zstd is a fast compression algorithm that offers high compression ratios, low compression times, and a configurable compression level.&nbsp; To set this level, call the <code>zstd</code> function from inside the <code>compression</code> block:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">install(Compression) {
   zstd {
       compressionLevel = 3
       ...
   }
}</pre>



<h2 class="wp-block-heading">HttpRequestLifecycle</h2>



<p>The <em>new</em> <code>HttpRequestLifecycle</code> plugin allows you to cancel in-flight HTTP requests when the client disconnects, which is useful when you need to cancel a long-running or resource-intensive in-flight request. Simply install the <code>HttpRequestLifecycle</code> plugin and set <code>cancelCallOnClose = true</code>:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">install(HttpRequestLifecycle) {
    cancelCallOnClose = true
}

routing {
    get("/long-process") {
        try {
            while (isActive) {
                delay(10_000)
                logger.info("Very important work.")
            }
            call.respond("Completed")
        } catch (e: CancellationException) {
            logger.info("Cleaning up resources.")
        }
    }
}</pre>



<p>When the client disconnects, the coroutine handling the request is canceled, along with any <code>launch</code> or <code>async</code> coroutines started by it, and structured concurrency cleans all resources. This is currently only supported for the <code>Netty</code> and <code>CIO</code> engines.</p>



<h1 class="wp-block-heading"><strong>üöÄ</strong><strong> </strong>Thank you!</h1>



<p>We want to thank<a href="https://github.com/MarcusDunn" target="_blank" rel="noopener"> </a>everyone in the community for your support and feedback, as well as for reporting issues.</p>



<p>Start building your next project at<a href="https://kotl.in/3l8e5x" target="_blank" rel="noreferrer noopener"> start.ktor.io</a>. Your suggestions and contributions are always welcome! üîó<a href="https://ktor.io/docs/welcome.html" target="_blank" rel="noopener"> Get Started With Ktor</a> | üì¢ Join the Community on<a href="https://www.reddit.com/r/ktor/" target="_blank" rel="noopener"> Reddit</a> and<a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up?_gl=1*1wxglsg*_gcl_au*MTE4MjgxMTg3Mi4xNzM2MjY0ODgy*_ga*MTYyODczMDg5NS4xNzAyMDQyMTMx*_ga_9J976DJZ68*MTczODY3Mjg3Ny4xOTguMS4xNzM4NjczNDI2LjM2LjAuMA.." target="_blank" rel="noopener"> Slack</a></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Exposed 1.0 Is Now Available</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/exposed-1-0-is-now-available/</link>
		
		<dc:creator><![CDATA[Simon Vergauwen]]></dc:creator>
		<pubDate>Fri, 23 Jan 2026 13:07:20 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/Exposed-Release-Blog-Featured-Blog-1280x720-1.png</featuredImage>		<category><![CDATA[exposed]]></category>
		<category><![CDATA[news]]></category>
		<category><![CDATA[releases]]></category>
		<category><![CDATA[backend]]></category>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[release]]></category>
		<category><![CDATA[server-side]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=676201</guid>

					<description><![CDATA[This is the first major release of Exposed ‚Äì a huge milestone for both the project and the Exposed team! This release brings many new exciting features, the most requested being R2DBC support, as well as performance enhancements and bug fixes. Exposed 1.0 also introduces a stable API that guarantees no breaking changes until the [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>This is the first major release of <a href="https://www.jetbrains.com/exposed/" target="_blank" rel="noopener">Exposed</a> ‚Äì a huge milestone for both the project and the Exposed team! This release brings many new exciting features, the most requested being R2DBC support, as well as performance enhancements and bug fixes. Exposed 1.0 also introduces a stable API that guarantees no breaking changes until the next major release.</p>



<h2 class="wp-block-heading">Get started</h2>



<p>Can‚Äôt wait to start building your next project with Exposed 1.0? Check out the examples with <a href="https://github.com/JetBrains/Exposed/tree/main/samples/exposed-ktor" target="_blank" rel="noopener">Ktor</a> or <a href="https://github.com/JetBrains/Exposed/tree/main/samples/exposed-spring" target="_blank" rel="noopener">Spring</a> and join the <a href="https://slack-chats.kotlinlang.org/c/exposed" target="_blank" rel="noreferrer noopener">#exposed</a> channel on Kotlin Slack if you have any questions or feedback.</p>



<div class="buttons">
        <div class="buttons__row">
            <a class="ek-link jb-download-button" title="Get Started With Exposed" href="https://kotl.in/vpbuvk" target="_blank" rel="noopener" data-test="blog-article-cta" data-cl="true">Get Started With Exposed</a>
         </div>
</div>



<p>If you are already using Exposed, check out the <a href="https://www.jetbrains.com/help/exposed/migration-guide-1-0-0.html" target="_blank" rel="noopener">Migration Guide</a> on how to migrate from version 0.61.0 to 1.0.</p>



<h2 class="wp-block-heading">What‚Äôs new</h2>



<h3 class="wp-block-heading">R2DBC</h3>



<p>Highly requested by the community, <a href="https://r2dbc.io" target="_blank" rel="noopener">R2DBC</a> support has made it into Exposed. This brings <a href="https://www.jetbrains.com/help/exposed/working-with-connectionfactory.html" target="_blank" rel="noopener">support</a> for reactive drivers to the Exposed SQL DSL approach.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val database = R2dbcDatabase.connect(
    url = "r2dbc:postgresql://db:5432/mydatabase",
        databaseConfig = R2dbcDatabaseConfig {
        defaultMaxAttempts = 1
        defaultR2dbcIsolationLevel = IsolationLevel.READ_COMMITTED

        connectionFactoryOptions {
            option(ConnectionFactoryOptions.USER, dbUser)
        }
    }
)</pre>



<h2 class="wp-block-heading">Spring Support</h2>



<p>Spring is heavily used in Kotlin and with Exposed. For 1.0, we will continue to support Spring Boot 3 alongside Spring Boot 4. Exposed brings many quality of life improvements when using Spring with Exposed, such as GraalVM native image support and better transaction management.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Component
@Transactional
class UserService {
    // Use Exposed dsl without `transaction { }`
    fun findUserById(id: UserId): User? =
        UserTable.selectAll().where { UserTable.id eq id.value }
            .firstOrNull()?.let { row ->
                User(
                    id = UserId(row[UserTable.id].value),
                    name = row[UserTable.name],
                    age = row[UserTable.age],
                )
            }
}</pre>



<h2 class="wp-block-heading">Exposed 1.0: Stable, scalable, and looking forward | Chantal Loncle</h2>



<p>Chantal Loncle gave an overview of Exposed 1.0, how we got here, and what the future might bring at KotlinConf 2025.</p>



<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<iframe loading="lazy" title="Exposed 1.0: Stable, Scalable, and Looking Forward | Chantal Loncle" src="https://www.youtube.com/embed/xgfeqj8UyVA?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div></figure>



<h2 class="wp-block-heading">Thank you!</h2>



<p>We want to thank everyone for their support, contributions, and feedback as we prepared for this release!<br><br>We‚Äôd especially like to thank all of our contributors whose pull requests were included in this release:</p>



<p><a href="https://github.com/Avi18971911" target="_blank" rel="noopener">Avi18971911</a>, <a href="https://github.com/Attacktive" target="_blank" rel="noopener">Attacktive</a>, <a href="https://github.com/marceligrabowski" target="_blank" rel="noopener">Marceli Grabowski</a>, <a href="https://github.com/med01-flutter-uki" target="_blank" rel="noopener">Michael Edwards</a>, <a href="https://github.com/ntkoopman" target="_blank" rel="noopener">Tim Koopman</a>, <a href="https://github.com/sokomishalov" target="_blank" rel="noopener">Mikhael Sokolov</a>, <a href="https://github.com/Blad3Mak3r" target="_blank" rel="noopener">Juan Luis Caro</a>, <a href="https://github.com/nicktelford" target="_blank" rel="noopener">Nick Telford</a>, <a href="https://github.com/IlyaPechuro" target="_blank" rel="noopener">Ilya</a>, <a href="https://github.com/kchung1995" target="_blank" rel="noopener">Kuyho Chung</a>, <a href="https://github.com/tronto20" target="_blank" rel="noopener">tronto20</a>, <a href="https://github.com/mole828" target="_blank" rel="noopener">mole828</a>, <a href="https://github.com/zbqmgldjfh" target="_blank" rel="noopener">Jiwoo Kim</a>, <a href="https://github.com/sh-cho" target="_blank" rel="noopener">Seonghyeon, Cho</a>, <a href="https://github.com/zackman0010" target="_blank" rel="noopener">Zachary Sistrunk</a>, <a href="https://github.com/devch37" target="_blank" rel="noopener">devch37</a></p>



<p>Your suggestions and <a href="https://youtrack.jetbrains.com/issues/EXPOSED" target="_blank" rel="noopener">issue reports</a> are always welcome!</p>



<p><a href="https://www.jetbrains.com/help/exposed/home.html" target="_blank" rel="noopener">Get Started with Exposed</a> | Join the Community on <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up" target="_blank" rel="noopener">Slack</a></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How to Avoid Common Pitfalls With JPA and Kotlin</title>
		<link>https://blog.jetbrains.com/idea/2026/01/how-to-avoid-common-pitfalls-with-jpa-and-kotlin/</link>
		
		<dc:creator><![CDATA[Teodor Irkhin]]></dc:creator>
		<pubDate>Tue, 20 Jan 2026 17:25:41 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/IJ-social-BlogFeatured-1280x720-1-1.png</featuredImage>		<product ><![CDATA[kotlin]]></product>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[tutorials]]></category>
		<category><![CDATA[jpa]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=idea&#038;p=669971</guid>

					<description><![CDATA[This post was written together with Thorben Janssen, who has more than 20 years of experience with JPA and Hibernate and is the author of &#8220;Hibernate Tips: More than 70 Solutions to Common Hibernate Problems&#8221; and the JPA newsletter. Kotlin and Jakarta Persistence (also known as JPA) are a popular combination for server-side development. Kotlin [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><em>This post was written together with <a href="https://thorben-janssen.com/" data-type="link" data-id="https://thorben-janssen.com/" target="_blank" rel="noopener">Thorben Janssen</a>, who has more than 20 years of experience with JPA and Hibernate and is the author of &#8220;Hibernate Tips: More than 70 Solutions to Common Hibernate Problems&#8221; and the JPA newsletter.</em></p>



<p>Kotlin and Jakarta Persistence (also known as JPA) are a popular combination for server-side development. Kotlin offers concise syntax and modern language features, while Jakarta Persistence provides a proven persistence framework for enterprise applications.</p>



<p>However, Jakarta Persistence was originally designed for Java. Some of Kotlin‚Äôs popular features and concepts, like null safety and data classes, help you tremendously when implementing your business logic, but they don‚Äôt align well with the specification.</p>



<p>This article outlines a set of best practices to help you avoid problems and build reliable persistence layers with Kotlin and Jakarta Persistence. And to share some good news before diving in, IntelliJ IDEA 2026.1 will automatically detect many of these issues, highlight them with warnings, and provide support through various inspections.</p>



<h2 class="wp-block-heading" id="entity-class-design"><strong>Entity class design</strong></h2>



<p>Jakarta Persistence defines several <a href="https://jakarta.ee/specifications/persistence/3.2/jakarta-persistence-spec-3.2#a18" target="_blank" rel="noopener">requirements</a> for entity classes that form the foundation for how persistence providers manage entity objects.</p>



<p>An entity class must:</p>



<ul>
<li><strong>Provide a no-argument constructor</strong><strong><br></strong>The persistence provider uses reflection to call the no-argument constructor to create entity instances when loading data from the database.</li>



<li><strong>Have non-final attributes</strong><strong><br></strong>When fetching an entity object from the database, the persistence provider sets all attribute values after it calls the no-argument constructor to instantiate the entity object. This process is called hydration.<br>After that is done, the persistence provider keeps a reference to the entity object to perform automatic dirty checks, during which it detects changes and updates the corresponding database records automatically.</li>



<li><strong>Be non-final</strong><strong><br></strong>The persistence provider often creates proxy subclasses to implement features such as <a href="https://www.baeldung.com/hibernate-lazy-eager-loading" target="_blank" rel="noopener">lazy loading</a> for @ManyToOne and @OneToOne relationships. For this to work, the entity class can‚Äôt be final.<br></li>
</ul>



<p>In addition to these specification requirements, it is a widely accepted best practice to:</p>



<ul>
<li><strong>Implement <code>equals</code>, <code>hashCode</code>, and <code>toString</code> carefully<br></strong>These methods should rely only on the entity‚Äôs identifier and type to avoid unexpected behavior in persistence contexts. You can find approaches for better implementing those <a href="https://thorben-janssen.com/ultimate-guide-to-implementing-equals-and-hashcode-with-hibernate/" target="_blank" rel="noopener">here</a>.<br></li>
</ul>



<p>These rules are easy to follow in Java but conflict with some of Kotlin‚Äôs defaults, such as final classes, immutable properties, and constructor-based initialization.<br><br>The following sections show how to adapt your Kotlin classes to meet these requirements while still using Kotlin‚Äôs language features effectively.</p>



<h3 class="wp-block-heading">Data classes vs. entities</h3>



<p><a href="https://kotlinlang.org/docs/data-classes.html" target="_blank" rel="noopener">Kotlin‚Äôs data classes</a> are designed to hold data. They are final and provide several utility methods, including getters and setters for all fields, as well as <code>equals</code>, <code>hashCode</code>, and <code>toString</code>.</p>



<p>This makes data classes a great fit for DTOs, which represent query results and are not managed by your persistence provider.</p>



<p>Below is a typical usage of a data class to fetch data:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">data class EmployeeWithCompany(val employeeName: String, val companyName: String)

val query = entityManager.createQuery("""
¬†¬†¬†SELECT new com.company.kotlin.model.EmployeeWithCompany(p.name, c.name)
¬†¬†¬†¬†FROM Employee e
¬†¬†¬†¬†¬†¬†¬†JOIN e.company c
¬†¬†¬†¬†WHERE p.id = :id""")

val employeeWithCompany = query.setParameter("id", 1L).singleResult;</pre>



<p>However, entities differ because they are managed objects. And that causes problems when you model them as a data class.</p>



<p>For entities, the persistence provider automatically detects changes and uses lazy loading for relationships. To support this, it expects entity classes to follow the requirements defined in the Jakarta Persistence specification, which we discussed at the beginning of this chapter.&nbsp;</p>



<p>As you can see in the following table, that makes Kotlin‚Äôs data classes a bad fit for entity classes.</p>



<figure class="wp-block-table"><table><tbody><tr><td></td><td><strong>Kotlin Data Class</strong></td><td><strong>Jakarta Persistence Entity</strong></td></tr><tr><td><strong>Class Type</strong></td><td>Final</td><td>Must be open (non-final) so the provider can create proxy subclasses</td></tr><tr><td><strong>Constructors</strong></td><td>Primary constructor with required parameters</td><td>Must provide a no-argument constructor, used by the persistence provider</td></tr><tr><td><strong>Mutability</strong></td><td>Immutable by default (val properties)</td><td>Must have mutable, non-final attributes so the provider can perform lazy loading as well as detect and persist changes</td></tr><tr><td><strong>equals</strong><strong> and </strong><strong>hashCode</strong></td><td>Use all properties</td><td>Should rely only on type and primary key</td></tr><tr><td><strong>toString</strong></td><td>Includes all properties</td><td>Should only reference eagerly loaded attributes to avoid additional queries</td></tr></tbody></table></figure>



<p>The recommended approach is to use regular open classes to model your entities. They are mutable and proxy-friendly, and they don‚Äôt cause any issues with Jakarta Persistence.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
open class Person {
¬†¬†¬†@Id
¬†¬†¬†@GeneratedValue
¬†¬†¬†var id: Long? = null

¬†¬†¬†var name: String? = null
}</pre>



<h3 class="wp-block-heading">Non-final classes and no-argument constructors</h3>



<p><a href="#entity-class-design">As discussed earlier</a>, Jakarta Persistence requires entity classes to be non-final and provide a no-argument constructor.&nbsp;</p>



<p>Kotlin‚Äôs classes are final by default and don‚Äôt have to offer a no-argument constructor.</p>



<p>But don‚Äôt worry, it‚Äôs easy to fulfill the requirements without changing your code or implementing your entity classes in a specific way. Just add the no-arg and all-open plugins and add <a href="https://kotlinlang.org/docs/reflection.html" target="_blank" rel="noopener">kotlin-reflect</a> to your dependencies. This adds the required constructor and marks annotated classes as open at build time.</p>



<p>Currently, you need the compiler plugins <code>plugin.spring</code> and <code>plugin.jpa</code>, which will automatically add the no-arg and all-open plugins. When creating a new Spring project using the <em>New Project</em> wizard in IntelliJ IDEA or via <a href="http://start.spring.io" target="_blank" rel="noopener">start.spring.io</a>, both plugins are automatically configured for you. And starting with IntelliJ IDEA 2026.1, this will also be the case when you add a Kotlin file to an existing Java project.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">plugins {
¬†¬†¬†kotlin("plugin.spring") version "2.2.20"
¬†¬†¬†kotlin("plugin.jpa") version "2.2.20"
}

allOpen {
¬†¬†¬†annotation("jakarta.persistence.Entity")
¬†¬†¬†annotation("jakarta.persistence.MappedSuperclass")
¬†¬†¬†annotation("jakarta.persistence.Embeddable")
}</pre>



<p>When configuring this manually, pay close attention to both parts of this setup. <code>plugin.jpa</code> appears to provide the required configuration, but it only configures the no-arg plugin, not the all-open one. This will be improved with the upcoming JPA plugin update. You will then no longer have to add the allOpen section. See: <a href="https://youtrack.jetbrains.com/issue/KT-79389/Add-allopen-plugin-JPA-preset-to-kotlin.plugin.jpa" target="_blank" rel="noopener">KT-79389</a></p>



<h2 class="wp-block-heading">Mutability</h2>



<p>As a Kotlin developer, you‚Äôre used to analyzing whether information is mutable or immutable and modelling your classes accordingly. And when defining your entities, you might want to do the same. But that creates potential issues.</p>



<h3 class="wp-block-heading"><code>var</code> vs. <code>val</code></h3>



<p>In Kotlin, you use val to define an immutable field or property and var for mutable ones. Under the hood, val is compiled in Java to a final field. But as discussed earlier, the Jakarta Persistence specification requires all fields to be non-final.</p>



<p>So, in theory, you can‚Äôt use val when modelling your entities. However, if you look at various projects, you can find several entities that use val without causing any bugs.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Person(name: String) {
¬†¬†¬†@Id
¬†¬†¬†@GeneratedValue
¬†¬†¬†var id: Long? = null

¬†¬†¬†val name: String = name
}</pre>



<p>That‚Äôs because your Jakarta Persistence implementation, the persistence provider, populates entity fields through reflection if you use field-based access, which is usually the case when implementing Jakarta Persistence entities in Kotlin. <code>final</code> fields can also be <a href="https://docs.oracle.com/javase/specs/jls/se25/html/jls-17.html#jls-17.5.3" target="_blank" rel="noopener">modified using reflection</a>. As a result, your persistence provider can modify val fields, but this contradicts Kotlin‚Äôs immutability guarantees.</p>



<p>So, practically, you can use <code>val</code> to model immutable fields of your entity class. Still, it‚Äôs not in line with the Jakarta Persistence specification, and your fields are not as immutable as you might expect. To make it even worse, <a href="https://openjdk.org/jeps/500" target="_blank" rel="noopener">JEP 500: Prepare to Make Final Mean Final</a> discusses introducing a warning and future changes to restrict final field modifications via reflection. This would prevent you from using <code>val</code> on your entity fields and break many persistence layers using Jakarta Persistence and Kotlin.</p>



<p>Be careful when using <code>val</code> for your entity fields and make sure everyone on your team understands the implications.</p>



<p>Starting with version 2026.1, IntelliJ IDEA will display a weak warning indicating that a val field will be modified when the persistence provider, such as Hibernate or EclipseLink, instantiates the entity object.</p>



<h2 class="wp-block-heading">Access types</h2>



<p>The Jakarta Persistence specification defines two access types that determine if your persistence provider uses getter and setter methods to access your entity‚Äôs fields or reflection.</p>



<p>You can define the access type explicitly by annotating your entity class with the <code>@Access</code> annotation. Or, as almost all development teams do, define it implicitly by where you place your mapping annotations:</p>



<ul>
<li>Annotations on entity fields ‚Üí field access = direct access using reflection</li>



<li>Annotations on getter methods ‚Üí property access = access via getter or setter methods</li>
</ul>



<p>Most Kotlin developers put their annotations on properties, which Hibernate treats as field access by default.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
¬†¬†¬†@Id
¬†¬†¬†@GeneratedValue
¬†¬†¬†var id: Long? = null

¬†¬†¬†var name: String? = null
¬†¬†¬†¬†¬†¬†¬†get() {
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†println("Getter called")
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†return field
¬†¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†¬†¬†¬†set(value) {
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†println("Setter called")
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†field = value
¬†¬†¬†¬†¬†¬†¬†}
}</pre>



<p>In this example, it might look like the getter and setter methods will be called to access the name property. But that‚Äôs only the case for your business logic. Because we annotated the fields, the persistence provider will use reflection to access them directly, bypassing the getter and setter methods.</p>



<p>As a general best practice, it‚Äôs recommended to stick to field access. It‚Äôs easier to read and lets your persistence provider access the entity‚Äôs fields directly. You can then provide getter and setter methods that help your business code without affecting your database mapping.</p>



<p>If you want to use property access, you can either annotate your entity class with <code>@Access(AccessType.PROPERTY)</code> or annotate the accessors explicitly:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
   @get:Id
   @get:GeneratedValue
   var id: Long? = null

   var name: String? = null
       get() {
           println("Getter called")
           return field
       }
       set(value) {
           println("Setter called")
           field = value
       }
}</pre>



<p>However, when you do this, you must ensure that all fields are defined as <code>var</code>. Kotlin doesn‚Äôt provide setter methods for fields defined as <code>val</code>.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
   @get:Id
   @get:GeneratedValue
   var id: Long? = null

   val name: String? = null 
}</pre>



<p>You can see this when checking Kotlin‚Äôs decompiled bytecode of a snippet above.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import kotlin.Metadata;
import org.jetbrains.annotations.Nullable;


@Entity
‚Ä¶
public final class Company {
  @Nullable
  private Long id;
  @Nullable
  private final String name;

  @Id
  @GeneratedValue
  @Nullable
  public final Long getId() {
     return this.id;
  }

  public final void setId(@Nullable Long var1) {
     this.id = var1;
  }

  @Nullable
  public final String getName() {
     return this.name;
  }
}
</pre>



<p>Your persistence provider will check that each field has a getter and a setter method. As long as you use var to define your entity fields, property access works with Kotlin.</p>



<h2 class="wp-block-heading">Null safety and default values</h2>



<p>Null safety and default values are two popular features in Kotlin that don‚Äôt exist in that form in Java. It‚Äôs no surprise that you have to pay special attention if you want to use them in your Jakarta Persistence entities.</p>



<h3 class="wp-block-heading">Nullability considerations (including primary key fields)</h3>



<p>Kotlin allows you to define whether a field or property supports <code>null </code>values. Unfortunately, reflection can bypass Kotlin&#8217;s null prevention, and as explained earlier, the persistence provider uses reflection to initialize your entity objects.</p>



<p>Even if you define an entity attribute as non-nullable, your persistence provider will set it to <code>null</code> if the database contains a <code>null</code> value. In your business code, this can lead to runtime exceptions similar to those seen in Java.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
@Table(name = "user")
class User(
   @Id
   var id: Long? = null

   var name: String
)

fun testLogic(){
   // Suppose the row with id = 1 has name = NULL in the database
   val user = userRepository.findById(1).get()
   println("Firstname: ${user.name}") // null, because Hibernate saves null via reflection
}</pre>



<p>And unfortunately, solving this problem is not as easy as it seems.</p>



<p>You could argue that all non-nullable entity fields should map to a database column with a not-null constraint. So, your database can‚Äôt contain any <code>null</code> values.</p>



<p>In general, this is a great approach. But it does not eliminate the risk completely. Constraints can get out of sync between different environments or during migrations. Therefore, using not-null constraints on your database is highly recommended, but it doesn‚Äôt provide an unbreakable guarantee that you will never fetch a <code>null</code> value from the database.</p>



<p>To make it even worse, all Jakarta Persistence implementations call the no-argument constructor of your entity class to instantiate an object and then use reflection to initialize each field. This means that technically, all your entity fields must be nullable.</p>



<p>What does that mean for your entities? Should you use <code>val</code> or <code>var</code> to model your fields?</p>



<p>That decision is ultimately up to you. Both of them work, but we recommend sticking to the Kotlin way: Use <code>val</code> if an entity field is not supposed to be changed by your business logic, and <code>var</code> otherwise. However, due to the issues discussed earlier, it is also essential to ensure that everyone on your team is aware that your Jakarta Persistence implementation may set those fields to <code>null</code> if your database lacks a not-null constraint.</p>



<h3 class="wp-block-heading">@Id and generated value</h3>



<p>The previous paragraphs already discussed why all entity fields should be nullable. However, many developers consider primary key attributes to be distinct because the database requires a primary key value, and the Jakarta Persistence specification defines it as immutable. Primary keys are mandatory and immutable as soon as you persist the entity object in your database. But let‚Äôs quickly discuss why this doesn‚Äôt mean that primary key values should be not-nullable, especially if you‚Äôre using database-generated primary key values.</p>



<p>When you want to store a new record in your database, you create a new entity object without a primary key and persist it.&nbsp;</p>



<p>Unfortunately, the Jakarta Persistence specification doesn‚Äôt clearly define how to implement the persist operation. But it requires generating a primary key value if none is provided. The handling of provided primary key values differs across implementations, but that‚Äôs a topic for a different article.&nbsp;</p>



<p>The important thing here is that all persistence providers treat null as a not-provided primary key value. They then use a database sequence or an auto-incremented column to generate a primary key value and set it on the entity object. Due to this mechanism, the primary key value is <code>null </code>before the entity gets persisted, and changes during the persist operation.</p>



<p>An interesting side note is that Hibernate handles the primary key value 0 differently when calling the persist or the merge method. The persist method throws an exception because it expects the object to be an already-persisted entity. In contrast, Hibernate‚Äôs merge method generates a new primary key value and inserts a new record into the database. That‚Äôs why you can model a primary key with the default value 0 and save the new entity object using Spring Data JPA. The default repository implementation recognizes the already set primary key value and calls the merge method instead of the persist method.</p>



<p>Now, returning to the initialization of primary key fields.</p>



<p>When you fetch an entity object from the database, your persistence provider uses the parameterless constructor to instantiate a new object. It then uses reflection to set the primary key value before it returns the entity object to your business code.</p>



<p>All of this clearly shows that the Jakarta Persistence specification expects the primary key field to be mutable, even though the primary key value is not allowed to change after it was assigned. To avoid any portability issues across different Jakarta Persistence implementations, use <code>null </code>to represent an undefined primary key value.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company {
   @Id
   @GeneratedValue
   var id: Long? = null
}</pre>



<h3 class="wp-block-heading">Declaring default values</h3>



<p>Kotlin‚Äôs support for default values can simplify your business code and prevent <code>null</code> values.&nbsp;</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@Entity
class Company(
   @Id @GeneratedValue 
   var id: Long? = null,

   @NotNull
   var name: String = "John Doe",

   @Email
   var email: String = "default@email.com"
)</pre>



<p>However, please be aware that these default values will have no effect when your persistence provider fetches an entity object from the database.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">val companyFromDb = companyRepository.findById(1).get()
println(companyFromDb.email) // &lt;- If email in DB is empty, it will not set to "default@email.com"</pre>



<p>The Jakarta Persistence specification requires a parameterless constructor that the implementations call when fetching an entity object from the database. After that, they use reflection to map all values retrieved from the database to the corresponding entity fields. As a result, the default values defined in your constructor will not be used, and some fields of your entity object might not be set even though you expect your constructor to assign default values. This may not cause any issues in your application, but it is something you and your team should be aware of.</p>



<h2 class="wp-block-heading">Annotation placement</h2>



<p>In Java, annotations are typically applied directly to the field, method, or class you annotate. In Kotlin, by contrast, annotations can target different elements, such as constructor parameters, properties, or fields.</p>



<p>Before Kotlin 2.2, this often caused problems because annotations applied to properties were applied only to the constructor parameter by default. This often caused problems for Jakarta Persistence and validation frameworks. Annotations like <code>@NotNull</code>, <code>@Email</code>, or even <code>@Id</code> didn&#8217;t end up where the framework expected them to be. This led to missed validations or mapping issues.</p>



<p>The good news is that this has been improved in Kotlin 2.2. With the new compiler option, which IntelliJ IDEA will suggest enabling, annotations will be applied to the constructor parameter and the property or field by default. So, your code now works as expected without requiring any changes.</p>



<p>To learn more, check out the <a href="https://blog.jetbrains.com/idea/2025/09/improved-annotation-handling-in-kotlin-2-2-less-boilerplate-fewer-surprises/">blog post</a>.</p>



<h2 class="wp-block-heading">IntelliJ IDEA to the rescue!</h2>



<p>In the upcoming 2026.1 release, IntelliJ IDEA will provide inspections and quick-fixes to address many of the problems mentioned in this article, thereby improving your overall experience. Be sure to update when the release becomes available. Here are a few examples of what you‚Äôll get with the new release:</p>



<ul>
<li>Highlighting missing no-arg constructors or final entity classes and suggestions to enable the correct Kotlin plugins.</li>



<li>Autoconfiguration of all essential setup when configuring Kotlin in the project.</li>



<li>Detection and quick fix for data classes and val fields on JPA-managed properties.</li>
</ul>



<p>And other JPA-related updates!</p>



<h2 class="wp-block-heading"><strong>About the author</strong></h2>


    <div class="about-author ">
        <div class="about-author__box">
            <div class="row">
                                                            <div class="about-author__box-img">
                            <img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/Thorben-Janssen-400x400-1.jpg" alt="" loading="lazy">
                        </div>
                                        <div class="about-author__box-text">
                                                    <h4>Thorben Janssen</h4>
                                                <div class="p-client_container">
<div class="p-ia4_client_container">
<div class="p-ia4_client p-ia4_client--sidebar-wide p-ia4_client--with-split-view-feature">
<div class="p-client_workspace_wrapper" role="tabpanel" aria-label="JetBrains">
<div class="p-client_workspace">
<div class="p-client_workspace__layout">
<div class="p-client_workspace__tabpanel" role="tabpanel" aria-label="DMs">
<div class="enabled-managed-focus-container" role="none">
<div>
<div class="p-view_contents p-view_contents--primary" tabindex="-1" role="dialog" aria-label="Conversation with Teodor Irkhin">
<div class="tabbed_channel__Abx5r">
<div class="tabbed_channel__Abx5r">
<div class="channel_tab_panel__zJ5Bt c-tabs__tab_panel c-tabs__tab_panel--active c-tabs__tab_panel--full_height" role="none" data-qa="tabs_content_container">
<div class="p-file_drag_drop__container">
<div class="p-workspace__primary_view_body">
<div class="p-message_pane p-message_pane--classic-nav p-message_pane--scrollbar-float-adjustment p-message_pane--with-bookmarks-bar" data-qa="message_pane">
<div>
<div id="message-list" role="presentation">
<div id="message-list" class="c-virtual_list c-virtual_list--scrollbar c-message_list c-scrollbar c-scrollbar--fade" role="presentation">
<div class="c-scrollbar__hider" role="presentation" data-qa="slack_kit_scrollbar">
<div class="c-scrollbar__child" role="presentation">
<div class="c-virtual_list__scroll_container" role="presentation" data-qa="slack_kit_list">
<div id="message-list_1766072525.327379" class="c-virtual_list__item" tabindex="0" role="listitem" aria-setsize="-1" data-qa="virtual-list-item" data-item-key="1766072525.327379">
<div class="c-message_kit__background c-message_kit__background--hovered p-message_pane_message__message c-message_kit__message" role="presentation" data-qa="message_container" data-qa-unprocessed="false" data-qa-placeholder="false" data-msg-ts="1766072525.327379" data-msg-channel-id="D072Y30UX54">
<div class="c-message_kit__hover c-message_kit__hover--hovered" role="document" aria-roledescription="message" data-qa-hover="true">
<div class="c-message_kit__actions c-message_kit__actions--above">
<div class="c-message_kit__gutter">
<div class="c-message_kit__gutter__right" role="presentation" data-qa="message_content">
<div class="c-message_kit__blocks c-message_kit__blocks--rich_text">
<div class="c-message__message_blocks c-message__message_blocks--rich_text" data-qa="message-text">
<div class="p-block_kit_renderer" data-qa="block-kit-renderer">
<div class="p-block_kit_renderer__block_wrapper p-block_kit_renderer__block_wrapper--first">
<div class="p-rich_text_block" dir="auto">
<p>Thorben Janssen is a consultant and trainer who helps teams build better persistence layers with JPA and Hibernate. An international speaker with more than 20 years of experience in JPA and Hibernate, Thorben is the author of the best-selling book¬†<i data-stringify-type="italic">Hibernate Tips: More than 70 solutions to common Hibernate problems</i>.</p>
<p>He also writes on¬†thorben-janssen.com¬†about various persistence topics, and to help developers improve their skills, he founded the Persistence Hub.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
                    </div>
                            </div>
        </div>
    </div>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Update your Kotlin projects for Android Gradle Plugin 9.0</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/update-your-projects-for-agp9/</link>
		
		<dc:creator><![CDATA[M√°rton Braun]]></dc:creator>
		<pubDate>Fri, 16 Jan 2026 10:30:56 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/KT-social-BlogFeatured-1280x720-1-10.png</featuredImage>		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=673033</guid>

					<description><![CDATA[Android Gradle plugin 9.0 is now available, and it includes two major changes that will affect existing Kotlin projects: This post provides some details about these changes and points you to the resources that you‚Äôll need to update your existing projects. You‚Äôll also need to update tools and plugins that depend on AGP to their [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><a href="https://developer.android.com/build/releases/agp-9-0-0-release-notes" target="_blank" rel="noopener">Android Gradle plugin 9.0</a> is now available, and it includes two major changes that will affect existing Kotlin projects:</p>



<ul>
<li>Android apps need to start using AGP 9.0‚Äôs <strong>built-in Kotlin support</strong>.</li>



<li>Kotlin Multiplatform projects targeting Android need to migrate to the <strong>new Android KMP library plugin</strong>.</li>
</ul>



<p>This post provides some details about these changes and points you to the resources that you‚Äôll need to update your existing projects.</p>



<p>You‚Äôll also need to update tools and plugins that depend on AGP to their latest versions with support for AGP 9.0. If you use Android Studio, you&#8217;ll need to use Otter 3 Feature Drop or later.</p>



<blockquote class="wp-block-quote">
<p>Note: Support for AGP 9.0 is coming soon to IntelliJ IDEA, expected to arrive in Q1 2026.</p>
</blockquote>



<p>For information about Gradle plugin compatibility, you can refer to <a href="https://agp-status.frybits.com/agp-9.0.0/" target="_blank" rel="noopener">this community-maintained page</a>.</p>



<p>We are working on adopting AGP 9.0 in our documentation, samples, and wizards. This means that they will all use AGP 9.0 by default and already include these changes in their respective configurations.</p>



<h2 class="wp-block-heading">Use built-in Kotlin</h2>



<p>Previously, Android projects had to apply the Kotlin Android plugin (<code>org.jetbrains.kotlin.android</code>) to add support for Kotlin source files. With AGP 9.0, Kotlin support is built in and enabled by default, so you no longer need to apply the Kotlin Android plugin separately for Android apps.</p>



<p>The main migration step here is to remove usages of the Kotlin Android plugin from your projects. However, if your project uses kapt for annotation processing or sets custom <code>kotlinOptions</code>, you‚Äôll need to update those configurations as well.</p>



<p>Read the <a href="https://developer.android.com/build/migrate-to-built-in-kotlin" target="_blank" rel="noopener">migration guide</a> in the Android documentation for step-by-step instructions.</p>



<blockquote class="wp-block-quote">
<p>With AGP 9.0, you can still opt out of these changes <em>temporarily</em> by adding <code>android.builtInKotlin=false</code> and <code>android.newDsl=false</code> to your <code>gradle.properties</code>. However, this will no longer work in AGP 10.0, which is expected sometime in 2026.</p>
</blockquote>



<h2 class="wp-block-heading">Use the new Android KMP library plugin</h2>



<p>In previous versions, the Android Gradle plugin provided two different plugins you could apply to a module:</p>



<ul>
<li>The Android library plugin (<code>com.android.library</code>).</li>



<li>The Android application plugin (<code>com.android.application</code>).</li>
</ul>



<p>Either of them could be used in combination with the KMP plugin (<code>org.jetbrains.kotlin.multiplatform</code>) to set up a multiplatform module.</p>



<p>AGP 9.0 introduces a new, simplified Android KMP library plugin (<code>com.android.kotlin.multiplatform.library</code>), built specifically for multiplatform projects. The previously used Android library and Android application plugins are no longer compatible with the KMP plugin in the same module, which means you‚Äôll need to migrate any multiplatform modules to the new plugin. This migration will be different for library and application modules; you can learn more about both scenarios below.</p>



<blockquote class="wp-block-quote">
<p>With AGP 9.0, you can still opt out of these changes <em>temporarily</em> by adding <code>android.enableLegacyVariantApi=true</code> to your <code>gradle.properties</code>. However, this will no longer work in AGP 10.0, which is expected sometime in 2026.</p>
</blockquote>



<h3 class="wp-block-heading">Migrating a library module</h3>



<p>If you have a module that uses the Android library plugin and the Kotlin Multiplatform plugin together, you‚Äôll have to <strong>replace the Android library plugin with the Android KMP library plugin</strong>. This means you‚Äôll have to update the build configuration of your existing module, but generally no changes are required to your project structure or source code.</p>



<p>The new Android KMP library plugin has default settings that are designed for Kotlin Multiplatform and optimized for build speed and stability. Some previous configuration options have been removed or moved to new APIs.</p>



<p>Read the <a href="https://developer.android.com/kotlin/multiplatform/plugin#migrate" target="_blank" rel="noopener">migration guide</a> to learn about the differences and get step-by-step instructions on how to migrate a library module to the new plugin.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://developer.android.com/kotlin/multiplatform/plugin#migrate" class="btn" target="" rel="noopener">Migrate a library module</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading">Migrating an application module</h3>



<p>Many projects apply both the Android application plugin and the Kotlin Multiplatform plugin in the same module. A module like this contains shared multiplatform code as well as an Android application with all of its related build configuration. This was the recommended structure in the past, and if you created your project using the KMP wizard, your project probably has a single <code>composeApp</code> module that‚Äôs set up like this.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/before.png" alt="" class="wp-image-673062" style="aspect-ratio:2.259770114942529;width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/><figcaption class="wp-element-caption">The starting setup</figcaption></figure></div>


<p>Modules like this also have to be migrated to use the new Android KMP library plugin in the module that contains shared code, which requires multiple steps.</p>



<p>First, you‚Äôll have to <strong>create a new module for the entry point of your app and apply the Android application plugin</strong> there. This new module can be relatively small and simple, containing the build configuration to package an Android app and its entry point, such as <code>Activity</code> and <code>Application</code> classes (all represented by <code>MainActivity</code> in the illustrations here).</p>



<blockquote class="wp-block-quote">
<p>When using AGP 9.0, this new module doesn‚Äôt need to apply a Kotlin plugin, as it can use the built-in Kotlin support (as detailed above).</p>
</blockquote>



<p>Then, this new application module should <strong>depend on the existing multiplatform module</strong> to have access to its contents. The multiplatform module can now become an Android library, which means you should <strong>migrate it to the new Android KMP library</strong><strong><em> </em></strong><strong>plugin</strong>.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/after.png" alt="" class="wp-image-673073" style="width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/><figcaption class="wp-element-caption">The migrated project</figcaption></figure></div>


<p>To migrate an Android application module to AGP 9.0, follow the detailed steps in the <a href="https://kotlinlang.org/docs/multiplatform/multiplatform-project-agp-9-migration.html" target="_blank" rel="noopener">migration guide</a>.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://kotlinlang.org/docs/multiplatform/multiplatform-project-agp-9-migration.html" class="btn" target="" rel="noopener">Migrate an application module</a>
                                                    </div>
    </div>







<h2 class="wp-block-heading">Conclusion</h2>



<p>We recommend making these configuration changes in your existing projects as soon as possible to ensure smooth upgrades to the latest versions of AGP in the future.</p>



<p>In addition to the links above, you can read the <a href="https://developer.android.com/build/releases/agp-9-0-0-release-notes" target="_blank" rel="noopener">full release notes for AGP 9.0</a> to learn more about what‚Äôs new.</p>



<p>If you encounter any issues with AGP 9.0 itself, <a href="https://issuetracker.google.com/issues/new?component=192708" target="_blank" rel="noopener">create a new issue</a> in the Android Studio component of the Google issue tracker.</p>



<p>For problems related to the Kotlin Multiplatform IDE plugin, <a href="https://youtrack.jetbrains.com/newIssue?project=KMT" target="_blank" rel="noopener">create an issue in the KMT tracker</a>.</p>



<p>To provide feedback on Kotlin documentation, <a href="https://youtrack.jetbrains.com/newIssue?project=KT" target="_blank" rel="noopener">create an issue on YouTrack</a> or report it in the <a href="https://slack-chats.kotlinlang.org/c/multiplatform" target="_blank" rel="noopener">#multiplatform channel</a> on the Kotlinlang Slack.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Compose Multiplatform 1.10.0: Unified @Preview, Navigation 3, and Stable Compose Hot Reload</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/compose-multiplatform-1-10-0/</link>
		
		<dc:creator><![CDATA[Elvira Mustafina]]></dc:creator>
		<pubDate>Tue, 13 Jan 2026 14:48:34 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/CMP-social-BlogFeatured-1280x720-1.png</featuredImage>		<category><![CDATA[multiplatform]]></category>
		<category><![CDATA[compose-hot-reload]]></category>
		<category><![CDATA[compose-multiplatform]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=674389</guid>

					<description><![CDATA[Compose Multiplatform 1.10.0 has been released! We‚Äôre continually developing our multiplatform APIs and expanding support for Jetpack libraries commonly used on Android. Here are the highlights of this release: Get Started with Compose Multiplatform For a complete overview of the changes, check out What‚Äôs new in Compose Multiplatform 1.10.0 or the release notes on GitHub. [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Compose Multiplatform 1.10.0 has been released! We‚Äôre continually developing our multiplatform APIs and expanding support for Jetpack libraries commonly used on Android.</p>



<p>Here are the highlights of this release:</p>



<ul>
<li><a href="#common-preview" data-type="internal">One common <code>@Preview</code> annotation to rule them all</a></li>



<li><a href="#navigation-3" data-type="internal">Navigation 3 is available on non-Android targets</a></li>



<li><a href="#compose-hot-reload" data-type="internal">Stable and bundled Compose Hot Reload</a></li>
</ul>



<p></p>



<p align="center"><a class="ek-link jb-download-button" href="https://kotlinlang.org/docs/multiplatform/compose-multiplatform-create-first-app.html" target="_blank" rel="noopener"><i class="download-icon"></i>Get Started with Compose Multiplatform</a></p>



<p>For a complete overview of the changes, check out <a href="https://kotlinlang.org/docs/multiplatform/whats-new-compose-110.html" target="_blank" rel="noopener">What‚Äôs new in Compose Multiplatform 1.10.0</a> or the <a href="https://github.com/JetBrains/compose-multiplatform/releases/tag/v1.10.0" target="_blank" rel="noopener">release notes on GitHub</a>.</p>



<h2 class="wp-block-heading" id="common-preview">Common <code>@Preview</code> annotation</h2>



<p>Previously, we had three separate <code>@Preview</code> annotations across different packages, which made it challenging to figure out the correct combination of annotation, platform, and IDE.</p>



<p>With this release, we‚Äôve unified previews under a single <code>@Preview</code> annotation that works in your <code>commonMain</code> source set:</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/preview_in_common_code.png" alt="Preview in common code" class="wp-image-673989" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>All other annotations have been deprecated. But fear not ‚Äì IDE quick-fix suggestions will help you easily update your dependencies to <code>androidx.compose.ui.tooling.preview.Preview</code>.</p>



<h2 class="wp-block-heading">Navigation 3</h2>



<p>We‚Äôve introduced support for Navigation 3, a new library for managing navigation. With Navigation 3, you can manipulate your navigation stack directly, making tasks like adding or removing destinations more straightforward.</p>



<p>To help you get started, we‚Äôve compiled a set of <a href="https://github.com/terrakok/nav3-recipes" target="_blank" rel="noopener">Navigation 3 recipes</a>&nbsp;with examples of common usage patterns for Compose Multiplatform.</p>



<figure class="wp-block-image is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/navigation3_recipes.png" alt="Navigation 3 in Compose Multiplatform" class="wp-image-673978" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<h2 class="wp-block-heading">Compose Hot Reload</h2>



<p>Compose Hot Reload is designed to speed up UI iteration by letting you instantly see changes without restarting the application:</p>


                                                <figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" data-gif-src="https://blog.jetbrains.com/wp-content/uploads/2026/01/KotlinConf_hot_reload.animated.gif" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/KotlinConf_hot_reload.png" alt="" class="wp-image-673967"/></figure>
                        


<p>The Compose Hot Reload plugin is now stable ‚Äì check out this <a href="https://blog.jetbrains.com/kotlin/2026/01/the-journey-to-compose-hot-reload-1-0-0/">deep-dive blog post</a> to learn more about how it works. It‚Äôs now bundled with the Compose Multiplatform Gradle plugin and enabled by default, so no additional configuration is required.</p>



<p align="center"><a class="ek-link jb-download-button" href="https://kotlinlang.org/docs/multiplatform/compose-hot-reload.html#use-compose-hot-reload" target="_blank" rel="noopener"><i class="download-icon"></i>Try Compose Hot Reload</a></p>



<hr class="wp-block-separator has-alpha-channel-opacity"/>



<p>These are just the highlights ‚Äì this release includes numerous updates across platforms, including the introduction of more transparent <a href="https://kotlinlang.org/docs/multiplatform/whats-new-compose-110.html#deprecated-dependency-aliases" target="_blank" rel="noopener">dependency management</a> for Compose Multiplatform libraries with direct library references.</p>



<p>Make sure to check out the <a href="https://kotlinlang.org/docs/multiplatform/whats-new-compose-110.html" target="_blank" rel="noopener">full version</a> in our documentation. If you encounter any issues, please report them on our <a href="https://youtrack.jetbrains.com/issues/CMP" target="_blank" rel="noopener">issue tracker</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>The Journey to Compose Hot Reload 1.0.0</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/the-journey-to-compose-hot-reload-1-0-0/</link>
		
		<dc:creator><![CDATA[Sebastian Sellmair]]></dc:creator>
		<pubDate>Tue, 13 Jan 2026 14:47:58 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/CMP-social-BlogFeatured-1280x720-1-1.png</featuredImage>		<category><![CDATA[multiplatform]]></category>
		<category><![CDATA[compose-hot-reload]]></category>
		<category><![CDATA[compose-multiplatform]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=673207</guid>

					<description><![CDATA[Compose Hot Reload has just been promoted to stable with our 1.0.0 release. We worked hard to build a technology that is easy to use and well-integrated into existing tools while also requiring zero configuration from users. The tool is bundled with Compose Multiplatform, starting from version 1.10 (see our dedicated release blog post). While [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Compose Hot Reload has just been promoted to stable with our <a href="https://github.com/JetBrains/compose-hot-reload/releases/tag/v1.0.0" target="_blank" rel="noreferrer noopener">1.0.0</a> release. We worked hard to build a technology that is easy to use and well-integrated into existing tools while also requiring zero configuration from users. The tool is bundled with Compose Multiplatform, starting from version 1.10 (see our dedicated <a href="https://blog.jetbrains.com/kotlin/2026/01/compose-multiplatform-1-10-0/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2026/01/compose-multiplatform-1-10-0/" rel="noreferrer noopener">release blog post</a>). While we‚Äôre happy to have built tooling that doesn&#8217;t really require users to think about its technical implementation, we‚Äôre also immensely proud of the engineering behind the project. This blog post highlights some of the technical aspects we find most interesting and provides a high-level overview of how Compose Hot Reload works under the hood.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/aa93f2aa-b976-4bc0-94c0-e5338cab4e01.png" alt="" class="wp-image-674265" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<h2 class="wp-block-heading">What we‚Äôve built so far</h2>



<p>Compose Multiplatform is a declarative framework for sharing UIs across multiple platforms. Typically, if you‚Äôd like to launch a Compose application during development, you need to invoke the corresponding Gradle build tasks or otherwise launch it directly from within the IDE. This is also the case with Compose Hot Reload. Launching your application can be done by invoking the <code>./gradlew :myApp:hotRunJvm</code> task or clicking <em>Run with Compose Hot Reload</em> in IntelliJ IDEA (assuming that the Kotlin Multiplatform plugin has already been installed).</p>



<p>Once the app launches in hot-reload mode, we see a floating toolbar right next to the application window. Changing code within IntelliJ IDEA and clicking <em>Save</em> (<em>Cmd</em>+<em>S</em>/<em>Ctrl</em>+<em>S</em>) will recompile the relevant code, perform a hot reload, and update the UI accordingly while preserving all parts of the state that are still considered valid.</p>



<p><em>Note: Screen recordings were made using the latest Compose Hot Reload version, 1.1, which differs visually from the 1.0 release but is conceptually equivalent.</em></p>



<figure class="wp-block-video"><video controls src="https://blog.jetbrains.com/wp-content/uploads/2026/01/hot-reload-demo-cc.mp4"></video></figure>



<p>Beyond simply changing the image resources, Compose Hot Reload lets you make almost arbitrary changes to your code, including but not limited to adding and removing functions, classes, and parameters ‚Äì in short, all the kinds of changes you typically make during regular development.</p>



<p>The floating toolbar next to your application offers additional features, such as the ability to view logs, manually trigger a reload, and reset the UI state, as well as status indications and more. One of the most critical aspects of any hot-reload user experience, however, is communicating whether something went wrong. As the developer, you should always be acutely aware when reloading fails, causing your current code changes not to be reflected in the application. This could happen, for example, if you try to reload but the code cannot compile and requires your attention. In such cases, Compose Hot Reload will prominently display the error right in the target application&#8217;s window.</p>



<figure class="wp-block-video"><video controls src="https://blog.jetbrains.com/wp-content/uploads/2026/01/error-demo-cc.mp4"></video></figure>



<h2 class="wp-block-heading">Let‚Äôs decompose Compose Hot Reload</h2>



<p>Looking at the example above, let‚Äôs break Compose Hot Reload into its separate components and try to understand their individual purposes. In this section, we will recreate the process of building the core of Compose Hot Reload from the ground up, before proceeding to an explanation of the more technical details in the following sections.</p>



<p>First things first, the main requirement for Compose Hot Reload is the ability to update the application while it is running dynamically. To achieve this, we need to answer two questions: <strong>How </strong>do we reload code that is already running dynamically, and <strong>when</strong> should we do it? Without first answering these questions, the technology will not work.&nbsp;</p>



<p>The <strong>how</strong> part can be achieved in multiple ways in the JVM world: using custom classloaders, JVM hot swapping, and via various other methods. But what really makes Compose Hot Reload work so well is the JetBrains Runtime and its DCEVM implementation, which we‚Äôll cover in detail later.</p>



<p>With the <strong>how</strong> being taken care of by DCEVM, we need to decide on the <strong>when</strong>. In other words, we need a way to run the application with DCEVM, detect when the user makes changes, recompile the code, and trigger the reload. That‚Äôs right, we need an integration with the application‚Äôs build system ‚Äì a plugin that will provide us access to applications&#8217; build and launch configurations.</p>



<p>It would seem that these components should provide everything we need, right? We can integrate with the application&#8217;s build system and trigger code reloads when the user changes their code! Unfortunately, it‚Äôs not that simple. You see, dynamically changing the code will not re-render the application&#8217;s UI. Even worse, changes to the code can now lead to errors when interacting with the UI. For example, what will happen if a user interacts with a button that no longer exists in the code? Therefore, we also need a way to interact with the Compose framework and re-render the UI when necessary. Luckily, the Compose Runtime provides APIs to invalidate states and re-render UIs, so we just need to correctly invoke them after the code is reloaded.</p>



<p>Good news: these three components are sufficient to provide the core functionality of Compose Hot Reload! But to truly elevate the user experience, we need to provide quick visual feedback on the current state of the hot reload. That&#8217;s why Compose Hot Reload also offers:</p>



<ul>
<li>In-app notifications about the state of any hot reloads.</li>



<li>A custom toolbar next to the application window, which allows us to track the status and control the state of a given hot reload.</li>



<li>Integration with an IDE that allows you to easily run the application with Compose Hot Reload and monitor its state.</li>
</ul>



<p>Now that you have the rough outline of Compose Hot Reload, let&#8217;s dive deeper into its technical implementation. There is a lot to discover!</p>



<h2 class="wp-block-heading">Reloading code dynamically: DCEVM and the JetBrains Runtime </h2>



<p>As previously mentioned, Compose Hot Reload relies heavily on the JetBrains Runtime to run the user code. Not only is the JetBrains Runtime specialized in building UI applications, it is also, to date, the only JVM to implement the <a href="https://www.sciencedirect.com/science/article/pii/S0167642311001456?via%3Dihub" target="_blank" rel="noreferrer noopener">DCEVM proposal</a> published in 2011 by Thomas W√ºrthinger, Christian Wimmer, and Lukas Stadler. This proposal enhances virtual machines&#8217; ability to reload code. Where a regular JVM is limited to just reloading function bodies, DCEVM proposes ‚Äúunrestricted and safe dynamic code evolution for Java‚Äù, which lifts the restrictions and supports almost arbitrary code changes. Here‚Äôs an example demonstrating how the JetBrains Runtime can perform more complex reloads:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/data-classes.png" alt="" class="wp-image-674276"/></figure>



<p>The given program creates an instance of the class <code>Foo</code> and prints it every second in an endless loop.</p>



<p>When reloading, the class was modified, and a second property <code>y</code> was added. This begs the question: How can the program <strong>and the current state</strong> be reloaded in this way? Once the developer edits the code and compiles it, Compose Hot Reload sends the updated <code>.class</code> files to the currently running application, requesting that it reload. The request will be handled over several subsequent steps.&nbsp;</p>



<p>The first step can be called ‚Äúverification‚Äù: The JetBrains Runtime will check whether the new .class files are valid and can generally <em>be reloaded</em>. If the code passes all checks, it can proceed to the second stage, ‚Äúloading‚Äù. Then, the JetBrains Runtime will load all classes into what we call a ‚Äúside universe‚Äù. This will represent the application code (all loaded classes) after the reload.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/SystemClassLoader.png" alt="" class="wp-image-674287" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>At this point, the side universe can be thought of as a second instance of your application, containing all updated application code, but without any state or threads executing. The above example shows the changed <code>Foo.class</code> marked in green, indicating that it points to an updated version of the class.</p>



<p>The current state of the application is then required to migrate objects to this side universe: We call this a ‚Äústate transfer‚Äù. This state transfer is implemented as a special garbage collection (GC) pass. GC has a few properties that are useful for implementing the state transfer. Not only is it possible to ‚Äústop the world‚Äù (wait for all application threads to reach safe points), but GC is also allowed to allocate new memory and move objects to new locations!</p>



<p>To demonstrate this for the previous example, we can look at the instance created by <code>val foo = Foo(1)</code>. The actual instance might look something like this in your memory:</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/ObjectHeader.png" alt="" class="wp-image-674298" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>This is where the object currently resides at a known memory location. The memory representation of our object starts with a 16-byte header containing metadata about our object, for example, a pointer or a compressed pointer to our runtime representation of the class (called <code>Klass</code>). Right after the header, we can find the actual fields stored in the object. In our case, we see the value 1 associated with the property x. Memory before or after our object is unknown and could contain basically anything. When a reload changes a class&#8217;s layout by adding or removing properties, it becomes clear that the object needs to be adjusted.</p>



<p>This is where the nature of GC works well for migrating the object. GC can allocate a new block of memory to account for the object&#8217;s new size, and then start migrating the object by copying its previous values. In the chosen example, we added one more <code>int</code> field, requiring us to allocate 32 additional bits of memory. Since the <code>x</code> field was unchanged, we can just copy the previous value to its new location. However, a decision has to be made on how to treat the newly introduced field <code>y</code>. Re-running the constructor is not feasible, so DCEVM uses the JVM defaults: null, 0, and <code>false</code>.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/ObjectHeader_2.png" alt="" class="wp-image-674309" style="width:500px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>Note that the new object has a different header that points to the new <code>Klass</code> object, representing the reloaded code.</p>



<p>Once all objects are migrated, all pointers to them will be updated to point to the migrated objects. In our example above, the instance <code>Foo</code> has moved to a new memory location and now carries a y property.&nbsp;</p>



<p>Before we can resume the application, the runtime needs to consider that previous optimizations and just-in-time compilations to machine code might be invalid. For this reason, the code is then ‚Äúde-optimized‚Äù. Once the application resumes, the JIT compiler is free to kick in again, optimizing our code and returning the application to the previous level of performance.</p>



<h2 class="wp-block-heading">Java agents FTW</h2>



<p>DCEVM is an amazing technology that allows you to dynamically reload and redefine code while it is executing. However, to make it actually work, we need a way to call its APIs from the user application.&nbsp;</p>



<p>Luckily, the JVM has a way to implement that ‚Äì it&#8217;s called a <strong>Java agent</strong>. A Java agent is a Java library that can be attached to any Java program and execute code before the target program starts.</p>



<p>To create a Java agent, we need to declare a class with a <code>premain</code> method. This method, as the name suggests, will be executed<strong><em> </em></strong><em>before</em> the target application‚Äôs <code>main</code>, i.e. during JVM startup. The method takes a <code>String</code> argument and an instance of <code>java.lang.instrument.Instrumentation</code><strong> </strong>as its parameters.</p>



<pre class="EnlighterJSRAW">fun premain(args: String, instrumentation: Instrumentation)</pre>



<p><code>java.lang.instrument.Instrumentation</code> is a part of the <strong>Java Instrumentation API</strong>, which allows agents to <strong>observe</strong>, <strong>modify</strong>, and <strong>redefine</strong> classes at runtime. When you are using the JetBrains Runtime, <code>java.lang.instrument.Instrumentation</code> provides you with access to DCEVM via its <code>redefineClasses</code> method implementation.</p>



<p>So, in the case of Compose Hot Reload, the Java agent&#8217;s function is relatively straightforward: We attach it to the target application and launch a background task/thread in the <code>premain</code>. This background task will invoke <code>instrumentation.redefineClasses</code> with new classes whenever it receives information about changes to the application&#8217;s code.&nbsp;</p>



<p>Finally, we just need to package our agent as a standalone JAR and give the agent information required by the JVM in the manifest file:</p>



<p><code>Premain-Class: org.jetbrains.compose.reload.agent.ComposeHotReloadAgent</code></p>



<p><code>Can-Redefine-Classes: true&nbsp; // declare that we intend to redefine classes</code></p>



<p>In practice, we use the Compose Hot Reload agent for much more than just redefining classes via DCEVM. We will cover its other functions in the following sections.</p>



<p>You may have noticed that we boldly skipped one of the most important parts of any hot reload by simply claiming that the agent ‚Äúreceives information about changes in the code‚Äù. It is, indeed, not so simple. However, to get the whole picture, we first have to dive into another complex subsystem of Compose Hot Reload ‚Äì its integration with build systems.</p>



<h2 class="wp-block-heading">Building a zero-configuration tool</h2>



<p>The combination of the JetBrains Runtime‚Äôs ability to reload code and an agent that can listen for reload requests form the core functionality of Compose Hot Reload. Integrating these components into a zero-configuration product requires careful integration into build tools. The following describes how the Gradle plugin is implemented, but hot reload is also available in <a href="https://amper.org/dev/" target="_blank" rel="noreferrer noopener">Amper</a>. The user-facing workflows can be separated into two typical kinds of builds: In the first, the user compiles the application and intends to launch it in hot-reload mode. In the second kind of build, there will be multiple reloads. These consist of incrementally compiling the code, and then sending the reload request to the agent after a given change. Reload requests typically contain all <code>.class</code> files that have been either changed, added, or modified. While reloading can be triggered manually, it is typically managed either by Compose Hot Reload itself or by the IDE, which watches source files for changes.&nbsp;</p>



<p>This leads to two questions:&nbsp;</p>



<ol>
<li>How can the set of <strong>changed files</strong> be resolved efficiently when reloading?</li>



<li>How can other tools reliably issue reloads?</li>
</ol>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-23.png" alt="" class="wp-image-673267"/></figure>



<p>The flow of launching the application already gives a lot of insights into how the overall system works, and it is relatively straightforward:&nbsp;</p>



<p>The entire project is compiled, as usual, and produces the corresponding <code>.class</code> files. Typically, applications can launch directly afterwards by launching the JVM with all necessary arguments (classpath, properties, JVM arguments, user arguments, etc.). A hot reload run will then perform two additional steps before actually launching.</p>



<p>After the compilation finishes, a snapshot of the classpath is taken. It&#8217;s worth mentioning that Compose Hot Reload differentiates the classpath into a <strong>hot</strong> and <strong>cold</strong> part. Dependencies resolved from remote repositories are considered <strong>cold</strong> because they won‚Äôt change during a hot reload session. Code compiled by the current build, however, is considered <strong>hot</strong>. The snapshot is therefore only taken of the <strong>hot</strong> part of the classpath and contains all known <code>.class</code> files, each with a checksum of its contents.</p>



<p>The second task performed by hot reload is to produce special hot-reload arguments for the run. For convenience and to support restarting the application, these arguments will be stored in an <code>.argfile</code>. The most important arguments being:</p>



<ul>
<li><code><em>-</em>XX:+AllowEnhancedClassRedefinition</code>, which enables the JetBrains Runtime‚Äôs DCEVM capabilities.</li>



<li><code><em>-</em>javaagent:/.../hot-reload-agent-1.1.0.jar</code>, which adds our agent to the application.</li>



<li><code>-Dcompose.reload.buildSystem=Gradle</code>, which tells Compose Hot Reload to use the Gradle recompiler backend.</li>



<li><code><em>-</em>Dgradle.build.root=/.../myProject</code>, which tells Compose Hot Reload where the current Gradle project is located.</li>



<li><code><em>-</em>Dgradle.build.project=:app</code>, which indicates which Gradle project was launched for hot reload.</li>



<li><code><em>-</em>Dgradle.build.task=hotReloadJvmMain</code>, which tells Compose Hot Reload which Gradle task can be executed to issue a reload.</li>



<li><code>-Dcompose.reload.devToolsClasspath=...</code>, which provides the floating toolbar application classpath.</li>



<li><code>-Dcompose.reload.devToolsEnabled=true</code>, which enables the floating toolbar application.</li>
</ul>



<p>Given that the application now has all the information necessary to start reloads by invoking the provided Gradle task at the provided location, Compose Hot Reload will start a supervisor process called <code>devTools</code>. This is the same process that will then provide the floating toolbar window. This process will either start a continuous Gradle build for reloading or wait for external events (such as you clicking <em>Reload</em>, or the IDE sending a signal to reload).&nbsp;</p>



<p>Such signals can be sent through the orchestration protocol, which we‚Äôll talk about in more detail later. For now, it is just essential to know that the application will host a TCP server that allows components, such as Gradle, Amper, or the IDE, to communicate with each other.</p>



<p>Requests to reload the application will trigger the corresponding reload task. Such a Gradle invocation will be marked as <code>isHotReloadBuild</code> and will get the application server port forwarded as <code>orchestration.port</code>.</p>



<p>Once the project is compiled incrementally, the snapshot will be rebuilt incrementally as well. Comparing the previous snapshot to the new one is quick and produces a map of <code>.class</code> files that are either added, removed, or modified.&nbsp;</p>



<p>The last task is to connect to the application using the provided port and send a request to reload those files. The agent will handle this request and reload the code using the JetBrains Runtime.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-24.png" alt="" class="wp-image-673279"/></figure>



<p>Since all relevant tasks can be created automatically by inferring them from the Kotlin Gradle Plugin model, the tool can be used effectively without any further configuration. Launching from the CLI only requires calling the corresponding <code>hotRunJvm</code> task. IntelliJ IDEA can import hot reload tasks during the Gradle sync process and create corresponding run gutters.</p>



<h2 class="wp-block-heading">But what about the UI?</h2>



<p>As we mentioned before, being able to reload the code does not guarantee that Compose Hot Reload will magically start working. Modern applications are far too complex for that to happen. Therefore, after reloading the code, we need to propagate those updates throughout the application, re-rendering the UI, resetting the state, cleaning the references to the old code, etc.&nbsp;</p>



<p>Now, to do that correctly, we first need to understand how Compose code actually works. Let&#8217;s take a look at how our <code>App</code> function from the previous examples is represented.</p>



<pre class="EnlighterJSRAW">@Composable
fun App() {
   var clicks by remember { mutableStateOf(0) }
   MaterialTheme {
       Column(
           horizontalAlignment = Alignment.CenterHorizontally,
       ) {
           Button(onClick = { clicks++ }) {
               Text(&quot;Clicks: $clicks&quot;)
           }


           Icon(
               imageResource(Res.drawable.Kodee_Assets_Digital_Kodee_greeting),
               contentDescription = &quot;Kodee!!!&quot;,
               modifier = Modifier,
               tint = Color.Unspecified
           )
       }
   }
}</pre>



<p>Compose splits the code into sections called <strong>groups</strong> and assigns each group a unique integer key. As an approximation, you can think that each <strong>scope</strong> (e.g. each <code>{}</code> pair in the code) corresponds to a separate group. The groups are organized in a tree-like structure that corresponds to their relations in the source code. In this image, green nodes correspond to Compose groups created by the <code>App</code> function, blue nodes represent other Composable functions called in the <code>App</code> function, and white nodes represent state information.&nbsp;</p>



<p>When the Compose Runtime detects that some parts of the UI need to be re-rendered, it marks the groups corresponding to those components as invalid. It then re-executes all the code corresponding to those groups, creating an updated version of the tree. Subsequently, this means that the state<strong> </strong>created by any invalidated groups will be reset. For example, if we invalidate the group with the key -419397569, the mutable state with the counter will not be reset, while all the other code will be re-executed.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-25.png" alt="" class="wp-image-673314"/></figure>



<p>Now that we have a high-level understanding of the Compose representation, how do we actually implement hot reload? Well, the intuitive option would be to reuse the Compose Runtime&#8217;s existing functionality: If the code changes, we invalidate all groups corresponding to that code. This will allow us to:</p>



<ul>
<li>Re-render only the necessary parts of the UI.</li>



<li>Preserve the state whenever possible.</li>



<li>Clean up all references to the old code.</li>
</ul>



<p>To do that, we need to understand:</p>



<ul>
<li>What code has been changed?</li>



<li>Which Compose groups need to be invalidated because of that change?</li>
</ul>



<p>And here, the Compose Hot Reload agent comes into play one more time.</p>



<h3 class="wp-block-heading">Bytecode analysis</h3>



<p>When compiling the application, the Compose plugin changes the intermediate representation (IR) of the Composable functions and inserts additional instructions for the Compose Runtime. For example, the bytecode of the <code>App</code> function will start with the following instruction: <code>$composer.startRestartGroup(1359525739)</code>.</p>



<p>Here, <code>startRestartGroup</code> is a special instruction of the Compose Runtime that marks the start of a new group, and its argument is the key for this group. Correspondingly, the end of this group will be marked by a call to <code>endRestartGroup</code>. This means that all the information that we‚Äôre interested in is actually contained in the bytecode; we just need to extract it.</p>



<p>Luckily, the Java agent allows us to hook into the target application and inspect all the classes while they are loading. We use the <a href="https://asm.ow2.io/" target="_blank" rel="noopener">ASM</a> library to analyze classes, and for each method, we build our own representation of the Compose tree. By locating the startGroup and endGroup calls, we can determine the bounds (and keys) of Compose groups, and their locations in the code define the parent-child relations between them. Conditional branches inside a function can be parsed by tracking jump instructions and their target labels.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/scopes.png" alt="" class="wp-image-673336"/></figure>



<p>For each Compose group, we determine its key, its relations with other groups, its dependencies on different methods, and its <strong>hash</strong>. The group&#8217;s hash value attempts to capture its semantics; for simplicity, we can think of it as a hash of all the bytecode instructions in this group. It allows us to quickly determine whether the group&#8217;s code has changed semantically during reloads.</p>



<h3 class="wp-block-heading">Tracking changes</h3>



<p>Now that we know how to extract information from the bytecode, we need to think about how to apply it. As we mentioned, a Java agent allows us to analyze every class before it has been loaded. This will enable us to analyze classes not only during initial loading, but also during reloads. Thus, during reload, we can keep track of both the old and new versions of each class and monitor changes.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/runtime.png" alt="" class="wp-image-673347"/></figure>



<p>When the class is reloaded, we can compare both its old and new runtime information and invalidate groups using the following rules.</p>



<ul>
<li>If the code hash of a Compose group is changed, invalidate it.</li>



<li>If the code hash of a non-Compose function is changed, invalidate all Compose groups that are (transitively) dependent on it. Since we keep track of the entire runtime, we can efficiently compute all method dependencies.</li>
</ul>



<p>After that, the only thing left to do is to save the new version of the runtime as the current one.</p>



<h2 class="wp-block-heading">The compiler doesn‚Äôt like your hot reload stuff</h2>



<p>Even though the core idea of the code invalidation and UI re-rendering approach is not particularly complicated, the path to Compose Hot Reload&#8217;s success was blocked by many obstacles and hurdles we had to overcome. Many of them stemmed from the fact that the Kotlin compiler and Compose plugin weren‚Äôt built with DCEVM and hot swapping in mind. Therefore, bytecode produced by those tools often behaved unexpectedly during hot reload. In this section, we will highlight some of the technical difficulties we encountered during the development of Compose Hot Reload and how we solved them.</p>



<h3 class="wp-block-heading">All your lambdas belong to us</h3>



<p>Both Kotlin and Compose encourage heavy use of lambda functions. However, lambda functions were a significant source of inconsistency in the bytecode produced by the Kotlin compiler, mainly due to their names. Users do not provide names for lambda functions; therefore, the compiler generates them itself, using predefined rules to determine each lambda&#8217;s name. Unfortunately, those rules are not designed with hot reload in mind.</p>



<p>There are two ways a lambda function can be compiled to the bytecode: anonymous classes and indy lambdas. The first way suggests that a lambda is compiled as a class that implements one of Kotlin‚Äôs <code>FunctionN</code> interfaces, and the lambda‚Äôs body is placed inside the <code>invoke</code> method of this class.</p>



<p>The indy way suggests that a lambda is compiled as a function inside the original class, which is then converted into an object in the runtime via the JVM‚Äôs <code>invokedynamic</code> instruction and the <code>LambdaMetafactory</code>.</p>



<pre class="EnlighterJSRAW">fun bar() =
   foo { println(it) }


fun foo(a: (Int) -&gt; Unit) {
   listOf(1, 2, 3).forEach(a)
}</pre>



<p>Class-based lambda:</p>



<pre class="EnlighterJSRAW">final class org/example/project/MainKt$bar$1 extends kotlin/jvm/internal/Lambda implements kotlin/jvm/functions/Function1 {
   // access flags 0x0
   &lt;init&gt;()V
           L0
   ALOAD 0
   ICONST_1
   INVOKESPECIAL kotlin/jvm/internal/Lambda.&lt;init&gt; (I)V
   RETURN


   // access flags 0x11
   public final invoke(I)V
   GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
   ILOAD 1
   INVOKEVIRTUAL java/io/PrintStream.println (I)V
   RETURN
}</pre>



<p>Indy lambda:</p>



<pre class="EnlighterJSRAW">public final static bar()V
INVOKEDYNAMIC invoke()Lkotlin/jvm/functions/Function1; &#091;
// handle kind 0x6 : INVOKESTATIC
java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
// arguments:
(Ljava/lang/Object;)Ljava/lang/Object;,
// handle kind 0x6 : INVOKESTATIC
org/example/project/MainKt.bar$lambda$0(I)Lkotlin/Unit;,
(Ljava/lang/Integer;)Lkotlin/Unit;
]
INVOKESTATIC org/example/project/MainKt.foo (Lkotlin/jvm/functions/Function1;)V
RETURN


private final static bar$lambda$0(I)Lkotlin/Unit;
GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
ILOAD 0
INVOKEVIRTUAL java/io/PrintStream.println (I)V
GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit;
ARETURN</pre>



<h4 class="wp-block-heading"><code>ComposableSingleton</code> classes</h4>



<p>Compose attempts to emit every composable lambda function as a singleton, meaning there is only one instance of that lambda function in existence. Therefore, it compiles all the composable lambdas as classes with a <code>ComposableSingleton</code> prefix in their names. <strong>Before </strong>Kotlin 2.1.20, the Compose compiler traversed nested functions using depth-first search and assigned each lambda class a unique name just using a counter.&nbsp;</p>



<p>The problem, however, arises when we introduce changes to the original code:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/composable-singletons.png" alt="" class="wp-image-673369"/></figure>



<p>As you can see, just by adding a single new call to <code>Surface</code>, we caused two significant changes:</p>



<ul>
<li>Each lambda class changed, because adding a new lambda at the bottom of the tree caused all the lambda classes in the file to be renamed.</li>



<li>The class named <code>ComposableSingleton$AppKt$lambda-0</code> changed its interface from <code>Function3</code> to <code>Function2</code>, which causes an error in the JetBrains Runtime during reload, as before version 21.0.8, the JetBrains Runtime did not support changes to class interfaces.</li>
</ul>



<p>Obviously, these kinds of dramatic bytecode changes are not good when hot reloading. Therefore, we changed how the Compose compiler generates names for composable singleton lambdas. Starting from version 2.1.20, the Compose compiler uses <strong>group keys </strong>as a stable, unique name for composable lambdas:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/composable-singletons-fixed-1.png" alt="" class="wp-image-673911"/></figure>



<p>This change ensures that changes to composable lambdas do not cause errors or excessive invalidations in Compose Hot Reload.</p>



<h4 class="wp-block-heading">Indy lambdas</h4>



<p>We encountered similar problems with the names generated for indy lambdas by the Kotlin compiler: Adding a nested lambda anywhere in the code renames all other lambdas.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/Lambdas-Not-Fixed.png" alt="" class="wp-image-674551"/></figure>



<p>This issue leads to the same problems as we observed with <code>ComposableSingletons</code>. However, this issue was reinforced by the fact that it affects <strong>all</strong> lambdas in the code, and Kotlin switched to indy lambdas by default in 2.0.0.</p>



<p>To solve this problem, we have changed the Kotlin compiler. As of Kotlin 2.2.20, indices for indy lambda names are unique for each scope they appear in. This guarantees that:</p>



<ul>
<li>Random changes at the beginning of the file will not affect lambda names at the end of the file.</li>



<li>Adding nested lambdas will not affect all the other lambdas declared in the class.</li>
</ul>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/indys-fixed-1.png" alt="" class="wp-image-673944"/></figure>



<h4 class="wp-block-heading"><code>FunctionKeyMeta</code> annotations</h4>



<p>The whole functionality of Compose Hot Reload relies on the fact that we can extract information about Compose from the bytecode. However, consider this example:</p>



<pre class="EnlighterJSRAW">@Composable
fun App() {
   Button(onClick = { }) {
       Text(&quot;Click me!!!&quot;)
   }
}</pre>



<p>The lambda, passed to a <code>Button</code> call, only creates a single text field and does not create any new Compose groups. The (decompiled) bytecode of this lambda function looks like this:</p>



<pre class="EnlighterJSRAW">final class ComposableSingletons$AppKt$lambda$-794152384$1 implements Function3&lt;RowScope, Composer, Integer, Unit&gt; {


   @FunctionKeyMeta(
       key = -794152384,
       startOffset = 568,
       endOffset = 603
   )
   @Composable
   public final void invoke(RowScope $this$Button, Composer $composer, int $changed) {
       Intrinsics.checkNotNullParameter($this$Button, &quot;$this$Button&quot;);
       ComposerKt.sourceInformation($composer, &quot;C17@578L19:App.kt&quot;);
       if ($composer.shouldExecute(($changed &amp; 17) != 16, $changed &amp; 1)) {
       if (ComposerKt.isTraceInProgress()) {
           ComposerKt.traceEventStart(-794152384, $changed, -1, &quot;ComposableSingletons$AppKt.lambda$-794152384.&lt;anonymous&gt; (App.kt:17)&quot;);
       }


       TextKt.Text--4IGK_g(&quot;Click me!!!&quot;, (Modifier)null, 0L, 0L, (FontStyle)null, (FontWeight)null, (FontFamily)null, 0L, (TextDecoration)null, (TextAlign)null, 0L, 0, false, 0, 0, (Function1)null, (TextStyle)null, $composer, 6, 0, 131070);
       if (ComposerKt.isTraceInProgress()) {
           ComposerKt.traceEventEnd();
       }
   } else {
       $composer.skipToGroupEnd();
   }
   }
}</pre>



<p>As you may notice, the source code of the <code>invoke</code> function does not contain any calls to <code>startGroup</code> or <code>endGroup</code> methods, and we can‚Äôt reliably extract the group information from it. The only way to access it is to read the <code>FunctionKeyMeta</code> annotation. This is a special annotation emitted by the Compose compiler that is intended to be used by tooling.&nbsp;</p>



<p>However, before version 2.1.20, there was no way to generate <code>FunctionKeyMeta</code> annotations on composable functions, and there was no way to infer the group key from the bytecode of the compiled composable lambdas. We introduced this option in Kotlin 2.1.20 (which is why it is the required version of Kotlin if you want to use Compose Hot Reload) and enabled it by default in Kotlin 2.2.0.</p>



<h2 class="wp-block-heading">Lifting the limits of the JetBrains Runtime</h2>



<p>With the compiler tamed to emit bytecode that can be reloaded, another set of potential issues needs to be solved. One such issue surfaced very early in our testing. What should happen to the state that was statically initialized? The state in question here is not a UI state, stored by Compose, but static values, such as top-level properties. Take a look at the following test, which failed in early versions of Compose Hot Reload.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/EnumClasses.png" alt="" class="wp-image-674320" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>The test first defines an enum with the cases <code>A</code>, <code>B</code>, and <code>C</code>, then compiles and reloads the enum definition so that it also contains the case <code>D</code>. This failure is due to the <code>EnumCases.entries</code> being stored statically on the enum class. Once this collection is initialized, reloading this code will not magically cause its state to change to include the new case. Similarly, any other top-level property or static value would not change.</p>



<p>This is analogous to managing the state within the Compose framework, which means the same problems need to be solved.&nbsp;</p>



<p>We still need a way to reinitialize static values, and we need to know <strong>when</strong> to do so. This time around, we can answer the question of when to do so much more easily: Our bytecode analysis engine is perfectly capable of finding which functions and properties are considered <strong>dirty</strong>. However, reinitializing static fields is not as straightforward as calling a function. First, many static fields are also declared as final; re-assigning values cannot be done by calling a given function again, as it would require reflection. Second, the code that initializes statics lives inside a function called <code>clinit</code>. This function cannot be simply invoked, as it&#8217;s supposed to be invoked during class loading by the JVM itself. The problem requires transforming the code of <code>.class</code> files that will subsequently be reloaded. The transformation removes all final modifiers from static fields and copies the body of the <code>clinit</code> function to a new, synthetic <code>$chr$clinit</code> function (where <code>chr</code> is short for Compose Hot Reload). When reloading, the <code>clinit</code> method of several classes can be marked as dirty. We enqueue those classes for reinitialization and call them in topological order, according to their dependencies.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/Reloading-Transformed.png" alt="" class="wp-image-674331"/></figure>



<p>When this project started, one of the stated limitations of the JetBrains Runtime was that reloads were rejected if either the superclass or any of a class&#8217;s interfaces changed while the class had active instances. Since some Kotlin lambdas still compile to abstract classes that implement <code>Function1</code>, <code>Function2</code>, and other interfaces, the limitation prevented some valid user code from reloading. We were able to produce lambda class names that were unique in Compose and much more tame outside of Compose, but users could occasionally encounter this limitation. We‚Äôre happy to announce that the team working on the JetBrains Runtime, especially Vladimir Dvorak, has lifted the restriction on changing interfaces and is now working on changing superclasses as well.</p>



<h2 class="wp-block-heading">The orchestration protocol</h2>



<p>We have previously seen that different processes need to communicate with each other. There are two concepts we can deduce from the required communication:</p>



<ul>
<li>Events: Single-shot pieces of data (something that happened to which other parts of the system can react).</li>



<li>States: Current statuses of different Compose Hot Reload components that are continuously updated and available across the entire orchestration. For example, the <code>ReloadState</code> can either be <code>Ok,</code> <code>Reloading</code>, or <code>Failed</code>. This is not just a single event, but a universal state that each component can interact with. You can see that this <code>ReloadState</code> will be displayed in the application, the floating toolbar, and the IDE.&nbsp;</li>
</ul>



<p>Typically, such communication patterns can be modelled using higher-level abstractions, such as HTTP, and many would think that Ktor, or <code>kotlinx.rpc</code> might be fitting technologies. We, however, believe that technologies like Compose Hot Reload need to prioritize compatibility over our own developer experience. Using external libraries inside our devtools application is not a problem, but the communication with the user application requires code to run inside the user&#8217;s application, and polluting the user‚Äôs classpath might lead to frustrating compatibility issues. Shading such libraries can work, but most of those libraries would require <code>kotlinx.coroutines</code>. While <code>kotlinx.coroutines</code> can be shaded, it is designed to be a system-level library, and we would like to keep it this way.</p>



<p>Therefore, we opted to implement all of the server/client code without any external dependencies. To model async code accurately, we even implemented a tiny coroutines runtime that allows launching tasks, switching threads, offering a <code>Queue</code> option (analogous to a <code>Channel</code> in <code>kotlinx.coroutines</code>), and more.&nbsp;</p>



<p>The key aspect of this protocol is that it is both forward- and backwards-compatible. This bi-directional compatibility is verified by running tests in a special way, but we‚Äôll go into more detail on that later.</p>



<p>Defining a state within a single process is hard enough to get right, but defining it across multiple processes raises the question of how to implement it safely. State updates in Compose Hot Reload are defined atomically and are done through an atomic update function. This means that racing threads, even racing processes, will be able to conveniently update a given state while using a pattern that is widely adopted by application developers:</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/OrchestrationState.png" alt="" class="wp-image-674342" style="width:800px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>The provided <code>update</code> function ensures atomic updates to the state. Like an <code>AtomicReference</code> or a <code>MutableSharedFlow</code>, this update function might be called multiple times if proposed updates are rejected. To enable such atomic updates across numerous processes, the <code>OrchestrationServer</code> acts as the source of truth: Any participant trying to update the state will send binary <code>Update</code> requests to the server. These requests will contain the binary (serialized) form of the expected state and the binary form of the updated state.&nbsp;</p>



<p>The server processes all requests in a single <code>Queue</code>. If the expected binary matches, the update gets accepted, and the updated state binary is distributed to all clients. If many threads or processes are racing to update a given state value, the expected binary representation might have changed so that it no longer matches the update request. Such updates will be rejected; the client will receive the new underlying state value, call the update function again, and send a new update request.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-52.png" alt="" class="wp-image-674022"/></figure>



<h2 class="wp-block-heading">Fast visual feedback</h2>



<p>We‚Äôve now covered the internal workings of Compose Hot Reload. But as interesting as all that is, in our opinion, fast visual feedback is the most important part of the hot reload experience. So, how can we provide this feedback, and more importantly, share it across different processes? Well, the key to doing this is the states that are shared between all processes via the orchestration protocol. The <code>hot-reload-devtooling-api</code> module introduces them:</p>



<ul>
<li><code>WindowsState</code>. By hooking into the user application process and intercepting all the <code>ComposeWindow.setContent</code> invocations, we can keep track of all the windows created by the user application. Each window is assigned a unique <code>windowId</code>, and we keep information about the current position of all windows.</li>
</ul>



<pre class="EnlighterJSRAW">public class WindowsState(
   public val windows: Map&lt;WindowId, WindowState&gt;
) : OrchestrationState {
   public class WindowState(
       public val x: Int,
       public val y: Int,
       public val width: Int,
       public val height: Int,
       public val isAlwaysOnTop: Boolean
   )
}</pre>



<ul>
<li><code>ReloadState</code>. <code>ReloadState</code> keeps track of the current reload status. Basically, it tracks all orchestration messages and updates the state based on reload, recompile, or build status messages exchanged between the processes.&nbsp;</li>
</ul>



<pre class="EnlighterJSRAW">public sealed class ReloadState : OrchestrationState {
   public abstract val time: Instant


   public class Ok(
       override val time: Instant,
   ) : ReloadState()


   public class Reloading(
       override val time: Instant,
       public val reloadRequestId: OrchestrationMessageId?
   ) : ReloadState() {


   public class Failed(
       override val time: Instant,
       public val reason: String,
   ) : ReloadState()
}</pre>



<ul>
<li><code>ReloadCountState</code>. In addition to the reload state, it is also nice to keep track of the history of reload attempts. Working on the UI of your application and seeing that you have iterated on it over 30 times already is a very inspiring feeling!</li>
</ul>



<pre class="EnlighterJSRAW">public class ReloadCountState(
   	    public val successfulReloads: Int = 0,
   	    public val failedReloads: Int = 0
) : OrchestrationState</pre>



<p>As we mentioned before, all these states are shared between the processes. So if you feel like it, you can actually create your own UI tooling for Compose Hot Reload!&nbsp;</p>



<h3 class="wp-block-heading">In-app effects</h3>



<p>The Compose Hot Reload agent hooks to the user application process and intercepts Compose calls that initialize the window: <code>ComposeWindow.setContent</code> and <code>ComposeDialog.setContent</code>. To be more precise, we don‚Äôt just intercept these calls; we actually replace them with our own implementation that wraps the user content into a special <code>DevelopmentEntryPoint</code> function.</p>



<pre class="EnlighterJSRAW">@Composable
public fun DevelopmentEntryPoint(
   window: Window,
   child: @Composable () -&gt; Unit
) {
   startWindowManager(window)
   val currentHotReloadState by hotReloadState.collectAsState()


   CompositionLocalProvider(hotReloadStateLocal provides currentHotReloadState) {
       key(currentHotReloadState.key) {
           when {
               reloadEffectsEnabled -&gt; ReloadEffects(child)
               else -&gt; child()
           }
       }
   }
}</pre>



<p>This is a very high-level implementation of the <code>DevelopmentEntryPoint</code>. As you can see, it provides us with three key features:</p>



<ul>
<li>We start a window manager that updates the <code>WindowState</code> of the current window.</li>



<li>We wrap the user app&#8217;s contents in a separate scope guarded by a special hot-reload state. If we ever want to reset the user application&#8217;s UI state, we can do so by resetting the hot-reload state.</li>



<li>We wrap the user content into the <code>ReloadEffects</code> function, which renders all in-app effects based on the shared states.</li>
</ul>



<h3 class="wp-block-heading">Floating toolbar</h3>



<p>The floating toolbar, or the Compose Hot Reload <em>Dev tools</em> window, is a separate process that starts together with the user application and connects to the orchestration. Then, it just tracks the <code>WindowsState</code>, and launches a new toolbar for each window of the user application. The toolbar just tracks the target window&#8217;s state and updates its position accordingly.</p>



<p>The toolbar also contains action buttons that control the user application: <em>Reload UI</em>, <em>Reset UI</em>, and <em>Shutdown</em>. These actions are implemented via the orchestration protocol as well: Clicking a button just triggers a corresponding orchestration message to be sent to all connected processes. Each process then knows how to handle received commands.</p>



<figure class="wp-block-video"><video controls src="https://blog.jetbrains.com/wp-content/uploads/2026/01/toolbar.mov"></video></figure>



<h3 class="wp-block-heading">IDE integration</h3>



<p>IDE support for Compose Hot Reload is implemented in the <a href="https://plugins.jetbrains.com/plugin/14936-kotlin-multiplatform" target="_blank" rel="noreferrer noopener">Kotlin Multiplatform</a> plugin. When you open a Kotlin Multiplatform project in your IDE, the KMP plugin checks whether the Compose Hot Reload plugin is applied to the project. If it is, the KMP plugin also checks the versions for compatibility (IDEs support Compose Hot Reload versions from 1.0.0-beta07 onward). Via IDE integration with the build systems, the KMP plugin can extract all the information needed to run the app in hot-reload mode. And when you click on the <em>Run</em> button in the gutter next to <code>main</code>, the KMP plugin automatically generates a new run configuration with hot reload enabled.</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/runcomposeApp.png" alt="" class="wp-image-674355" style="width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>Everything else works very similarly to the <em>Dev tools</em> window. The KMP plugin connects to the orchestration server of the running application and displays information about the app&#8217;s current state: logs, reload status, errors, etc.</p>



<h2 class="wp-block-heading">Testing</h2>



<p>This project required the team to think about many components across the entire Kotlin and JetBrains technology stack, and we have spent a lot of time debugging, experimenting, and writing production code. We would like to claim that <strong>most</strong> of our time was spent on our project infrastructure. However, we estimate that roughly 30% of all our commits were purely for introducing test infrastructure, highlighting how complicated testing a system that reloads code can be.</p>



<h3 class="wp-block-heading">Hot-reload unit tests</h3>



<p>Tests running assertions within the JVM that reload code are called hot-reload unit tests. An example of such a test case was shown earlier in this blog post.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/EnumClass2.png" alt="" class="wp-image-674366"/></figure>



<p>The tests here can define <strong>code of interest</strong> right next to the actual test function. But the real magic happens when calling the <code>compileAndReload</code> method.&nbsp;</p>



<p>This method allows us to compile the provided source code within the current process and reload it. Once this <code>compileAndReload</code> method finishes, we can safely assume the new code is available and begin to write assertions. The example above shows a test that defines an enum with three cases. After reloading the enum with one case added, we can safely assert that the <code>.entries</code> property contains the newly added case. This test suite implements a custom <strong>test executor</strong> for Gradle, which launches each test case in a fresh JetBrains Runtime with hot reload enabled and provides a Kotlin compiler for the <code>compileAndReload </code>function. We used such tests in cases where reloading either crashed or had some issues, as mentioned previously (reinitializing statics).</p>



<h3 class="wp-block-heading"><code>HotReloadTestFixture</code>: Orchestration-based tests</h3>



<p>Since this project integrates into many other systems, having a heavier, end-to-end test fixture at our disposal seems natural. Similar to how Gradle plugins would write Gradle integration tests using Gradle-specific fixtures, we have implemented a <code>HotReloadTestFixture</code> that launches actual applications with Gradle in hot-reload mode and communicates with Gradle and the application using the previously mentioned orchestration protocol. Such tests were implemented to cover the integration with the JDWP commands for reloading and testing generic Gradle tasks, but they were also very useful for building screenshot tests:</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/HotReloadTest.png" alt="" class="wp-image-674377" style="width:600px; width:100% !important; height:auto !important; max-width:100% !important;"/></figure>



<p>Just as unit tests do, orchestration-based tests have a convenient way to replace code, thanks to the <code>HotReloadTestFixture</code>; however, this test fixture actually changes source code on disk and thus relies on the entire Gradle/Compose Hot Reload machinery to pick the change up correctly, issue the reload request, and perform other relevant actions, right up until Compose actually updates the UI. After that, the test then takes a screenshot. We have many tests that ensure, through screenshots, that the code change was handled properly, i.e. that only the corresponding state was reset and the UI picked up the changes.</p>



<h4 class="wp-block-heading">Testing the backwards and forwards compatibility of the orchestration protocol</h4>



<p>As we mentioned before, compatibility is one of the key properties of the orchestration protocol. For example, the IDE might have a different client version bundled compared to the server version hosted by the application.&nbsp;</p>



<p>Such compatibility tests typically define a communication flow between a server and a client. Let‚Äôs say the client connects, the server sends a message <code>Foo</code>, and the client responds with <code>Bar</code>. Now, to test the compatibility, this flow will be separated into two parts:&nbsp;<br>The first part is called <code>main</code>, which contains one side of the communication (e.g. the server‚Äôs) and runs with the currently compiled version of the code. The second part is called <code>Isolate</code>, and this code will be running in a separate process, launched with the previous JARs of the protocol.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/main-Server.png" alt="" class="wp-image-674403"/></figure>



<p>The Isolate class can be defined right next to the test function, making it easy to write compatibility test cases where both ends of the communication are close together. Still, only one will be launched in isolation, running the test against many different, previously released versions of Compose Hot Reload.</p>



<h2 class="wp-block-heading">Continuing the journey</h2>



<p>Compose Hot Reload is a very complex technical project, and we are proud of the engineering work behind it. We tried to highlight what we consider the most interesting aspects of Compose Hot Reload in this blog post. But if you are interested in learning more about the project, check out our <a href="https://github.com/JetBrains/compose-hot-reload" target="_blank" rel="noreferrer noopener">GitHub repository</a>. And don‚Äôt hesitate to create new <a href="https://github.com/JetBrains/compose-hot-reload/issues" target="_blank" rel="noreferrer noopener">issues</a> or <a href="https://github.com/JetBrains/compose-hot-reload/discussions" target="_blank" rel="noreferrer noopener">discussions</a> if you have any questions or ideas.</p>



<p>Compose Hot Reload version 1.0.0 is bundled automatically with the latest Compose Multiplatform 1.10 release. But we are continuing to work on improving both the IDE experience and the underlying technology. So check out our latest <a href="https://github.com/JetBrains/compose-hot-reload/releases" target="_blank" rel="noreferrer noopener">releases</a> and share your feedback!</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Building AI Agents in Kotlin ‚Äì Part 4: Delegation and Sub-Agents</title>
		<link>https://blog.jetbrains.com/ai/2026/01/building-ai-agents-in-kotlin-part-4-delegation-and-sub-agents/</link>
		
		<dc:creator><![CDATA[Bruno Lannoo]]></dc:creator>
		<pubDate>Tue, 13 Jan 2026 08:27:09 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/KG-social-BlogFeatured-1280x720-1.png</featuredImage>		<product ><![CDATA[kotlin]]></product>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[tutorials]]></category>
		<category><![CDATA[ai]]></category>
		<category><![CDATA[ai-agents]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=ai&#038;p=672689</guid>

					<description><![CDATA[Previously in this series: In the previous installment, we saw how to set up tracing, which brings us to two new questions: What should we experiment with based on the information this tool provides? And what parts of our agent could we improve using its observations? The first idea we had was to experiment with [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Previously in this series:</p>



<ul>
<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Building AI Agents in Kotlin ‚Äì Part 1: A Minimal Coding Agent</a></li>



<li><a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-2-a-deeper-dive-into-tools/">Building AI Agents in Kotlin ‚Äì Part 2: A Deeper Dive Into Tools</a></li>



<li><a href="https://blog.jetbrains.com/ai/2025/12/building-ai-agents-in-kotlin-part-3-under-observation/">Building AI Agents in Kotlin ‚Äì Part 3: Under Observation</a></li>
</ul>



<p>In the previous installment, we saw how to set up tracing, which brings us to two new questions: What should we experiment with based on the information this tool provides? And what parts of our agent could we improve using its observations?</p>



<p>The first idea we had was to <a href="https://github.com/JetBrains/koog/tree/develop/examples/code-agent/step-04-add-subagent" target="_blank" rel="noopener">experiment with sub-agents</a>, or more specifically, a <code>find</code> sub-agent. This will give us a chance to have a look at how Koog makes it easier to implement common patterns like sub-agents. Our hypothesis is that a <code>find</code> sub-agent might reduce overall cost while maintaining, or even improving, performance.</p>



<p>Why would we think that? Well, the main driver of cost is context growth. Each LLM request contains the full context from start to finish, which means each subsequent request is more expensive (at least in terms of input tokens) than the previous one. If we could limit context growth, especially early in the agent&#8217;s run, we might significantly reduce cost. An unnecessarily large context could also distract the agent from its core task. Therefore, by narrowing the context, we might even see a performance improvement, though that‚Äôs harder to predict.</p>



<p>The <code>find</code> functionality is particularly suited for removal from the long-term context. When searching for something, you typically open many files that don&#8217;t contain your target. Remembering those dead ends isn&#8217;t useful. Remembering what you actually found is. You could think of this as a natural way of compressing the agent&#8217;s history (we&#8217;ll look at actual compression in a later article).</p>



<p>This task is also a good candidate for a sub-agent because it&#8217;s relatively simple. That simplicity means we could also make use of the sub-agent‚Äôs ability to use a different LLM model. In this case, a faster and cheaper one. This offers flexibility that regular compression doesn&#8217;t.</p>



<p>Of course, we could have built a traditional procedural tool to do this. In fact, we did build one called <code>RegexSearchTool</code>, but for the purposes of this experiment, we put it inside the <code>find</code> agent rather than directly in the <code>main</code> agent. This approach provides us with flexibility in terms of model choice while also incorporating an extra layer of intelligence.</p>



<h2 class="wp-block-heading">The <code>find</code> agent</h2>



<p>To be able to have a sub-agent pattern, we first need a second agent. We&#8217;ve already covered agent creation in depth in <a href="https://blog.jetbrains.com/ai/2025/11/building-ai-agents-in-kotlin-part-1-a-minimal-coding-agent/">Part 1</a> of the series, so we won&#8217;t spend much time on this now. However, a few details are still worth noting.</p>



<p>First, a minor point: We&#8217;re using GPT4.1 Mini for this sub-agent because its task is much simpler and doesn&#8217;t require a model as capable as the one used by the <code>main</code> agent.</p>



<p>Second, it&#8217;s useful to look at which tools this agent can access. Like the <code>main</code> agent, it has access to the <code>ListDirectoryTool</code> and <code>ReadFileTool</code>, but not the <code>EditFileTool</code> or <code>ExecuteShellCommandTool</code>. We‚Äôve also given it access to the new procedural search tool we mentioned above, <code>RegexSearchTool</code>, which allows us to search a comprehensive range of files inside a folder and its subfolders using a regex pattern.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">ToolRegistry {
    tool(ListDirectoryTool(JVMFileSystemProvider.ReadOnly))
    tool(ReadFileTool(JVMFileSystemProvider.ReadOnly))
    tool(RegexSearchTool(JVMFileSystemProvider.ReadOnly))
}</pre>



<p>For more detailed information, check out the full implementation <a href="https://github.com/JetBrains/koog/blob/develop/examples/code-agent/step-04-add-subagent/src/main/kotlin/FindAgent.kt" target="_blank" rel="noopener">here</a>.</p>



<h2 class="wp-block-heading">Building a <code>find</code> sub-agent</h2>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-20.png" alt="" class="wp-image-673091"/></figure>



<p>First things first ‚Äì what is a sub-agent? A sub-agent is really quite simple; it is an agent that is being controlled by another agent. In this specific case, we are working with the agent-as-a-tool sub-agent pattern, where the sub-agent is running inside a tool that is provided to the <code>main</code> agent.</p>



<p>Creating a sub-agent turns out to be straightforward. We know a tool is essentially a function paired with descriptors that the agent can read to understand when and how to call it. We could simply define <a href="https://github.com/JetBrains/koog/blob/3a8b1174458fe0d5a3e02a8c60bbaaf14f6f4caf/agents/agents-core/src/commonMain/kotlin/ai/koog/agents/core/agent/AIAgentTool.kt#L79" target="_blank" rel="noopener">a tool</a> whose <a href="https://github.com/JetBrains/koog/blob/7feb6d49a45fbc8ed7cbb30f5aed67909969a8d1/agents/agents-core/src/commonMain/kotlin/ai/koog/agents/core/agent/AIAgentTool.kt#L119" target="_blank" rel="noopener"><code>.execute()</code></a> function calls our sub-agent. But Koog provides tools to remove even this boilerplate:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">fun createFindAgentTool(): Tool&lt;*, *> {
    return AIAgentService
        .fromAgent(findAgent as GraphAIAgent&lt;String, String>)
        .createAgentTool&lt;String, String>(
            agentName = "__find_in_codebase_agent__",
            agentDescription = """
                &lt;when to call your agent>
            """.trimIndent(),
            inputDescription = """
                &lt;how to call your agent>
            """.trimIndent()
        )
}</pre>



<p>You could think of this as roughly equivalent to:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">public class FindAgentTool(): Tool&lt;FindAgentTool.Args, FindAgentTool.Result>() {
   override val name: String = "__find_in_codebase_agent__"
   override val description: String = """
      &lt;when to call your agent>
   """
   @Serializable
   public data class Args(
      @property: LLMDescription(
         """
            &lt;how to call your agent>
         """
      )
      val input: String
   )
   @Serializable
   public data class Result(
	val output: String
   )
   override suspend fun execute(args: Args): Result = when {
      output = findAgent.run(args.input)
      Result(output)
   }
}</pre>



<p>In either case, the only things we need to do are:&nbsp;</p>



<ol>
<li>Create our sub-agent.</li>



<li>Give it an <code>agentName</code>.</li>



<li>Specify <strong>when</strong> to call the agent through the <code>agentDescription</code> prompt.</li>



<li>Specify <strong>how</strong> to call the agent through the <code>inputDescription</code> prompt.</li>
</ol>



<p>The prompts are, perhaps, the trickiest part. There‚Äôs plenty of room for fine-tuning. But there‚Äôs some indication that newer LLMs need less precisely tuned prompts, so perfectly fine-tuned prompts may not be worth our time. We&#8217;re still exploring this topic ourselves, and it will take more experimentation to really come to a strong conclusion.</p>



<p>One thing we did notice is that, if we&#8217;re not careful with the prompts, the <code>main</code> agent sometimes confuses the <code>find</code> agent with a simple <em>Ctrl+F </em>/<em> ‚åòF</em> function, sending only the tokens it wants to search for. That‚Äôs clearly suboptimal. With so little context, the <code>find</code> agent can‚Äôt reason about what it should actually be looking for. To address this, we include instructions requiring the main agent to specify why it&#8217;s looking for something. That way, the find agent can fully leverage its intelligence to <code>find</code> the actual thing the <code>main</code> agent is looking for.</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
This tool is powered by an intelligent micro agent that analyzes and understands code context to find specific elements in your codebase.
Unlike simple text search (Ctrl+F / ‚åòF), it intelligently interprets your query to locate classes, functions, variables, or files that best match your intent.
It requires a detailed query describing what to search for, why you need this information, and an absolute path defining the search scope.
...
"""</pre>



<figure class="wp-block-table"><table><thead><tr><th>Query WITH highlighting (not <em>Ctrl+F </em>/<em>‚åòF</em>)</th><th>Query WITHOUT highlighting (not <em>Ctrl+F </em>/<em>‚åòF</em>)</th></tr></thead><tbody><tr><td>Search for changes in <code>get_search_results</code> regarding unnecessary <code>joins</code> to see if there are comment or logic on unnecessary <code>joins</code>.</td><td><code>get_search_results</code></td></tr><tr><td>Search for environment variable usage with <code>SKLEARN_ALLOW</code> or similar in repository to find potential bypass of <code>check_build</code>.</td><td><code>SKLEARN_ALLOW</code></td></tr></tbody></table></figure>



<p>We also noticed that the <code>main</code> agent sometimes still chooses to call the shell tool with a <code>grep</code> command instead of the <code>find</code> agent, which undermines the entire purpose of having a dedicated sub-agent. To avoid this pattern, we added this section to the main system prompt in order to push it harder:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
...
You also have an intelligent find micro agent at your disposal,
which can help you find code components and other constructs more
cheaply than you can yourself. Lean on it for any and all
search operations. Do not use shell execution for find tasks.
...
"""</pre>


<aside style="background: #f8f9fa;border-left: 4px solid #007bff;padding: 1rem 1.5rem;margin: 1.5rem 0;border-radius: 4px">
<p style="margin: 0;color: #555">We also took some lessons from years of IDE development. When you search in your IDE, you don&#8217;t just get file paths and line numbers. You get snippets of the code around each match. This helps you quickly determine whether that&#8217;s actually what you were looking for without opening every file.</p>
<p>We wanted to create a similar experience for the <code>main</code> agent, which is why we prompt the <code>find</code> sub-agent to include snippets in its results:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
...
Prioritize accuracy and relevance in your search results.
* For each result, provide a clear and concise explanation of why it was selected.
* The explanation should state the specific criteria that led to its selection.
* If the match is partial or inferred, clearly state the limitations and potential inaccuracies.
* Include only relevant snippets in the results.
...</pre>
<p>This way, the <code>main</code> agent gets the same rich context we get as engineers, without needing to read through entire files just to verify it found the right thing.</p>
</aside>


<p>This is the &#8220;natural compression&#8221; we mentioned in the opening. The <code>find</code> agent opens many files, follows dead ends, and explores the codebase. But the <code>main</code> agent only sees the results: relevant file paths, snippets, and explanations. All that exploration stays in the <code>find</code> agent&#8217;s context and disappears after it returns. Only the stuff that really mattered is then added to the <code>main</code> agent&#8217;s context.</p>



<h2 class="wp-block-heading">The trade-offs</h2>



<p>Using a sub-agent has its benefits, but it also has downsides. This is certainly the kind of change that warrants experimentation to show whether it delivers the benefits we&#8217;re hoping for without too many sacrifices.</p>



<p>The first trade-off is cost and time. While shortening the context in the main thread helps bring down the cost and time there, we now also have to pay and wait for a number of LLM calls in the sub-agent. The hope is that the total cost and time spent are less, but that depends on how the <code>main</code> agent uses the sub-agent. If it ends up doing a large number of small queries, that benefit might not materialize. We will look at the costs when we run the benchmarks again in a later section, and we will just assume that cost and time are correlated.</p>



<p>We did notice this happening in some of our runs, so we added a segment to the tool‚Äôs <code>agentDescription</code> that explains the issue to the <code>main</code> agent and tries to limit the frequency of such high volumes of small queries:</p>



<pre class="EnlighterJSRAW" data-enlighter-language="kotlin" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">"""
...
While this agent is much more cost efficient at executing searches than using shell commands, it does lose context in between searches. So give preference to clustering similar searches in one call rather than doing multiple calls to this tool.
...
"""
</pre>



<p>A second trade-off is that this approach treats context retention in a far more black-and-white way than humans do. We may not pull everything that happened in the past into active memory, but we do keep vague impressions of what happened and can retrieve additional context when needed. There are ways to model this kind of behavior, but they are far beyond the scope of the current iteration of our agent and are more related to the deep and complex subject of agentic memory.</p>



<p>Another challenge is that it creates more complexity in tracing. In Langfuse, we no longer only have to look at the trace of just one agent. Indeed, we might even need to look at the behavior from multiple perspectives ‚Äì both the full view and each agent separately.</p>



<h2 class="wp-block-heading">Think wider: The engineering team analogy</h2>



<p>This technique of using sub-agents isn&#8217;t limited to simple cases like the <code>find</code> agent. You could, for example, replicate the separation of concerns in team structures by assigning analysis, implementation, testing, and planning to different sub-agents.&nbsp;</p>



<p>It&#8217;s still an open question whether an agent with all these capabilities does better or worse than a system where such capabilities are divided among sub-agents, but it&#8217;s not hard to imagine potential benefits. Think of Conway&#8217;s law: &#8220;Organizations design systems that mirror their communication structure.&#8221; One interpretation is that these communication structures evolved to discover efficient patterns worth keeping. The reverse Conway maneuver even suggests this is desirable.<br><br>Could the same be true for role distribution? Maybe the division of tasks across different specializations in software teams also evolved to discover efficient ways of working. Maybe LLMs could benefit from that, too.</p>



<p>Yet this is not guaranteed. The efficiencies might stem largely from spreading the human learning processes, and this might not apply to LLMs. But in the book <a href="https://frc3624wiki.readthedocs.io/en/latest/docs/software/advanced/read/CleanCode.html" target="_blank" rel="noopener"><em>Clean Code</em></a>, we read about wearing different hats: a writer hat (creator), a reader hat (maintainer), and a tester hat (tester). The idea is to focus on one role without being distracted by the perspectives of the others. This suggests task division goes deeper than just learning efficiency, meaning it might indeed be relevant to LLMs.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2026/01/image-8.png" alt="" class="wp-image-672692"/></figure>



<p>All of this is to say that you can take sub-agents a lot further, but whether this is a beneficial approach is still unproven. It&#8217;s still an art form for now, not a hard science.</p>



<h2 class="wp-block-heading">Benchmark results: Testing the hypothesis</h2>



<p>We&#8217;re happy to report that our version without the <code>find</code> sub-agent shows a cost of about $814, or $1.63 per instance, while our version with this sub-agent shows a cost of about $733, or $1.47 per instance. That&#8217;s a <strong>10% cost saving</strong>, which is definitely worth noting.</p>



<p>One interesting observation is how strongly the results depend on the choice of LLM for the sub-agent. In a smaller experiment, we tried keeping our sub-agent connected to GPT-5 Codex, and that dramatically increased the cost to $3.30 per example, averaged over 50 examples.</p>



<figure class="wp-block-table"><table><tbody><tr><td>Experiment</td><td>Success rate</td><td>Cost per instance</td></tr><tr><td>Part 03 (Langfuse)</td><td>56% (278/500)</td><td>$1.63 ($814/500)</td></tr><tr><td>Part 04&nbsp;(sub-agent GPT4.1 mini)</td><td>58% (290/500)</td><td>$1.47 ($733/500)&nbsp;</td></tr><tr><td>Part 04 (sub-agent GPT-5 Codex)</td><td>58% (29/50)</td><td>$3.30 ($165/50)</td></tr></tbody></table></figure>



<p>However, it is interesting to note that we hypothesized two ways to reduce cost. The first was shrinking the context size through the natural compression achieved by task handoffs, and the second was offloading work to a cheaper model. The data suggests that just splitting off a sub-agent (and keeping the GPT-5 Codex model) actually increases the cost significantly, so our first method doesn‚Äôt seem to work, while our second (cheaper models) is the one that seems to do the trick ‚Äì though this may not be rigorous proof.</p>



<p>As for performance improvements, we see a small uptick from 56% to 58%. This could be within the tolerance of statistical variance, but it&#8217;s encouraging that performance at least stayed consistent while we reduced costs.</p>



<h2 class="wp-block-heading">Conclusion</h2>



<p>We&#8217;ve seen that creating sub-agents is both simple and potentially powerful. Koog provides convenient tooling to streamline the process even further, leaving only the prompts for the agent-as-a-tool for you to define.</p>



<p>This technique clearly delivers worthwhile cost savings. We achieved nearly a<strong> 10% reduction</strong> ‚Äì a clear, measurable improvement. The performance impact is less clear, but it does look like it might be some gains there, too.</p>



<p>At the same time, these kinds of evaluations are expensive. Even with reduced costs, this benchmark still totaled $730. That‚Äôs why, in the next part, we will take a closer look at another strategy for lowering costs: a more general approach to compression. In it, we&#8217;ll answer the question, ‚ÄúHow do you prevent your context from growing indefinitely, and your costs growing with it?‚Äù</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Advent of Code 2025 in Kotlin: Puzzles, Prizes, and Community</title>
		<link>https://blog.jetbrains.com/kotlin/2026/01/advent-of-code-2025-in-kotlin/</link>
		
		<dc:creator><![CDATA[Ksenia Shneyveys]]></dc:creator>
		<pubDate>Mon, 12 Jan 2026 19:33:14 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2026/01/Featured_1280x720-2x-4.png</featuredImage>		<category><![CDATA[education]]></category>
		<category><![CDATA[news]]></category>
		<category><![CDATA[advent-of-code]]></category>
		<category><![CDATA[aoc]]></category>
		<category><![CDATA[prizes]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=673883</guid>

					<description><![CDATA[Thank you to everyone who participated in Advent of Code 2025 in Kotlin! Once again, it was a joy to see so many of you sharing solutions, cheering each other on in Slack, and keeping the holiday coding spirit alive. This year, we kicked things off with five days of livestreams on December 1‚Äì5, with [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Thank you to everyone who participated in <a href="https://adventofcode.com/2025" target="_blank" rel="noreferrer noopener">Advent of Code 2025 in Kotlin</a>! Once again, it was a joy to see so many of you sharing solutions, cheering each other on in Slack, and keeping the holiday coding spirit alive.</p>



<p>This year, we kicked things off with <a href="https://www.youtube.com/watch?v=qJIqcGXuuQs&amp;embeds_referring_euri=https%3A%2F%2Fblog.jetbrains.com%2F" target="_blank" rel="noreferrer noopener">five days of livestreams</a> on December 1‚Äì5, with Sebastian Aigner and fantastic guests solving puzzles live, discussing strategies, and showing off idiomatic Kotlin approaches.</p>



<p>If you missed the streams or want to revisit a clever trick, you can still catch up with the recordings:</p>



<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<iframe loading="lazy" title="Advent of Code 2025 in Kotlin. Day 1." src="https://www.youtube.com/embed/qJIqcGXuuQs?list=PLlFc5cFwUnmx9-VIcfxqhjHrwD3Lab4o4" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div></figure>



<h1 class="wp-block-heading">Community</h1>



<p>The Advent of Code puzzles remain available all year round, and so does the community energy. The <a href="https://slack-chats.kotlinlang.org/c/advent-of-code" target="_blank" rel="noreferrer noopener">#advent-of-code</a> channel in the Kotlinlang Slack was once again full of:</p>



<ul>
<li>Creative Kotlin snippets</li>



<li>Non-spoiler hints</li>



<li>Lots of encouragement</li>
</ul>



<p>Whether you took part in discussions every day or just lurked and learned, thank you for making the channel such a friendly, collaborative space.</p>



<p align="center"><a class="ek-link jb-download-button" title="Join the AoC channel in Slack" href="https://slack-chats.kotlinlang.org/c/advent-of-code" target="_blank" rel="noopener">Join the AoC channel in Slack</a></p>



<h1 class="wp-block-heading">Winners</h1>



<p>As in previous years, we invited you to solve Advent of Code puzzles in Kotlin, join our Kotlin leaderboards, and share your solutions on GitHub with the <code>aoc-2025-in-kotlin</code> topic for a chance to win special Kotlin prizes.</p>



<p>This year, we‚Äôre celebrating nine winners across three categories: Fastest to Solve, Random, and Community.</p>



<h2 class="wp-block-heading">Fastest to Solve</h2>



<p>These three contestants topped the combined Kotlin leaderboards, consistently solving the puzzles at impressive speed:</p>



<ul>
<li><a href="https://github.com/Kroppeb/AdventOfCodeSolutions2" target="_blank" rel="noreferrer noopener">Kroppeb</a></li>



<li><a href="https://github.com/AndrejStratmann/aoc-2025-in-kotlin" target="_blank" rel="noreferrer noopener">AndrejStratmann</a></li>



<li><a href="https://github.com/770grappenmaker/advent-of-code" target="_blank" rel="noreferrer noopener">770grappenmaker</a><br></li>
</ul>



<p>Congratulations on those lightning-fast stars and Kotlin-powered solutions!</p>



<h2 class="wp-block-heading">Random winners</h2>



<p>To give everyone a chance regardless of speed, we also randomly selected three prize winners from all the participants:</p>



<ul>
<li><a href="http://lbcp" target="_blank" rel="noreferrer noopener">lbcp</a></li>



<li><a href="https://github.com/FelixDombek/AdventOfCode" target="_blank" rel="noreferrer noopener">FelixDombek</a></li>



<li><a href="https://github.com/bjdupuis/Advent-Of-Code252" target="_blank" rel="noreferrer noopener">bjdupuis</a></li>
</ul>



<p></p>



<p>If you see your name here, keep an eye on your inbox. We‚Äôll be in touch about your prize soon.</p>



<h2 class="wp-block-heading">Community winners</h2>



<p>Finally, Advent of Code in Kotlin wouldn‚Äôt be the same without the people who answer questions, share insights and alternative solutions, help newcomers get started, and keep the #advent-of-code channel buzzing throughout December.</p>



<p>This year, we‚Äôd like to give a special shout-out to these three community stars:</p>



<ul>
<li><a href="https://github.com/jakubgwozdz/advent-of-code-2025" target="_blank" data-type="link" data-id="https://github.com/jakubgwozdz/advent-of-code-2025" rel="noreferrer noopener">jakubgwozdz</a></li>



<li><a href="https://github.com/bj0/aoc-kotlin" target="_blank" rel="noreferrer noopener">bj0</a></li>



<li><a href="https://github.com/ephemient/aoc2025" target="_blank" rel="noreferrer noopener">ephemient</a><br></li>
</ul>



<p>Thank you for your team spirit in the Kotlin community!</p>



<h1 class="wp-block-heading">Keep learning and solving</h1>



<p>Advent of Code might be over for this year, but the puzzles and the learning opportunities remain. If you‚Äôd like to keep sharpening your skills and prepare for future events, here are some resources:</p>



<ul>
<li><a href="https://www.youtube.com/playlist?list=PLlFc5cFwUnmx9-VIcfxqhjHrwD3Lab4o4" target="_blank" rel="noreferrer noopener">Advent of Code 2025 in Kotlin</a> YouTube playlist.</li>



<li><a href="https://kotlinlang.org/docs/advent-of-code.html" target="_blank" rel="noreferrer noopener">Solutions to Advent of Code puzzles</a> from previous years in idiomatic Kotlin.</li>



<li><a href="https://www.youtube.com/watch?v=nWPYGH-1hcw" target="_blank" rel="noreferrer noopener">A tutorial</a> on how to explore and solve programming puzzles using Kotlin Notebooks.</li>
</ul>



<p></p>



<p>We want to say a huge thank-you, as always, to Eric Wastl and the Advent of Code team for creating such a beloved set of puzzles year after year.</p>



<p>Let‚Äôs keep exploring Kotlin, solving algorithmic challenges, and supporting each other. We hope to see you for the next Advent of Code in Kotlin! üéÑ</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How Mobile Development Teams Use Kotlin in 2025: Insights From a Certified Trainer</title>
		<link>https://blog.jetbrains.com/kotlin/2025/12/how-mobile-development-teams-use-kotlin-in-2025/</link>
		
		<dc:creator><![CDATA[Ksenia Shneyveys]]></dc:creator>
		<pubDate>Fri, 19 Dec 2025 14:44:34 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/KT-social-BlogFeatured-1280x720-1-2.png</featuredImage>		<category><![CDATA[news]]></category>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=670271</guid>

					<description><![CDATA[This is the second guest post in a two-part series from Jos√© Luis Gonz√°lez. Jos√© Luis has a PhD in software development and is a JetBrains-certified Kotlin Trainer, who works with developers and engineering teams to deepen their Kotlin skills and apply the language effectively in real projects. At Hyperskill, he runs&#160;Kotlin instructor-led training for [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p><em>This is the second guest post in a two-part series from Jos√© Luis Gonz√°lez. Jos√© Luis has a PhD in software development and is a JetBrains-certified Kotlin Trainer, who works with developers and engineering teams to deepen their Kotlin skills and apply the language effectively in real projects. At Hyperskill, he runs&nbsp;<a href="https://bootcamps.hyperskill.org/kotlin-bootcamp-for-engineering-teams?utm_source=google&amp;utm_medium=organic&amp;utm_campaign=organic" target="_blank" rel="noreferrer noopener">Kotlin instructor-led training for teams at Hyperskill</a>&nbsp;that focus on advanced topics and practical problem-solving rather than theory.</em></p>



<p><strong>First post in the series:</strong> <a href="https://blog.jetbrains.com/kotlin/2025/12/how-backend-development-teams-use-kotlin-in-2025/">How Backend Development Teams Use Kotlin in 2025: Insights from a Certified Trainer</a></p>



<p>I‚Äôd probably have to say swallowing <code>CancellationException</code> in general <code>catch</code> blocks (including <code>runCatching</code>). It looks harmless, but it disables cooperative cancellation, so timeouts, parent scopes, and lifecycles keep running ‚Äúmysteriously.‚Äù In recent talks, linters, and guides, you still see this called out as a real-world production bug. Official docs stress that cancellation must propagate, detekt ships a rule warning if you don‚Äôt rethrow, and the coroutines library provides mechanisms that avoid catching <code>CancellationException</code> in generic catch-alls.</p>



<p>Use the following pattern instead to always rethrow cancellations (or choose a helper that preserves them):</p>



<pre class="EnlighterJSRAW">suspend fun &lt;T&gt; safeCall(block: suspend () -&gt; T, fallback: () -&gt; T): T = try {
    block()
} catch (e: CancellationException) {
    throw e // never swallow cancellation
}
// catch other specific exceptions
} catch (e: Exception) {
    logger.error(&quot;call failed&quot;, e)
    fallback()
}</pre>



<p>If you like Result-style API, mirror the <code>kotlinx</code> approach as follows:</p>



<pre class="EnlighterJSRAW">suspend inline fun &lt;T&gt; runSuspendCatching(block: () -&gt; T): Result&lt;T&gt; =
    try { Result.success(block()) }
    catch (e: CancellationException) { throw e }
    catch (e: Throwable) { Result.failure(e) }</pre>



<p>This tiny rethrow keeps structured concurrency intact and matches the guidance you‚Äôll hear in the latest coroutine discussions.</p>



<p><strong>2. If a team has only two hours to set up monitoring for their mobile Kotlin app, which specific dashboards should they prioritize?</strong></p>



<p>Begin with metrics that indicate whether users can successfully use the app. Crash-free users and ANR rate by version and device model tell you whether a release is safe to ship.</p>



<p>Firebase Crashlytics handles this out of the box ‚Äì just tag builds for quick filtering:</p>



<pre class="EnlighterJSRAW">FirebaseCrashlytics.getInstance().setCustomKeys {
    key(&quot;version&quot;, BuildConfig.VERSION_NAME)
    key(&quot;commit&quot;, BuildConfig.GIT_SHA)
}</pre>



<p>As for UI issues, use JankStats to log when and where frames drop, so you know which screens stutter:</p>



<pre class="EnlighterJSRAW">val jankStats = JankStats.create(window) { frame -&gt;
    if (frame.isJank) Log.d(&quot;Jank&quot;,
        &quot;Jank on ${currentScreen()} ‚Äì ${(frame.frameDurationUiNanos / 1_000_000)}ms&quot;)
}
jankStats.isTrackingEnabled = true</pre>



<p>Another main concern is performance, of course. With Sentry, you get end-to-end insights into what is actually slowing down your app: startup, navigation, network calls, etc. It correlates frontend and backend timing so you can spot bottlenecks and regressions fast.</p>



<p>Here is a standard setup with tracing and profiling:</p>



<pre class="EnlighterJSRAW">SentryAndroid.init(this) { options -&gt;
    options.dsn = &quot;&lt;dsn&gt;&quot;
    options.tracesSampleRate = 0.1
    options.profilesSampleRate = 0.05
    options.release = &quot;${BuildConfig.VERSION_NAME} (${BuildConfig.VERSION_CODE})&quot;
    options.environment = BuildConfig.BUILD_TYPE
}</pre>



<p>Now, let‚Äôs add some custom transactions for key flows:</p>



<pre class="EnlighterJSRAW">val tx = Sentry.startTransaction(&quot;screen:${currentScreen()}&quot;, &quot;ui.load&quot;)
Sentry.configureScope { it.setTransaction(tx) }

val net = tx.startChild(&quot;http.client&quot;, &quot;GET /api/items&quot;)
try { /* network call */ } finally { net.finish() }

val db = tx.startChild(&quot;db.query&quot;, &quot;SELECT items&quot;)
try { /* read */ } finally { db.finish() }

tx.finish()</pre>



<p>And auto-tracing for network calls (<code>OkHttp</code> and <code>Ktor</code>):</p>



<p>OkHttp:</p>



<pre class="EnlighterJSRAW">val client = OkHttpClient.Builder()
    .addInterceptor(SentryOkHttpInterceptor())
    .build()</pre>



<p>Ktor:</p>



<pre class="EnlighterJSRAW">val client = HttpClient(CIO) {
    install(Sentry) {
        tracesSampleRate = 0.1
        profilesSampleRate = 0.05
    }
}</pre>



<p>Sentry Mobile Insights provides a prebuilt dashboard for this. It groups slow transactions and crash-free rate by release and device model, so you can see exactly where users struggle the most without the need for a custom setup.</p>



<p>Here‚Äôs how a real trace looks in <code>Sentry</code>: You can see a cold start (<code>app.start.cold</code>), API calls, and rendering time, all visualized in one timeline, for a detailed breakdown of how much time the app spends on various tasks.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobile.png" alt="" class="wp-image-670286"/></figure>



<p>Check these dashboards in <code>Sentry</code>:</p>



<ul>
<li><strong>Performance / Transactions</strong>: p95 duration for <code>app.start.cold</code>, <code>ui.load</code>, and <code>checkout</code>.</li>



<li><strong>Traces / Slow spans</strong> to find lags in HTTP, database, or main-thread work.</li>



<li><strong>Releases / Crash-free and ANR</strong>: Correlate stability with performance.</li>
</ul>



<p><code>Sentry</code> (or <code>Crashlytics</code>) combined with <code>JankStats</code> will give you the full picture. Can users open the app, interact smoothly, and exit without crashes or leaks? <code>Sentry</code> covers both performance and crash tracking, so you can often use it alone, while <code>Crashlytics</code> remains a lightweight alternative many teams already have in place.</p>



<p><strong>3. When a mobile Kotlin application is running slowly in production, what are your top three profiling techniques, and what tools do you use for each?</strong></p>



<p>I wouldn‚Äôt say there‚Äôs anything groundbreaking here. I usually start with the same baseline we talked about earlier: <code>Crashlytics</code>, <code>JankStats</code>, and <code>Sentry</code> traces. They will provide a comprehensive overview of what‚Äôs going on. From there, my top three profiling techniques are pretty straightforward but extremely effective.</p>



<p>Honestly, the standalone <code>Android Studio</code> profiler is still the most powerful and underrated tool out there. I spend most of my time in its CPU and memory profilers, checking which methods block the main thread or which allocations spike during transitions. I always check the <code>Sample Call Stack</code> view, as it‚Äôs the fastest way to see where time is actually spent per frame, instead of guessing from logs.</p>



<p>It sounds basic, but it often reveals that a single <code>RecyclerView</code> binding or JSON parser allocates thousands of tiny objects per frame.</p>



<p>Also, I would typically do network profiling. Using the Network Inspector or Sentry‚Äôs tracing, I check which requests block rendering or input. If scrolling freezes when images load, you can immediately tell whether it‚Äôs an uncompressed call or a missing cache layer without guessing. If you‚Äôve already enabled Sentry Performance in the <em>Monitoring </em>section of the settings menu, it doubles as lightweight production profiling. You can literally see slow transactions by endpoint.</p>



<p>Frame-time profiling is something that comes in handy as well. I like using <code>JankStats</code> or even <code>adb shell dumpsys gfxinfo</code> to see which screens consistently drop frames. Then I pair that with <code>LeakCanary</code> to catch activities or bitmaps that stay alive longer than they should. Together, that tells me exactly what‚Äôs slowing the UI down.</p>



<p>In short, you don‚Äôt really need fancy tools. CPU, memory, network, and frame-time profiling, all within Android Studio, cover about 90% of the real issues. These profiling tools help identify what&#8217;s making the app feel slow, so you can easily fix the underlying problems.&nbsp;</p>



<p><strong>4. When teams ask about Kotlin Multiplatform, what&#8217;s the smallest project they should start with to prove the concept?</strong></p>



<p>I usually remind teams that they‚Äôre probably using <code>Kotlin Multiplatform</code> already. Libraries like <code>kotlinx.coroutines</code> or <code>kotlinx.serialization</code> are basically multiplatform under the hood. You‚Äôre just using them from Android today, but they work the same on iOS, too.</p>



<p>The smallest realistic project to actually prove Kotlin Multiplatform in your environment is a shared data or utility layer ‚Äì something both applications can call without touching the UI. A great first step is to share one simple function, like returning the current time or a version string:</p>



<pre class="EnlighterJSRAW">// commonMain
expect fun currentTime(): Long

// androidMain / iosMain
actual fun currentTime() = System.currentTimeMillis() // or NSDate().timeIntervalSince1970</pre>



<p>Here‚Äôs how to connect the Kotlin framework generated from the <code>Kotlin Multiplatform</code> project to your Xcode project:</p>



<p>The <code>embedAndSignAppleFrameworkForXcode</code> task only registers if the <code>binaries.framework</code> configuration option is declared. In your Kotlin Multiplatform project, check the iOS target declaration in the <code>build.gradle.kts</code> file.</p>



<pre class="EnlighterJSRAW">kotlin {
    ios() // or iosArm64(), iosX64(), iosSimulatorArm64()
    binaries {
        framework {
            baseName = &quot;Shared&quot;
        }
    }
}</pre>



<p>To automatically build a shared module in <code>Xcode</code>, you need to add a script. In the <strong>Build Phases</strong> tab, add a run script with the following code:</p>



<pre class="EnlighterJSRAW">cd &quot;$SRCROOT/..&quot;
./gradlew :shared:embedAndSignAppleFrameworkForXcode</pre>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobile1.jpg" alt="" class="wp-image-670297"/></figure>



<p>Using the specified script, access the Gradle task to create and embed the library into the native iOS application.</p>



<p>Then you should move the <strong>Run Script</strong> phase higher, placing it before the <strong>Compile Sources</strong> phase.</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobil2.jpg" alt="" class="wp-image-670308"/></figure>



<p>After running the build on the iOS app side or <code>iosApp</code> configuration from the Kotlin Multiplatform project, the compiled <code>xcode-frameworks</code> will appear in the build folder of the shared module.</p>



<p>This will generate the framework at:</p>



<figure class="wp-block-image size-full"><img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/mobile3.jpg" alt="" class="wp-image-670319"/></figure>



<p>Then import it into Swift:</p>



<pre class="EnlighterJSRAW">import Shared

let t = currentTime() // works directly from the shared Kotlin code</pre>



<p>If that builds and runs cleanly, you‚Äôve already proven that Kotlin code can compile and interop on both sides. From there, you can expand to something slightly more useful. For example, a shared module that fetches and parses a list of items using <code>Ktor</code> and <code>kotlinx.serialization</code>.</p>


    <div class="about-author ">
        <div class="about-author__box">
            <div class="row">
                                                            <div class="about-author__box-img">
                            <img style="width:100% !important; height:auto !important; max-width:100% !important;" decoding="async" src="https://blog.jetbrains.com/wp-content/uploads/2025/12/1604594047817.jpeg" alt="Jos√© Luis Gonz√°lez" loading="lazy">
                        </div>
                                        <div class="about-author__box-text">
                                                    <h4>Jos√© Luis Gonz√°lez</h4>
                                                <p><span style="font-weight: 400;">Jos√© Luis Gonz√°lez, PhD, is a JetBrains-certified Kotlin Trainer who teaches Kotlin and advanced techniques to development teams. If your team has more questions about Kotlin anti-patterns, idiomatic design, or wants to learn how to write more maintainable Kotlin code, explore his </span><a href="https://bootcamps.hyperskill.org/kotlin-bootcamp-for-engineering-teams" target="_blank" rel="noopener"><span style="font-weight: 400;">instructor-led Kotlin workshops</span></a><span style="font-weight: 400;"> at Hyperskill.</span></p>
                    </div>
                            </div>
        </div>
    </div>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>The Ultimate Guide to Successfully Adopting Kotlin in a Java-Dominated Environment</title>
		<link>https://blog.jetbrains.com/kotlin/2025/12/the-ultimate-guide-to-successfully-adopting-kotlin-in-a-java-dominated-environment/</link>
		
		<dc:creator><![CDATA[Alyona Chernyaeva]]></dc:creator>
		<pubDate>Thu, 18 Dec 2025 15:04:44 +0000</pubDate>
		<featuredImage>https://blog.jetbrains.com/wp-content/uploads/2025/12/Blog-Featured-1280x720-1-5.png</featuredImage>		<product ><![CDATA[idea]]></product>
		<guid isPermaLink="false">https://blog.jetbrains.com/?post_type=kotlin&#038;p=669909</guid>

					<description><![CDATA[Adopting Kotlin in a Java-centric company&#160; is not about flipping a switch or rewriting everything ‚Äúthe right way‚Äù. It‚Äôs about people, timing, risk, and trust. Over the last four weeks, we‚Äôve published a series of blog posts by Urs Peter, covering all of these aspects of migrating to Kotlin. In this post, we‚Äôll tie the [&#8230;]]]></description>
										<content:encoded><![CDATA[
<p>Adopting Kotlin in a Java-centric company&nbsp; is not about flipping a switch or rewriting everything ‚Äúthe right way‚Äù. It‚Äôs about people, timing, risk, and trust.</p>



<p>Over the last four weeks, we‚Äôve published a series of blog posts by <a href="https://www.linkedin.com/in/urs-peter-70a2882/?originalSubdomain=nl" data-type="link" data-id="https://www.linkedin.com/in/urs-peter-70a2882/?originalSubdomain=nl" target="_blank" rel="noreferrer noopener">Urs Peter</a>, covering all of these aspects of migrating to Kotlin. In this post, we‚Äôll tie the series together and give you one file you can hand to any engineer, tech lead, or manager to help them make the change.</p>



<div class="wp-block-file"><object class="wp-block-file__embed" data="https://blog.jetbrains.com/wp-content/uploads/2025/12/Kotlin-Adoption-Journey.pdf" type="application/pdf" style="width:100%;height:600px" aria-label="Embed of Kotlin Adoption Guide."></object><a id="wp-block-file--media-f1b063f5-cf8d-4fe4-ad98-1a828177863d" href="https://blog.jetbrains.com/wp-content/uploads/2025/12/Kotlin-Adoption-Journey.pdf">Kotlin Adoption Guide</a><a href="https://blog.jetbrains.com/wp-content/uploads/2025/12/Kotlin-Adoption-Journey.pdf" class="wp-block-file__button wp-element-button" aria-describedby="wp-block-file--media-f1b063f5-cf8d-4fe4-ad98-1a828177863d" download>Download</a></div>



<p>Use this post as a map, and when you spot a topic that resonates, check out the PDF for detailed instructions, side‚Äëby‚Äëside code examples, and concrete migration patterns.</p>



<h2 class="wp-block-heading">The journey in five parts</h2>



<p>Kotlin adoption starts with a spark: one or two engineers who feel that Kotlin could make their code a bit clearer, safer, or easier to work with in the long run.</p>



<p>The guide walks you through a five-stage process to make this happen.</p>



<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/10/getting-started-with-kotlin-for-java-developers/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/10/getting-started-with-kotlin-for-java-developers/" rel="noreferrer noopener">&nbsp;Part 1: Getting Started With Kotlin for Java Developers</a></h3>



<p>We‚Äôre starting small. And for good reason: You want to introduce Kotlin in a way that can‚Äôt possibly hurt production ‚Äì by using your test suite.</p>



<p>This part shows you how to:</p>



<ul>
<li>Wire Kotlin into an existing Java project.</li>



<li>Use tools like Kotest and MockK.</li>



<li>Use Kotlin‚Äôs null safety and collections in code you run every day.</li>
</ul>



<p>The goal here is not to become an expert, but to answer a simple question: ‚ÄúDoes working with this language feel better?‚Äù</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/10/getting-started-with-kotlin-for-java-developers/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/10/evaluating-kotlin-in-real-projects/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/10/evaluating-kotlin-in-real-projects/" rel="noreferrer noopener">Part 2: Evaluating Kotlin in Real Projects&nbsp;</a></h3>



<p>Once tests feel comfortable, you‚Äôll inevitably start asking yourself, ‚ÄúCan we trust this in production?‚Äù</p>



<p>Part 2 explores two paths:</p>



<ul>
<li>Starting a new service in Kotlin (often with Spring Boot).</li>



<li>Adding Kotlin modules to an existing Java system.</li>
</ul>



<p>You‚Äôll see how to avoid the ‚ÄúJava in Kotlin syntax‚Äù trap, teaching you how to use extension functions instead of static helpers, nullable types instead of Optional, and data classes and immutability instead of boilerplate models and builders.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/10/evaluating-kotlin-in-real-projects/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/11/growing-kotlin-adoption-in-your-company-2/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/11/growing-kotlin-adoption-in-your-company-2/" rel="noreferrer noopener">Part 3: Growing Kotlin Adoption in Your Company&nbsp;</a></h3>



<p>Part 3 looks at the human side: how to get your colleagues on board with Kotlin by piquing their interest rather than pushing it on them.</p>



<p>This part will give you practical ways to:</p>



<ul>
<li>Provide small, focused examples of Java and Kotlin that respect people‚Äôs existing code.</li>



<li>Share a starter repository with Kotlin, linting, tests, and CI already set up.</li>



<li>Hold short clinics, pairing sessions, and chats to give your colleagues a chance to ask you questions.</li>



<li>Build an in‚Äëhouse Kotlin community that doesn‚Äôt depend on a single proponent.</li>
</ul>



<p>The aim is simple: make it easy for others to say, ‚ÄúLet me try this on my next task.‚Äù</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/11/growing-kotlin-adoption-in-your-company-2/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/11/helping-decision-makers-say-yes-to-kotlin/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/11/helping-decision-makers-say-yes-to-kotlin/" rel="noreferrer noopener">Part 4: Helping Decision‚ÄëMakers Say Yes to Kotlin&nbsp;</a></h3>



<p>Persuading your tech-savvy employees is one thing ‚Äì but what about your colleagues who ask, ‚ÄúHow does Kotlin benefit us as a business?‚Äù</p>



<p>Part 4 helps you explain the benefits of Kotlin in terms of business value:</p>



<ul>
<li>Less code to read and maintain.</li>



<li>Fewer defects thanks to null safety and safer defaults.</li>



<li>No re-writing required, as Kotlin has full Java interop and existing frameworks still work.</li>



<li>Developer happiness and hiring ‚Äì people want to work with thoughtful, cutting-edge tools.</li>



<li>Predictable costs for training, gradual migration, and knowledge‚Äësharing.<br></li>
</ul>



<p>This part is written to help you have honest conversations with managers and architects who are accountable for risk, not just syntax.</p>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/11/helping-decision-makers-say-yes-to-kotlin/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h3 class="wp-block-heading"><a href="https://blog.jetbrains.com/kotlin/2025/11/scaling-kotlin-adoption-across-your-organization/" target="_blank" data-type="link" data-id="https://blog.jetbrains.com/kotlin/2025/11/scaling-kotlin-adoption-across-your-organization/" rel="noreferrer noopener">Part 5: Scaling Kotlin Adoption Across Your Organization</a></h3>



<p>Okay ‚Äì let‚Äôs say you‚Äôve managed to bring managers on board and teams are enjoying coding in Kotlin. Now to address the final question: ‚ÄúWe have a lot of Java. How do we migrate without breaking things or burning people out?‚Äù</p>



<p>Part 5 focuses on strategy at scale. It suggests:</p>



<ul>
<li>Treating systems differently based on lifecycle:
<ul>
<li>Leave end‚Äëof‚Äëlife apps as they are.</li>



<li>Default new builds to Kotlin.</li>



<li>Migrate active systems step by step, not as big‚Äëbang rewrites.</li>
</ul>
</li>



<li>Using the right tools for the job:
<ul>
<li>IDE conversion.</li>



<li>Null‚Äësafety annotations like JSpecify‚Äôs.</li>



<li>AI‚Äëassisted refactoring where tests are strong.</li>



<li>Rule‚Äëbased automation for large codebases.</li>
</ul>
</li>



<li>Capturing everything in a Kotlin ‚Äúhouse playbook‚Äù so teams don‚Äôt have to re-learn it all from scratch.</li>
</ul>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://blog.jetbrains.com/kotlin/2025/11/scaling-kotlin-adoption-across-your-organization/" class="btn" target="_blank">Learn More</a>
                                                    </div>
    </div>







<h2 class="wp-block-heading">Who this guide is for</h2>



<p>The guide is written for people who currently work in Java codebases and care about moving them forward responsibly:</p>



<ul>
<li>Java developers who want safer, more expressive tools without throwing away their experience.</li>



<li>Backend and platform engineers running Spring Boot or similar stacks who need a clear, low‚Äërisk path.</li>



<li>Tech leads and architects who are responsible for consistency across many services and teams.</li>



<li>Engineering managers and decision‚Äëmakers who need a transparent view of costs, benefits, and risks.</li>
</ul>



<h2 class="wp-block-heading">Download the complete series as a PDF</h2>



<p>The PDF version brings everything together:</p>



<ul>
<li>All five parts of the journey.</li>



<li>Side‚Äëby‚Äëside Java and Kotlin examples.</li>



<li>Migration patterns, pitfalls to avoid, and success factors at scale.</li>
</ul>


    <div class="buttons">
        <div class="buttons__row">
                                                <a href="https://drive.google.com/file/d/108gx4qiU501_5p9rNZVfsZ5TGqC5zV4q/view?usp=sharing" class="btn" target="_blank" rel="noopener">Download the Kotlin Adoption Guide (PDF)</a>
                                                    </div>
    </div>







<p>Take a look and let us know what you think in the comments. We can&#8217;t wait to hear about how you use it.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
