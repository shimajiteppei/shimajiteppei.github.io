<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-10-31T14:51:19+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Value Classes Heap Flattening - What to expect from JEP 401 #JVMLS</title><link href="https://inside.java/2025/10/31/jvmls-jep-401/" rel="alternate" type="text/html" title="Value Classes Heap Flattening - What to expect from JEP 401 #JVMLS" /><published>2025-10-31T00:00:00+00:00</published><updated>2025-10-31T00:00:00+00:00</updated><id>https://inside.java/2025/10/31/JVMLS-JEP-401</id><content type="html" xml:base="https://inside.java/2025/10/31/jvmls-jep-401/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/NF4CpL_EWFI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>The initial flattening in Project Valhalla relied on four property value types had at the time: lack of identity, immutability, null-freeness, and non-atomicity.</em> 
<em>As our understanding of value types improved, we realized that null-freeness was not a property inherently part of value types, and that non-atomicity was too challenging to include in the Java language for a first release. So, <a href="https://openjdk.org/jeps/401">JEP 401</a> defines value class instances as identity-less and (mostly) immutable. The value class model has also been relaxed, allowing field inheritance through abstract value classes. All these modifications, combined with the constraints of the Java Memory Model and the limitations of current hardware, created new challenges for the JVM to be able to flatten values. New flattening schemes had to be developed and are presented in the talk.</em></p>

<p><em>As the Valhalla team explored new flattening solutions, it became obvious that flattening is a multi-faceted problem. Flattening is beneficial to memory density: by removing object headers and the indirection pointer, Java heap space is used more efficiently. The spatial locality of the value and its container can lead to better cache efficiency, but a flat value can also have a higher access cost than a non-flat value, especially if properties such as nullability and atomicity must be guaranteed. Memory density can also be improved by using clever encodings to make the most of every bit of the flat representation. However, complex encodings usually have a higher access cost and have a significant impact on the code complexity in the JVM. The talk will explain the different trade-offs JVM engineers had to make when implementing the flattening policies.</em></p>

<p><em>With an improved prototype, benchmarks helped us understand the kinds of improvements flattening can provide, and which scenarios can be negatively impacted. Flat arrays accessed by C2 compiled code were, and remain, the ideal scenario for achieving a significant boost in application raw performance. Field flattening initially performed poorly in comparison until its impact on GC workload was measured. Finally, if C2 is able to exploit flat values to their maximum, other VM components like the interpreter, the runtime, or even C1 have a much harder time handling flat values, possibly leading to performance regressions—an aspect to consider when maintaining good startup times.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;FredericParain&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[Project Valhalla's approach to flattening value types has evolved significantly, driven by a deeper understanding of value type semantics, challenges in the Java language and the JVM.]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API</title><link href="https://inside.java/2025/10/30/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 26: HTTP/3 Support Available in HTTP Client API" /><published>2025-10-30T00:00:00+00:00</published><updated>2025-10-30T00:00:00+00:00</updated><id>https://inside.java/2025/10/30/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/10/30/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of the <a href="https://mail.openjdk.org/pipermail/quality-discuss/">quality outreach</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="http3-support-in-httpclient">HTTP/3 Support in HttpClient</h2>

<p>The <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> API allows Java applications to create reusable HTTP client instances, build HTTP requests, and handle responses synchronously or asynchronously. 
Since JDK 11, you can set the preferred HTTP protocol versions like HTTP/1.1 or HTTP/2 at the <code class="language-plaintext highlighter-rouge">HttpClient</code> or <code class="language-plaintext highlighter-rouge">HttpRequest</code> level.</p>

<p><a href="https://openjdk.org/jeps/517">JEP 517</a> introduces support for HTTP/3 (<code class="language-plaintext highlighter-rouge">HttpClient.Version.HTTP_3</code>) in JDK 26, enabling applications to prefer or enforce HTTP/3 for requests.
While HTTP/3 offers similar features to HTTP/2 at the protocol level, its key difference is that it runs over the QUIC protocol using UDP, whereas HTTP/2 operates over TCP.
Below is a code snippet on how you can prefer and/or enforce HTTP/3:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// prefer HTTP/3</span>
<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_3</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// if target server support HTTP/3, add this to enforce it</span>
<span class="nc">HttpRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.google.com/"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">setOption</span><span class="o">(</span><span class="nc">HttpOption</span><span class="o">.</span><span class="na">H3_DISCOVERY</span><span class="o">,</span> <span class="nc">Http3DiscoveryMode</span><span class="o">.</span><span class="na">HTTP_3_URI_ONLY</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="nc">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status code: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()</span> <span class="o">+</span> <span class="s">" HTTP protocol version: "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>
</code></pre></div></div>

<p>If you set HTTP/3 but it is not available, the client will automatically downgrade to HTTP/2 or HTTP/1.1.
If you configure to strictly require HTTP/3, a failed attempt leads to an exception rather than a downgrade.</p>

<p>However, setting HTTP/3 as the preferred version does not guarantee its use, as the client cannot know beforehand if the server supports it. 
For the first request to a server, the client tries both TCP (HTTP/2) and UDP (HTTP/3) connections and uses whichever succeeds first. 
Over time, the <code class="language-plaintext highlighter-rouge">HttpClient</code> can “learn” about the HTTP version(s) that a server supports by using the “Alt-Svc” mechanism (the “HTTP Alternative Services” standard per <a href="https://datatracker.ietf.org/doc/html/rfc7838">RFC 7838</a>). 
Servers supporting “Alt-Svc” advertise alternative supported protocols such as HTTP/3. This allows subsequent requests to that server to use HTTP/3 when supported. For more details on this mechanism, see <a href="https://inside.java/2025/10/22/http3-support/">this article</a>.</p>

<h2 id="call-to-action">Call to Action</h2>

<p>Although the enhancements to the HTTP Client API appear simple to use, supporting HTTP/3 on top of QUIC represents the result of several years of dedicated development effort within the JDK team.
As this implementation is still new, we encourage you to download the <a href="https://jdk.java.net/26/">Java 26 Early Access builds</a>, try this feature, and share your feedback through the <a href="https://mail.openjdk.org/mailman/listinfo/net-dev">net-dev OpenJDK mailing list</a> (registration required).</p>

<center>~</center>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 26" /><category term="Networking" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers the HTTP/3 support in JDK 26.]]></summary></entry><entry><title type="html">AI World: Georges Saab Unveils Java 25 for AI and Cloud</title><link href="https://inside.java/2025/10/29/aiworld-java-for-ai/" rel="alternate" type="text/html" title="AI World: Georges Saab Unveils Java 25 for AI and Cloud" /><published>2025-10-29T00:00:00+00:00</published><updated>2025-10-29T00:00:00+00:00</updated><id>https://inside.java/2025/10/29/AIWorld-java-for-ai</id><content type="html" xml:base="https://inside.java/2025/10/29/aiworld-java-for-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/a1aro8bq30o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.</em></p>

<p><em>Java is trusted by millions of developers worldwide and remains the backbone of enterprise systems and emerging AI-powered workloads. In this special segment from Oracle TV at Oracle AI World 2025, Georges Saab, Senior Vice President of Development of the Java Platform, highlights the latest features in Java 25 and their impact on developers, IT leaders, and businesses at scale.</em></p>

<p><em>Georges explains the major innovations in Java 25, Oracle’s approach to evolving and supporting the Java language, platform, and ecosystem, and the important role of GraalVM’s alternative runtime. Learn how the Java 25 long-term support (LTS) release enables organizations to modernize legacy applications and embrace cloud-first and multi-cloud strategies. Discover how new features in Java 25 make it easier to build, deploy, and run AI-driven and cloud-native solutions—driving agility and business value. Georges also provides a preview of what’s coming in Java 26, reinforcing Java’s ongoing six-month release cadence and its future in the enterprise and beyond.</em></p>]]></content><author><name>[&quot;GeorgesSaab&quot;]</name></author><category term="AI" /><category term="Cloud" /><category term="Oracle" /><summary type="html"><![CDATA[Explore how Java 25 accelerates AI, enterprise modernization, and cloud-native development. Watch this Oracle TV segment from Oracle AI World 2025 for expert insights into the platform’s newest innovations.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 504: Remove the Applet API</title><link href="https://inside.java/2025/10/28/jep504-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 504: Remove the Applet API" /><published>2025-10-28T00:00:00+00:00</published><updated>2025-10-28T00:00:00+00:00</updated><id>https://inside.java/2025/10/28/JEP504-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/10/28/jep504-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 504: Remove the Applet API</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?428039928" /></p>]]></content><author><name>[&quot;PhilRace&quot;]</name></author><category term="JDK 26" /><category term="Client" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 504: Remove the Applet API]]></summary></entry><entry><title type="html">Episode 41 “From Cowboy Mode to Careful Stewardship” with Mark Reinhold</title><link href="https://inside.java/2025/10/27/podcast-041/" rel="alternate" type="text/html" title="Episode 41 “From Cowboy Mode to Careful Stewardship” with Mark Reinhold" /><published>2025-10-27T01:00:00+00:00</published><updated>2025-10-27T01:00:00+00:00</updated><id>https://inside.java/2025/10/27/Podcast-041</id><content type="html" xml:base="https://inside.java/2025/10/27/podcast-041/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/ChadMic.jpg?423865323" /></p>

<p><br /></p>
<iframe title="Libsyn Player" style="border: none" src="//html5-player.libsyn.com/embed/episode/id/38766750/height/90/theme/custom/thumbnail/yes/direction/forward/render-playlist/no/custom-color/000000/" height="90" width="100%" scrolling="no"></iframe>

<div class="youtube-embed">
<iframe src="https://www.youtube.com/embed/ny4CqBX_kaQ?si=YMIp5TbKvjRQaCy" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</div>

<p><br /></p>

<p>Java is a 30-year success story, made possible because its development consistently aligned with users’ needs. In its early days, the platform required new features quickly, but over time, minimizing code breakage while carefully evolving the platform became essential. Critical junctures along that path included the introduction of modules and the current strive toward integrity by default.</p>

<p>Nicolai Parlog talks to Mark Reinhold, Chief Architect of the Java Platform, who brings nearly three decades of experience shaping Java’s evolution.</p>

<p><br />
Make sure to also check the <strong>Duke’s Corner podcast</strong> on <a href="https://dev.java/duke/corner/">dev.java</a>.</p>

<p><br /></p>

<h3 id="additional-resources">Additional resources</h3>
<ul>
  <li><a href="https://inside.java">Inside.java</a> : News and views from members of the Java team at Oracle</li>
  <li><a href="https://dev.java">Dev.java</a> : The Destination for Java Developers</li>
  <li><a href="https://openjdk.java.net/">OpenJDK</a></li>
  <li><a href="https://www.oracle.com/java/">Oracle Java</a></li>
</ul>

<p>For more episodes, check out <a href="https://inside.java/podcast">Inside Java</a>, our <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzV_hXbRevwzrXSMcGNzhxiZ">YouTube playlist</a>, and follow <a href="https://twitter.com/java">@Java</a> on Twitter.</p>

<p>Contact us <a href="https://inside.java/about/">here</a>.</p>]]></content><author><name>[&quot;MarkReinhold&quot;, &quot;NicolaiParlog&quot;]</name></author><summary type="html"><![CDATA[Nicolai Parlog talks to Mark Reinhold, Chief Architect of the Java Platform, who has almost 30 years of experience driving Java forward...]]></summary></entry><entry><title type="html">Try Out JEP 401 Value Classes and Objects</title><link href="https://inside.java/2025/10/27/try-jep-401-value-classes/" rel="alternate" type="text/html" title="Try Out JEP 401 Value Classes and Objects" /><published>2025-10-27T00:00:00+00:00</published><updated>2025-10-27T00:00:00+00:00</updated><id>https://inside.java/2025/10/27/try-jep-401-value-classes</id><content type="html" xml:base="https://inside.java/2025/10/27/try-jep-401-value-classes/"><![CDATA[<p>The Valhalla team recently published an early-access JDK build that fully implements <a href="https://openjdk.org/jeps/401">JEP 401: Value Classes and Objects (Preview)</a>.
There’s still a lot of work to do to get this code into a future release of the JDK.
Until then, now is a great time for anyone who is interested to try out this transformative new feature!</p>

<h2 id="getting-the-early-access-builds">Getting the Early-Access Builds</h2>

<p>To get started, go to <a href="https://jdk.java.net/valhalla/">jdk.java.net/valhalla</a> and download an early-access JDK build.
You can review the <a href="https://openjdk.org/projects/valhalla/early-access">release notes</a> for a quick summary of what’s included.</p>

<p>Unzip the package, put it somewhere handy, and refer to its <code class="language-plaintext highlighter-rouge">bin</code> directory to run commands like <code class="language-plaintext highlighter-rouge">java</code> and <code class="language-plaintext highlighter-rouge">javac</code>.
On my Mac, I’ll set an environment variable for easy access to these commands in the examples below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; export jdk401="$PWD/jdk-26.jdk/Contents/Home/bin"

% -&gt; "$jdk401"/java --version
openjdk 26-jep401ea2 2026-03-17
OpenJDK Runtime Environment (build 26-jep401ea2+1-1)
OpenJDK 64-Bit Server VM (build 26-jep401ea2+1-1, mixed mode, sharing)
</code></pre></div></div>

<h2 id="experimenting-with-value-objects">Experimenting with Value Objects</h2>

<p>As the JEP explains, <em>value objects</em> are instances of <em>value classes</em>, which have only <code class="language-plaintext highlighter-rouge">final</code> fields and lack object identity.
A handful of JDK classes, including <code class="language-plaintext highlighter-rouge">Integer</code> and <code class="language-plaintext highlighter-rouge">LocalDate</code>, become value classes when we run Java in preview mode.</p>

<p>In JShell, <code class="language-plaintext highlighter-rouge">Objects.hasIdentity</code> makes it easy to tell which objects are value objects and which are regular <em>identity objects</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/jshell --enable-preview
|  Welcome to JShell -- Version 26-jep401ea2
|  For an introduction type: /help intro

jshell&gt; Objects.hasIdentity(Integer.valueOf(123))
$1 ==&gt; false

jshell&gt; Objects.hasIdentity("abc")
$2 ==&gt; true

jshell&gt; Objects.hasIdentity(LocalDate.now())
$3 ==&gt; false

jshell&gt; Objects.hasIdentity(new ArrayList&lt;&gt;())
$4 ==&gt; true
</code></pre></div></div>

<p>Value objects behave just like identity objects in most ways.
But one difference is that <code class="language-plaintext highlighter-rouge">==</code> can’t tell whether two value objects are “the same object” or not—they have no identity to compare.
Instead, <code class="language-plaintext highlighter-rouge">==</code> tests whether two value objects are <em>statewise-equivalent</em>: instances of the same class with the same field values.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jshell&gt; LocalDate d1 = LocalDate.now()
d1 ==&gt; 2025-10-23

jshell&gt; LocalDate d2 = d1.plusDays(365)
d2 ==&gt; 2026-10-23

jshell&gt; LocalDate d3 = d2.minusDays(365)
d3 ==&gt; 2025-10-23

jshell&gt; d1 == d3
$8 ==&gt; true
</code></pre></div></div>

<p>Statewise equivalence is no substitute for a meaningful <code class="language-plaintext highlighter-rouge">equals</code> method designed by a class author. In some cases, two instances of a value class with different states should still be considered equal. 
So the best practice, as usual, is to avoid the <code class="language-plaintext highlighter-rouge">==</code> operator and prefer <code class="language-plaintext highlighter-rouge">equals</code> for comparisons.</p>

<p>You can declare your own value classes with the <code class="language-plaintext highlighter-rouge">value</code> keyword.
Many record declarations are good candidates to be value classes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jshell&gt; value record Point(int x, int y) {}
|  created record Point

jshell&gt; Point p = new Point(17, 3)
p ==&gt; Point[x=17, y=3]

jshell&gt; Objects.hasIdentity(p)
$11 ==&gt; false

jshell&gt; new Point(17, 3) == p
$12 ==&gt; true
</code></pre></div></div>

<h3 id="value-object-performance">Value Object Performance</h3>

<p>Why bother to declare a value class instead of regular identity class?</p>

<p>One reason is a semantic one:
If your class represents immutable domain values that are interchangeable when they have the same state, giving these objects all the features of identity just adds unnecessary complexity.
Better to declare a value class and give up identity entirely.</p>

<p>But the most compelling reason is that the JVM can optimize value objects in ways that are impossible for regular objects.
For example, a reference to a value object doesn’t have to point to a canonical memory location for that object.
Instead, the state of the object can be <em>embedded in the reference itself</em>.
This technique is called <em>heap flattening</em>, and can make a huge difference in the cost of loading objects from memory.</p>

<p>As a test, let’s create a very large array of <code class="language-plaintext highlighter-rouge">LocalDate</code> value objects and add up all of their year values.
To simulate a realistic distribution of objects in memory, we’ll populate the array from an unsorted <code class="language-plaintext highlighter-rouge">HashSet</code> of <code class="language-plaintext highlighter-rouge">LocalDate</code> objects.
We can do some rudimentary profiling by tracking the wall-clock time required to iterate through the array.
(Note: For more accurate profiling, <a href="https://github.com/openjdk/jmh">JMH</a> should be used.)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">50_000_000</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">size</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="nc">LocalDate</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">makeArray</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">sumYears</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="no">IO</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Attempt "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">/// Expensive task to be timed</span>
<span class="kt">long</span> <span class="nf">sumYears</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">[]</span> <span class="n">dates</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">d</span> <span class="o">:</span> <span class="n">dates</span><span class="o">)</span> <span class="n">result</span> <span class="o">+=</span> <span class="n">d</span><span class="o">.</span><span class="na">getYear</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">/// Make an array of LocalDates, unpredictably ordered</span>
<span class="nc">LocalDate</span><span class="o">[]</span> <span class="nf">makeArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">LocalDate</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">.</span><span class="na">ofEpochDay</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">set</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">LocalDate</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
<span class="o">}</span>

<span class="c1">/// Run a task and report the elapsed wall-clock time in ms</span>
<span class="kt">double</span> <span class="nf">time</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="kt">var</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="k">return</span> <span class="nc">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">).</span><span class="na">toNanos</span><span class="o">()</span> <span class="o">/</span> <span class="mf">1_000_000.0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As a baseline, when I put this code in a <code class="language-plaintext highlighter-rouge">DateTest.java</code> file and run it on my MacBook Pro <em>without</em> preview features enabled, I get the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/java DateTest.java
Attempt 1: 82.703
Attempt 2: 77.716
Attempt 3: 74.959
Attempt 4: 71.962
Attempt 5: 71.915
</code></pre></div></div>

<p>When I turn on preview features, <code class="language-plaintext highlighter-rouge">LocalDate</code> becomes a value class, and its instances can be flattened directly in the array.
By avoiding extra memory loads, the JVM can achieve a nearly 3x speedup!:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% -&gt; "$jdk401"/java --enable-preview DateTest.java
Attempt 1: 41.959
Attempt 2: 38.992
Attempt 3: 25.466
Attempt 4: 28.404
Attempt 5: 25.027
</code></pre></div></div>

<p>Results will vary on different machines and different array sizes.
But the point is that by using value objects in our performance-critical computation, we’ve enabled the JVM to make significant new optimizations that are impossible for identity objects.</p>

<h2 id="next-steps">Next Steps</h2>

<p>This is beta software, and it’s sure to have some bugs and surprising performance pitfalls.
Now is a great time for interested users to download the early-access build and try it out on their performance-sensitive workloads.
Feedback at <code class="language-plaintext highlighter-rouge">valhalla-dev@openjdk.org</code> is welcome and encouraged!</p>

<p>Of course, sprinkling the <code class="language-plaintext highlighter-rouge">value</code> keyword around a code base is not going to automatically address whatever performance bottlenecks the program faces.
Users are encouraged to review <a href="https://openjdk.org/jeps/401">JEP 401</a> to get a better sense of what kind of optimizations are possible, and use profiling tools like JDK Flight Recorder to see how value objects affect their program’s performance.</p>]]></content><author><name>[&quot;DanSmith&quot;]</name></author><category term="Valhalla" /><summary type="html"><![CDATA[The Valhalla team recently published an early-access JDK build that fully implements JEP 401: Value Classes and Objects (Preview). Now is a great time for anyone who is interested to try out this transformative new feature!]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 517: HTTP/3 for the HTTP Client API</title><link href="https://inside.java/2025/10/26/jep517-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 517: HTTP/3 for the HTTP Client API" /><published>2025-10-26T00:00:00+00:00</published><updated>2025-10-26T00:00:00+00:00</updated><id>https://inside.java/2025/10/26/JEP517-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/10/26/jep517-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 517: HTTP/3 for the HTTP Client API</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?411944248" /></p>]]></content><author><name>[&quot;DanielFuchs&quot;]</name></author><category term="JDK 26" /><category term="Client" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 517: HTTP/3 for the HTTP Client API]]></summary></entry><entry><title type="html">Writing GPU-Ready AI Models in Pure Java with Babylon</title><link href="https://inside.java/2025/10/25/devoxxbelgium-writing-gpuready-ai-models-in-java/" rel="alternate" type="text/html" title="Writing GPU-Ready AI Models in Pure Java with Babylon" /><published>2025-10-25T00:00:00+00:00</published><updated>2025-10-25T00:00:00+00:00</updated><id>https://inside.java/2025/10/25/DevoxxBelgium-writing-gpuready-ai-models-in-java</id><content type="html" xml:base="https://inside.java/2025/10/25/devoxxbelgium-writing-gpuready-ai-models-in-java/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/DaMgGyfTSSw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Project Babylon enables developers to build and run AI models - such as LLMs, image classifiers, or object detection algorithms - directly in Java. With Code Reflection, machine learning logic can be defined in plain Java code, eliminating the need for Python or external model files.</em> 
<em>By leveraging the Foreign Function and Memory (FFM) API, Babylon can connect Java code to native runtimes like ONNX for fast, GPU-accelerated inference. Additionally, the Heterogeneous Accelerator Toolkit (HAT) enables developers to write and compose compute kernels in Java, making it easy for Java libraries to tap into GPU power for high-performance computing.</em></p>

<p><em>This session introduces Babylon’s upcoming features and demonstrates how you can integrate AI capabilities into the Java ecosystem, appealing to both library maintainers and developers looking to incorporate AI into their Java applications.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;, &quot;LizeRaes&quot;]</name></author><category term="AI" /><category term="Babylon" /><category term="Panama" /><summary type="html"><![CDATA[Project Babylon enables developers to build and run AI models - such as LLMs, image classifiers, or object detection algorithms - directly in Java. With Code Reflection, machine learning logic can be defined in plain Java code, eliminating the need for Python or external model files. By leveraging the Foreign Function and Memory (FFM) API, Babylon can connect Java code to native runtimes like ONNX for fast, GPU-accelerated inference. Additionally, the Heterogeneous Accelerator Toolkit (HAT) enables developers to write and compose compute kernels in Java, making it easy for Java libraries to tap into GPU power for high-performance computing. This session introduces Babylon’s upcoming features and demonstrates how you can integrate AI capabilities into the Java ecosystem, appealing to both library maintainers and developers looking to incorporate AI into their Java applications.]]></summary></entry><entry><title type="html">NUMA-Aware Relocation in ZGC</title><link href="https://inside.java/2025/10/24/zgc-numa-aware-relocation/" rel="alternate" type="text/html" title="NUMA-Aware Relocation in ZGC" /><published>2025-10-24T00:00:00+00:00</published><updated>2025-10-24T00:00:00+00:00</updated><id>https://inside.java/2025/10/24/zgc-numa-aware-relocation</id><content type="html" xml:base="https://inside.java/2025/10/24/zgc-numa-aware-relocation/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;JoelSikstrom&quot;]</name></author><category term="GC" /><category term="JDK 26" /><summary type="html"><![CDATA[NUMA-aware relocation is a feature recently added to ZGC, one of the garbage collectors in the OpenJDK, and is set to be released in JDK 26 through the introduction of JDK-8359683. Building on the recent memory allocation overhaul, this feature further enhances NUMA support and optimization in ZGC.]]></summary></entry><entry><title type="html">Three Upcoming G1 Improvements - Inside Java Newscast #99</title><link href="https://inside.java/2025/10/23/newscast-99/" rel="alternate" type="text/html" title="Three Upcoming G1 Improvements - Inside Java Newscast #99" /><published>2025-10-23T00:00:00+00:00</published><updated>2025-10-23T00:00:00+00:00</updated><id>https://inside.java/2025/10/23/Newscast-99</id><content type="html" xml:base="https://inside.java/2025/10/23/newscast-99/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/w9mY8c72Ouk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Java’s (almost) default garbage collector G1 is undergoing even more improvements:</em> 
<em>From the already merged JEP 522, which introduces a second card table for improved throughput, and the candidate JEP 523,</em> 
<em>which aims to make G1 the default even where Serial GC used to be, to draft proposals for automatic heap sizing for G1 and ZGC.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=w9mY8c72Ouk">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="GC" /><summary type="html"><![CDATA[Java's (almost) default garbage collector G1 is undergoing even more improvements: From the already merged JEP 522, which introduces a second card table for improved throughput, and the candidate JEP 523, which aims to make G1 the default even where Serial GC used to be, to draft proposals for automatic heap sizing for G1 and ZGC.]]></summary></entry></feed>