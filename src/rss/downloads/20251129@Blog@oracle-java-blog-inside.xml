<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://inside.java/feed.xml" rel="self" type="application/atom+xml" /><link href="https://inside.java/" rel="alternate" type="text/html" /><updated>2025-11-29T11:51:27+00:00</updated><id>https://inside.java/feed.xml</id><title type="html">insidejava</title><subtitle>News and views from members of the Java team at Oracle</subtitle><entry><title type="html">Garbage Collection in Java: Choosing the Correct Collector</title><link href="https://inside.java/2025/11/29/devoxxbelgium-choose-correct-gc/" rel="alternate" type="text/html" title="Garbage Collection in Java: Choosing the Correct Collector" /><published>2025-11-29T00:00:00+00:00</published><updated>2025-11-29T00:00:00+00:00</updated><id>https://inside.java/2025/11/29/DevoxxBelgium-Choose-Correct-GC</id><content type="html" xml:base="https://inside.java/2025/11/29/devoxxbelgium-choose-correct-gc/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/2Obf2LqEvyk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Garbage collection (GC) is a type of automatic memory management and a key feature of the Java platform. It allows developers to focus on their application logic rather than low-level memory management issues.</em></p>

<p><em>The Java platform implements multiple garbage collection algorithms, making it suitable for handling all kinds of workloads. The default collector, G1, is often a great choice, but depending on your use case, another GC might provide even better performance. This video explores:</em></p>

<ul>
  <li><em>the basics of garbage collection</em></li>
  <li><em>why there are multiple collectors</em></li>
  <li><em>key characteristics of G1 and ZGC</em></li>
  <li><em>the performance differences between collectors and JDK releases.</em></li>
</ul>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;StefanJohansson&quot;]</name></author><category term="GC" /><summary type="html"><![CDATA[Garbage collection (GC) is a type of automatic memory management and a key feature of the Java platform. It allows developers to focus on their application logic rather than low-level memory management issues. The Java platform implements multiple garbage collection algorithms, making it suitable for handling all kinds of workloads. The default collector, G1, is often a great choice, but depending on your use case, another GC might provide even better performance. This video explores: the basics of garbage collection, why there are multiple collectors, key characteristics of G1 and ZGC and the performance differences between collectors and JDK releases.]]></summary></entry><entry><title type="html">Help, My Java Object Vanished (and the GC is Not at Fault)</title><link href="https://inside.java/2025/11/28/markword/" rel="alternate" type="text/html" title="Help, My Java Object Vanished (and the GC is Not at Fault)" /><published>2025-11-28T00:00:00+00:00</published><updated>2025-11-28T00:00:00+00:00</updated><id>https://inside.java/2025/11/28/Markword</id><content type="html" xml:base="https://inside.java/2025/11/28/markword/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>]]></content><author><name>[&quot;PaulHubner&quot;]</name></author><category term="HotSpot" /><category term="Valhalla" /><summary type="html"><![CDATA[This post provides an insight into Project Valhalla development, while offering insights into the inner workings of HotSpot. It also pragmatically demonstrates how JVM flags can be used to help you, and shares some lessons learned when debugging HotSpot.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 526: Lazy Constants (Second Preview)</title><link href="https://inside.java/2025/11/27/jep526-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 526: Lazy Constants (Second Preview)" /><published>2025-11-27T00:00:00+00:00</published><updated>2025-11-27T00:00:00+00:00</updated><id>https://inside.java/2025/11/27/JEP526-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/27/jep526-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 526: Lazy Constants (Second Preview)</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?467381799" /></p>]]></content><author><name>[&quot;Per-AkeMinborg&quot;, &quot;MaurizioCimadamore&quot;]</name></author><category term="JDK 26" /><category term="Core Libraries" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 526: Lazy Constants (Second Preview)]]></summary></entry><entry><title type="html">Quality Outreach Heads-up - JDK 26: HttpClient Supports TLS Named Groups &amp;amp; Signature Schemes</title><link href="https://inside.java/2025/11/26/quality-heads-up/" rel="alternate" type="text/html" title="Quality Outreach Heads-up - JDK 26: HttpClient Supports TLS Named Groups &amp;amp; Signature Schemes" /><published>2025-11-26T00:00:00+00:00</published><updated>2025-11-26T00:00:00+00:00</updated><id>https://inside.java/2025/11/26/Quality-Heads-Up</id><content type="html" xml:base="https://inside.java/2025/11/26/quality-heads-up/"><![CDATA[<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/code.jpg" /></p>

<p><i>The <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">OpenJDK Quality Group</a> is promoting the testing of FOSS projects with OpenJDK builds as a way to improve the overall quality of the release. This heads-up is part of the <a href="https://mail.openjdk.org/pipermail/quality-discuss/">quality outreach</a> sent to the projects involved. To learn more about the program, and how-to join, please check <a href="https://wiki.openjdk.java.net/display/quality/Quality+Outreach">here</a>.</i></p>

<h2 id="tls-named-groups-and-signature-schemes-setup-for-httpclient">TLS Named Groups and Signature Schemes Setup for HttpClient</h2>

<p>Java applications can configure TLS constraints on <code class="language-plaintext highlighter-rouge">javax.net.ssl.SSLParameters</code> during the setup of new connections.
Yet, as of now, <code class="language-plaintext highlighter-rouge">HttpClient</code> ignores named groups and signature schemes set on <code class="language-plaintext highlighter-rouge">SSLParameters</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">restrictedNamedGroups</span> <span class="o">=</span> <span class="o">{</span><span class="s">"x25519"</span><span class="o">,</span><span class="s">"x448"</span><span class="o">};</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">preferredSignatureScheme</span> <span class="o">=</span> <span class="o">{</span><span class="s">"ed25519"</span><span class="o">,</span><span class="s">"ed448"</span><span class="o">};</span>

<span class="kd">final</span> <span class="nc">SSLParameters</span> <span class="n">sslParameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SSLParameters</span><span class="o">();</span>
<span class="n">sslParameters</span><span class="o">.</span><span class="na">setNamedGroups</span><span class="o">(</span><span class="n">restrictedNamedGroups</span><span class="o">);</span>
<span class="n">sslParameters</span><span class="o">.</span><span class="na">setSignatureSchemes</span><span class="o">(</span><span class="n">preferredSignatureScheme</span><span class="o">);</span>

<span class="nc">SSLContext</span> <span class="n">sslContext</span> <span class="o">=</span> <span class="nc">SSLContext</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>

<span class="nc">HttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">sslContext</span><span class="o">(</span><span class="n">sslContext</span><span class="o">)</span>
    <span class="o">.</span><span class="na">sslParameters</span><span class="o">(</span><span class="n">sslParameters</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>Starting with JDK 26, the <code class="language-plaintext highlighter-rouge">java.net.http.HttpClient</code> preserves the signature schemes and named groups configured via <code class="language-plaintext highlighter-rouge">SSLParameters</code> when negotiating the TLS handshake.</p>

<p>This fix has been incorporated into the 26-ea mainline build available <a href="https://jdk.java.net/26/">here</a>. For more details on this change, check the JBS issue: <a href="https://bugs.openjdk.org/browse/JDK-8367112">JDK-8367112</a>.</p>

<center>~</center>]]></content><author><name>[&quot;Ana-MariaMihalceanu&quot;]</name></author><category term="JDK 26" /><category term="Security" /><category term="Networking" /><summary type="html"><![CDATA[This Heads-Up is part of the regular communication sent to the projects involved; it covers how HttpClient supports TLS signature schemes and named groups configured on SSLParameters.]]></summary></entry><entry><title type="html">ONNX Based Generative AI LLMs in Java with Project Babylon</title><link href="https://inside.java/2025/11/25/devoxxbelgium-java-generative-ai/" rel="alternate" type="text/html" title="ONNX Based Generative AI LLMs in Java with Project Babylon" /><published>2025-11-25T00:00:00+00:00</published><updated>2025-11-25T00:00:00+00:00</updated><id>https://inside.java/2025/11/25/DevoxxBelgium-Java-Generative-AI</id><content type="html" xml:base="https://inside.java/2025/11/25/devoxxbelgium-java-generative-ai/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/4grpNophot0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>The Open Neural Network Exchange (ONNX) serves as a universal format for representing machine learning models, facilitating their deployment across diverse platforms. Traditionally, Large Language Models (LLMs) are developed in Python using frameworks like PyTorch, TensorFlow, or scikit-learn, and then exported to ONNX for execution.</em></p>

<p><em>In this presentation, we demonstrate how Java, a language not traditionally associated with AI modeling, can be utilized to produce ONNX models. We also explore the concept of ONNX-based Generative AI LLMs in Java, leveraging Project Babylon’s code reflection capabilities.</em></p>

<p><em>The presentation showcases a practical Java example of an LLM, detailing its transformation into the ONNX format and subsequent execution.</em></p>

<p>Recorded at <a href="https://devoxx.be/">Devoxx Belgium 2025</a>.</p>]]></content><author><name>[&quot;AdamSotona&quot;]</name></author><category term="AI" /><category term="Babylon" /><summary type="html"><![CDATA[The Open Neural Network Exchange (ONNX) serves as a universal format for representing machine learning models, facilitating their deployment across diverse platforms. Traditionally, Large Language Models (LLMs) are developed in Python using frameworks like PyTorch, TensorFlow, or scikit-learn, and then exported to ONNX for execution. In this presentation, we demonstrate how Java, a language not traditionally associated with AI modeling, can be utilized to produce ONNX models. We also explore the concept of ONNX-based Generative AI LLMs in Java, leveraging Project Babylon's code reflection capabilities. The presentation showcases a practical Java example of an LLM, detailing its transformation into the ONNX format and subsequent execution.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 525: Structured Concurrency (6th Preview)</title><link href="https://inside.java/2025/11/24/jep525-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 525: Structured Concurrency (6th Preview)" /><published>2025-11-24T00:00:00+00:00</published><updated>2025-11-24T00:00:00+00:00</updated><id>https://inside.java/2025/11/24/JEP525-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/24/jep525-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 525: Structured Concurrency (Sixth Preview)</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?454600550" /></p>]]></content><author><name>[&quot;AlanBateman&quot;, &quot;ViktorKlang&quot;, &quot;RonPressler&quot;]</name></author><category term="JDK 26" /><category term="Loom" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 525: Structured Concurrency (Sixth Preview)]]></summary></entry><entry><title type="html">Symbolic Modeling and Transformation of Java Code #JVMLS</title><link href="https://inside.java/2025/11/22/jvmls-symbolic-modelling-java-transformation/" rel="alternate" type="text/html" title="Symbolic Modeling and Transformation of Java Code #JVMLS" /><published>2025-11-22T00:00:00+00:00</published><updated>2025-11-22T00:00:00+00:00</updated><id>https://inside.java/2025/11/22/JVMLS-Symbolic-Modelling-Java-Transformation</id><content type="html" xml:base="https://inside.java/2025/11/22/jvmls-symbolic-modelling-java-transformation/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/jbXobiQN8Fw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>This session explores code reflection in Project Babylon, demonstrating how Java code can be symbolically modeled as Java code models. It covers the underlying approach, highlights key advantages, and discusses potential limitations.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;PaulSandoz&quot;]</name></author><category term="Babylon" /><summary type="html"><![CDATA[This session explores code reflection in Project Babylon, demonstrating how Java code can be symbolically modeled as Java code models. It covers the underlying approach, highlights key advantages, and discusses potential limitations.]]></summary></entry><entry><title type="html">Java 26 Warns of Deep Reflection - Inside Java Newscast #101</title><link href="https://inside.java/2025/11/20/newscast-101/" rel="alternate" type="text/html" title="Java 26 Warns of Deep Reflection - Inside Java Newscast #101" /><published>2025-11-20T00:00:00+00:00</published><updated>2025-11-20T00:00:00+00:00</updated><id>https://inside.java/2025/11/20/Newscast-101</id><content type="html" xml:base="https://inside.java/2025/11/20/newscast-101/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/bdHkbEIdBAs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Java 26 will issue run-time warnings when a final field is mutated through reflection. This prepares for a future change that will make such final field mutations illegal by default to improve Java’s integrity, specifically the keyword <code class="language-plaintext highlighter-rouge">final</code>. 
This will have beneficial effects on maintainability, security, and performance. While the recommendation is to move away from final field mutation, the new permanent command-line option <code class="language-plaintext highlighter-rouge">--enable-final-field-mutation</code> allows it for selected modules. To ease migration, the more general but temporary option <code class="language-plaintext highlighter-rouge">--illegal-final-field-mutation</code> was also introduced.</em></p>

<p><em>Make sure to check the <a href="https://www.youtube.com/watch?v=bdHkbEIdBAs">show-notes</a>.</em></p>]]></content><author><name>[&quot;NicolaiParlog&quot;]</name></author><category term="JDK 26" /><category term="Integrity by Default" /><summary type="html"><![CDATA[Java 26 will issue run-time warnings when a final field is mutated through reflection. This prepares for a future change that will make such final field mutations illegal by default to improve Java's integrity, specifically the keyword final. This will have beneficial effects on maintainability, security, and performance. While the recommendation is to move away from final field mutation, the new permanent command-line option --enable-final-field-mutation allows it for selected modules. To ease migration, the more general but temporary option --illegal-final-field-mutation was also introduced.]]></summary></entry><entry><title type="html">JEP targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)</title><link href="https://inside.java/2025/11/17/jep524-target-jdk26/" rel="alternate" type="text/html" title="JEP targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)" /><published>2025-11-17T00:00:00+00:00</published><updated>2025-11-17T00:00:00+00:00</updated><id>https://inside.java/2025/11/17/JEP524-target-JDK26</id><content type="html" xml:base="https://inside.java/2025/11/17/jep524-target-jdk26/"><![CDATA[<p>The following JEP is targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)</p>

<p><img class="webfeedsFeaturedVisual" style="display: none;" src="/images/thumbnail/jep.jpg?443101541" /></p>]]></content><author><name>[&quot;AnthonyScarpino&quot;]</name></author><category term="JDK 26" /><category term="Security" /><summary type="html"><![CDATA[The following JEP is targeted to JDK 26: 524: PEM Encodings of Cryptographic Objects (Second Preview)]]></summary></entry><entry><title type="html">Beyond the Vector API - A Quest for a Lower Level API #JVMLS</title><link href="https://inside.java/2025/11/16/jvmls-vector-api/" rel="alternate" type="text/html" title="Beyond the Vector API - A Quest for a Lower Level API #JVMLS" /><published>2025-11-16T00:00:00+00:00</published><updated>2025-11-16T00:00:00+00:00</updated><id>https://inside.java/2025/11/16/JVMLS-Vector-API</id><content type="html" xml:base="https://inside.java/2025/11/16/jvmls-vector-api/"><![CDATA[<div class="youtube-embed">
    <iframe src="https://www.youtube.com/embed/YZLVj4UVSj0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<p><em>Throughout the project, the Vector API balanced providing a cross-platform API with staying close to the metal, performance-wise.</em></p>

<p><em>While the project succeeded in that goal, the Vector API had to give up some important functionality when it didn’t fit the design. As a result, the API became unsuitable for implementing an important class of vectorized algorithms that depend on access to particular hardware functionality. With recent progress in Project Panama (on the Foreign Function &amp; Memory API and <code class="language-plaintext highlighter-rouge">jextract</code>), new opportunities have emerged to bring Java even closer to hardware.</em></p>

<p><em>The talk covers how the Vector API evolved (from machine code snippets to JVM intrinsics), and then focus on a novel approach to providing access to individual machine code instructions from Java code in a performant manner. Such a “hardware intrinsics” API complements the Vector API by providing access to low-level platform-specific primitives. It opens up new opportunities for the Java Platform and enables simplifications in the Vector API, JDK, and JVM implementations.</em></p>

<p><em>Make sure to check <a href="https://www.youtube.com/playlist?list=PLX8CzqL3ArzUOgZpIX6GsoRhPbnij-sco">the JVMLS 2025 playlist</a>.</em></p>]]></content><author><name>[&quot;VladimirIvanov&quot;]</name></author><category term="Panama" /><summary type="html"><![CDATA[Throughout the project, the Vector API balanced providing a cross-platform API with staying close to the metal, performance-wise. While the project succeeded in that goal, the Vector API had to give up some important functionality when it didn't fit the design. As a result, the API became unsuitable for implementing an important class of vectorized algorithms that depend on access to particular hardware functionality. With recent progress in Project Panama (on the Foreign Function & Memory API and jextract), new opportunities have emerged to bring Java even closer to hardware. The talk covers how the Vector API evolved (from machine code snippets to JVM intrinsics), and then focus on a novel approach to providing access to individual machine code instructions from Java code in a performant manner. Such a "hardware intrinsics" API complements the Vector API by providing access to low-level platform-specific primitives. It opens up new opportunities for the Java Platform and enables simplifications in the Vector API, JDK, and JVM implementations.]]></summary></entry></feed>